2.13-33 dates when this was added

TODO: _DEBIAN_ in versions however pose problem. Remove the _DEBIAN_ version
once packages are rebuilt against 2.21.

2010-08-04  Emilio Pozuelo Monfort  <pochu27@gmail.com>
2017-09-26  Svante Signell  <svante.signell@gmail.com>
	* hurd/hurdexec.c (_hurd_exec): Deprecate it.
	(_hurd_exec_file_name): New function.
	* hurd/hurd.h (_hurd_exec): Deprecate it.
	(_hurd_exec_file_name): Declare it.
	* hurd/Versions: Export it.
	* sysdeps/mach/hurd/execve.c: Use it.
	* sysdeps/mach/hurd/fexecve.c: Likewise.
	* sysdeps/mach/hurd/spawni.c: Likewise.


From d1793416cf8bf6fccd42679a8ec30b0058823ab8 Mon Sep 17 00:00:00 2001
From: Emilio Pozuelo Monfort <pochu27@gmail.com>
Date: Sat, 22 May 2010 18:26:29 +0200
Subject: [PATCH] Use the new file_exec_file_name RPC

Pass the file name of executable to the exec server, which it needs to
execute #!-scripts.  Currently, the exec server tries to guess the name
from argv[0] but argv[0] only contains the executable name by convention.
---
 hurd/Makefile               |    4 -
 hurd/Versions               |    8 +++
 hurd/hurd.h                 |   12 ++++-
 hurd/hurdexec.c             |   63 +++++++++++++++++++++++----
 sysdeps/mach/hurd/execve.c  |   34 ++++++++++++++
 sysdeps/mach/hurd/fexecve.c |    5 +-
 sysdeps/mach/hurd/spawni.c  |  100 +++++++++++++++++++++++++++++++++-----------
 7 files changed, 184 insertions(+), 42 deletions(-)

--- a/hurd/Versions
+++ b/hurd/Versions
@@ -140,6 +140,14 @@ libc {
     _hurd_sigstate_unlock;
     _hurd_sigstate_delete;
   }
+  GLIBC_2.13_DEBIAN_33 {
+    # "quasi-internal" functions
+    _hurd_exec_file_name;
+  }
+  GLIBC_2.21 {
+    # "quasi-internal" functions
+    _hurd_exec_file_name;
+  }
 
   HURD_CTHREADS_0.3 {
     # weak refs to libthreads functions that libc calls iff libthreads in use
--- a/hurd/Makefile
+++ b/hurd/Makefile
@@ -32,8 +32,8 @@ user-interfaces		:= $(addprefix hurd/,\
 				       auth auth_request auth_reply startup \
 				       process process_request \
 				       msg msg_reply msg_request \
-				       exec exec_startup crash interrupt \
-				       fs fsys io term tioctl socket ifsock \
+				       exec exec_experimental exec_startup crash interrupt \
+				       fs fs_experimental fsys io term tioctl socket ifsock \
 				       login password pfinet \
 				       )
 server-interfaces	:= hurd/msg faultexc
--- a/hurd/hurd.h
+++ b/hurd/hurd.h
@@ -241,12 +241,20 @@ extern FILE *fopenport (io_t port, const
 extern FILE *__fopenport (io_t port, const char *mode);
 
 
-/* Execute a file, replacing TASK's current program image.  */
+/* Deprecated: use _hurd_exec_file_name instead.  */
 
 extern error_t _hurd_exec (task_t task,
 			   file_t file,
 			   char *const argv[],
-			   char *const envp[]);
+			   char *const envp[]) __attribute_deprecated__;
+
+/* Execute a file, replacing TASK's current program image.  */
+
+extern error_t _hurd_exec_file_name (task_t task,
+				     file_t file,
+				     const char *filename,
+				     char *const argv[],
+				     char *const envp[]);
 
 
 /* Inform the proc server we have exited with STATUS, and kill the
--- a/hurd/hurdexec.c
+++ b/hurd/hurdexec.c
@@ -25,16 +25,37 @@
 #include <hurd/fd.h>
 #include <hurd/signal.h>
 #include <hurd/id.h>
+#include <hurd/fs_experimental.h>
 #include <assert.h>
 #include <argz.h>
 
+#include <shlib-compat.h>
+
 /* Overlay TASK, executing FILE with arguments ARGV and environment ENVP.
    If TASK == mach_task_self (), some ports are dealloc'd by the exec server.
-   ARGV and ENVP are terminated by NULL pointers.  */
+   ARGV and ENVP are terminated by NULL pointers.
+   Deprecated: use _hurd_exec_file_name instead.  */
 error_t
 _hurd_exec (task_t task, file_t file,
 	    char *const argv[], char *const envp[])
 {
+  return _hurd_exec_file_name (task, file, NULL, argv, envp);
+}
+
+link_warning (_hurd_exec,
+	      "_hurd_exec is deprecated, use _hurd_exec_file_name instead");
+
+/* Overlay TASK, executing FILE with arguments ARGV and environment ENVP.
+   If TASK == mach_task_self (), some ports are dealloc'd by the exec server.
+   ARGV and ENVP are terminated by NULL pointers.  FILENAME is the path
+   (either absolute or relative) to FILE.  Passing NULL, though possible,
+   should be avoided, since then the exec server may not know the path to
+   FILE if FILE is a script, and will then pass /dev/fd/N to the
+   interpreter.  */
+error_t
+__hurd_exec_file_name (task_t task, file_t file, const char *filename,
+		      char *const argv[], char *const envp[])
+{
   error_t err;
   char *args, *env;
   size_t argslen, envlen;
@@ -216,7 +237,7 @@ _hurd_exec (task_t task, file_t file,
       /* We have euid != svuid or egid != svgid.  POSIX.1 says that exec
 	 sets svuid = euid and svgid = egid.  So we must get a new auth
 	 port and reauthenticate everything with it.  We'll pass the new
-	 ports in file_exec instead of our own ports.  */
+	 ports in file_exec_file_name instead of our own ports.  */
 
       auth_t newauth;
 
@@ -360,13 +381,27 @@ _hurd_exec (task_t task, file_t file,
       if (__sigismember (&_hurdsig_traced, SIGKILL))
 	flags |= EXEC_SIGTRAP;
 #endif
-      err = __file_exec (file, task, flags,
-			 args, argslen, env, envlen,
-			 dtable, MACH_MSG_TYPE_COPY_SEND, dtablesize,
-			 ports, MACH_MSG_TYPE_COPY_SEND, _hurd_nports,
-			 ints, INIT_INT_MAX,
-			 please_dealloc, pdp - please_dealloc,
-			 &_hurd_msgport, task == __mach_task_self () ? 1 : 0);
+      err = __file_exec_file_name (file, task, flags,
+				   filename ? filename : "",
+				   args, argslen, env, envlen,
+				   dtable, MACH_MSG_TYPE_COPY_SEND, dtablesize,
+				   ports, MACH_MSG_TYPE_COPY_SEND,
+				   _hurd_nports,
+				   ints, INIT_INT_MAX,
+				   please_dealloc, pdp - please_dealloc,
+				   &_hurd_msgport,
+				   task == __mach_task_self () ? 1 : 0);
+      /* Fall back for backwards compatibility.  This can just be removed
+         when __file_exec goes away.  */
+      if (err == MIG_BAD_ID)
+	err = __file_exec (file, task, flags,
+			   args, argslen, env, envlen,
+			   dtable, MACH_MSG_TYPE_COPY_SEND, dtablesize,
+			   ports, MACH_MSG_TYPE_COPY_SEND, _hurd_nports,
+			   ints, INIT_INT_MAX,
+			   please_dealloc, pdp - please_dealloc,
+			   &_hurd_msgport,
+			   task == __mach_task_self () ? 1 : 0);
     }
 
   /* Release references to the standard ports.  */
@@ -401,3 +436,13 @@ _hurd_exec (task_t task, file_t file,
   free (env);
   return err;
 }
+versioned_symbol (libc, __hurd_exec_file_name, _hurd_exec_file_name, GLIBC_2_21);
+#if SHLIB_COMPAT (libc, GLIBC_2_13, GLIBC_2_21)
+error_t
+__hurd_exec_file_name_2_13 (task_t task, file_t file, const char *filename,
+		      char *const argv[], char *const envp[])
+{
+  return __hurd_exec_file_name (task, file, filename, argv, envp);
+}
+compat_symbol (libc, __hurd_exec_file_name_2_13, _hurd_exec_file_name, GLIBC_2_13_DEBIAN_33);
+#endif
--- a/sysdeps/mach/hurd/execve.c
+++ b/sysdeps/mach/hurd/execve.c
@@ -18,6 +18,8 @@
 #include <unistd.h>
 #include <hurd.h>
 #include <fcntl.h>
+#include <stdlib.h>
+#include <stdio.h>
 
 /* Replace the current process, executing FILE_NAME with arguments ARGV and
    environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */
@@ -25,17 +27,45 @@ int
 __execve (const char *file_name, char *const argv[], char *const envp[])
 {
   error_t err;
-  file_t file = __file_name_lookup (file_name, O_EXEC, 0);
+  char *concat_name = NULL;
+  const char *abs_name;
 
+  file_t file = __file_name_lookup (file_name, O_EXEC, 0);
   if (file == MACH_PORT_NULL)
     return -1;
 
+  if (file_name[0] == '/')
+    {
+      /* Absolute path */
+      abs_name = file_name;
+    }
+  else
+    {
+      /* Relative path */
+      char *cwd = __getcwd (NULL, 0);
+      if (cwd == NULL)
+	{
+	  __mach_port_deallocate (__mach_task_self (), file);
+	  return -1;
+	}
+      int res = __asprintf (&concat_name, "%s/%s", cwd, file_name);
+      free (cwd);
+      if (res == -1)
+	{
+	  __mach_port_deallocate (__mach_task_self (), file);
+	  return -1;
+	}
+      abs_name = concat_name;
+    }
+
   /* Hopefully this will not return.  */
-  err = _hurd_exec (__mach_task_self (), file, argv, envp);
+  err = _hurd_exec_file_name (__mach_task_self (), file,
+			      abs_name, argv, envp);
 
   /* Oh well.  Might as well be tidy.  */
   __mach_port_deallocate (__mach_task_self (), file);
 
+  free (concat_name);
   return __hurd_fail (err);
 }
 
--- a/sysdeps/mach/hurd/fexecve.c
+++ b/sysdeps/mach/hurd/fexecve.c
@@ -25,8 +25,9 @@
 int
 fexecve (int fd, char *const argv[], char *const envp[])
 {
-  error_t err = HURD_DPORT_USE (fd, _hurd_exec (__mach_task_self (), port,
-						argv, envp));
+  error_t err = HURD_DPORT_USE (fd, _hurd_exec_file_name (__mach_task_self (),
+							  port, NULL,
+							  argv, envp));
   if (! err)
     err = EGRATUITOUS;
   return __hurd_fail (err);
--- a/sysdeps/mach/hurd/spawni.c
+++ b/sysdeps/mach/hurd/spawni.c
@@ -22,6 +22,7 @@
 #include <spawn.h>
 #include <stdlib.h>
 #include <string.h>
+#include <stdio.h>
 #include <unistd.h>
 #include <hurd.h>
 #include <hurd/signal.h>
@@ -29,6 +30,7 @@
 #include <hurd/id.h>
 #include <hurd/lookup.h>
 #include <hurd/resource.h>
+#include <hurd/fs_experimental.h>
 #include <assert.h>
 #include <argz.h>
 #include "spawn_int.h"
@@ -44,8 +46,9 @@ __spawni (pid_t *pid, const char *file,
 {
   pid_t new_pid;
   char *path, *p, *name;
-  size_t len;
-  size_t pathlen;
+  char *concat_name = NULL, *filename;
+  int res;
+  size_t len, pathlen;
   short int flags;
 
   /* The generic POSIX.1 implementation of posix_spawn uses fork and exec.
@@ -59,14 +62,14 @@ __spawni (pid_t *pid, const char *file,
      that remains visible after an exec is registration with the proc
      server, and the inheritance of various values and ports.  All those
      inherited values and ports are what get collected up and passed in the
-     file_exec RPC by an exec call.  So we do the proc server registration
-     here, following the model of fork (see fork.c).  We then collect up
-     the inherited values and ports from this (parent) process following
-     the model of exec (see hurd/hurdexec.c), modify or replace each value
-     that fork would (plus the specific changes demanded by ATTRP and
-     FILE_ACTIONS), and make the file_exec RPC on the requested executable
-     file with the child process's task port rather than our own.  This
-     should be indistinguishable from the fork + exec implementation,
+     file_exec_file_name RPC by an exec call.  So we do the proc server
+     registration here, following the model of fork (see fork.c).  We then
+     collect up the inherited values and ports from this (parent) process
+     following the model of exec (see hurd/hurdexec.c), modify or replace each
+     value that fork would (plus the specific changes demanded by ATTRP and
+     FILE_ACTIONS), and make the file_exec_file_name RPC on the requested
+     executable file with the child process's task port rather than our own.
+     This should be indistinguishable from the fork + exec implementation,
      except that all errors will be detected here (in the parent process)
      and return proper errno codes rather than the child dying with 127.
 
@@ -545,8 +548,29 @@ __spawni (pid_t *pid, const char *file,
      etc) can be observed before what errors.  */
 
   if ((xflags & SPAWN_XFLAGS_USE_PATH) == 0 || strchr (file, '/') != NULL)
-    /* The FILE parameter is actually a path.  */
-    err = child_lookup (file, O_EXEC, 0, &execfile);
+    {
+      /* The FILE parameter is actually a path.  */
+      if (file[0] == '/')
+	{
+	  /* Absolute path */
+	  filename = file;
+	}
+      else
+	{
+	  /* Relative path */
+	  char *cwd = getcwd (NULL, 0);
+	  if (cwd == NULL)
+	    goto out;
+
+	  res = __asprintf (&concat_name, "%s/%s", cwd, file);
+	  free (cwd);
+	  if (res == -1)
+	    goto out;
+
+	  filename = concat_name;
+	}
+      err = child_lookup (filename, O_EXEC, 0, &execfile);
+    }
   else
     {
       /* We have to search for FILE on the path.  */
@@ -573,20 +597,18 @@ __spawni (pid_t *pid, const char *file,
       p = path;
       do
 	{
-	  char *startp;
-
 	  path = p;
 	  p = __strchrnul (path, ':');
 
 	  if (p == path)
 	    /* Two adjacent colons, or a colon at the beginning or the end
 	       of `PATH' means to search the current directory.  */
-	    startp = name + 1;
+	    filename = name + 1;
 	  else
-	    startp = (char *) memcpy (name - (p - path), path, p - path);
+	    filename = (char *) memcpy (name - (p - path), path, p - path);
 
 	  /* Try to open this file name.  */
-	  err = child_lookup (startp, O_EXEC, 0, &execfile);
+	  err = child_lookup (filename, O_EXEC, 0, &execfile);
 	  switch (err)
 	    {
 	    case EACCES:
@@ -607,6 +629,20 @@ __spawni (pid_t *pid, const char *file,
 	    }
 
 	  // We only get here when we are done looking for the file.
+	  if (filename[0] != '/')
+	    {
+	      /* Relative path */
+	      char *cwd = getcwd (NULL, 0);
+	      if (cwd == NULL)
+		goto out;
+
+	      res = __asprintf (&concat_name, "%s/%s", cwd, filename);
+	      free (cwd);
+	      if (res == -1)
+		goto out;
+
+	      filename = concat_name;
+	    }
 	  break;
 	}
       while (*p++ != '\0');
@@ -623,14 +659,27 @@ __spawni (pid_t *pid, const char *file,
 
     inline error_t exec (file_t file)
       {
-	return __file_exec (file, task,
-			    (__sigismember (&_hurdsig_traced, SIGKILL)
-			     ? EXEC_SIGTRAP : 0),
-			    args, argslen, env, envlen,
-			    dtable, MACH_MSG_TYPE_COPY_SEND, dtablesize,
-			    ports, MACH_MSG_TYPE_COPY_SEND, _hurd_nports,
-			    ints, INIT_INT_MAX,
-			    NULL, 0, NULL, 0);
+	error_t err = __file_exec_file_name
+	  (file, task,
+	   __sigismember (&_hurdsig_traced, SIGKILL) ? EXEC_SIGTRAP : 0,
+	   filename, args, argslen, env, envlen,
+	   dtable, MACH_MSG_TYPE_COPY_SEND, dtablesize,
+	   ports, MACH_MSG_TYPE_COPY_SEND, _hurd_nports,
+	   ints, INIT_INT_MAX, NULL, 0, NULL, 0);
+
+	/* Fallback for backwards compatibility.  This can just be removed
+	   when __file_exec goes away.  */
+	if (err == MIG_BAD_ID)
+	  return __file_exec (file, task,
+			      (__sigismember (&_hurdsig_traced, SIGKILL)
+			      ? EXEC_SIGTRAP : 0),
+			      args, argslen, env, envlen,
+			      dtable, MACH_MSG_TYPE_COPY_SEND, dtablesize,
+			      ports, MACH_MSG_TYPE_COPY_SEND, _hurd_nports,
+			      ints, INIT_INT_MAX,
+			      NULL, 0, NULL, 0);
+
+	return err;
       }
 
     /* Now we are out of things that can fail before the file_exec RPC,
@@ -749,6 +798,7 @@ __spawni (pid_t *pid, const char *file,
 	    _hurd_port_free (dtable_cells[i], &ulink_dtable[i], dtable[i]);
 	}
 
+  free (concat_name);
   if (err)
     /* This hack canonicalizes the error code that we return.  */
     err = (__hurd_fail (err), errno);
