GIT update of git://sourceware.org/git/glibc.git/release/2.26/master from glibc-2.26

diff --git a/ChangeLog b/ChangeLog
index 8dbfc7eaff..ff9bc2b7eb 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,386 @@
+2017-10-10  Steve Ellcey  <sellcey@cavium.com>
+
+	* sysdeps/unix/sysv/linux/aarch64/cpu-features.c (get_midr_from_mcpu):
+	Use strcmp instead of tunable_is_name.
+
+2017-10-10  Siddhesh Poyarekar  <siddhesh@sourceware.org>
+
+	* sysdeps/aarch64/multiarch/Makefile (sysdep_routines): Add
+	memmove_falkor.
+	* sysdeps/aarch64/multiarch/ifunc-impl-list.c
+	(__libc_ifunc_impl_list): Likewise.
+	* sysdeps/aarch64/multiarch/memmove.c: Likewise.
+	* sysdeps/aarch64/multiarch/memmove_falkor.S: New file.
+
+	* benchtests/bench-memmove-walk.c: New file.
+	* benchtests/Makefile (string-benchset): Add it.
+
+	* benchtests/bench-memset-walk.c: New file.
+	* benchtests/Makefile (string-benchset): Add it.
+
+	* benchtests/bench-memcpy-walk.c: New file.
+	* benchtests/Makefile (string-benchset): Add it.
+
+	* po/sv.po: Update translations.
+	* po/fr.po: Likewise.
+
+	* sysdeps/aarch64/multiarch/memcpy_falkor.S: Fix code style in
+	comments.
+
+	* manual/tunables.texi (Tunable glibc.tune.cpu): Add falkor.
+	* sysdeps/aarch64/multiarch/Makefile (sysdep_routines): Add
+	memcpy_falkor.
+	* sysdeps/aarch64/multiarch/ifunc-impl-list.c (MAX_IFUNC):
+	Bump.
+	(__libc_ifunc_impl_list): Add __memcpy_falkor.
+	* sysdeps/aarch64/multiarch/memcpy.c: Likewise.
+	* sysdeps/aarch64/multiarch/memcpy_falkor.S: New file.
+	* sysdeps/unix/sysv/linux/aarch64/cpu-features.c (cpu_list):
+	Add falkor.
+	* sysdeps/unix/sysv/linux/aarch64/cpu-features.h (IS_FALKOR):
+	New macro.
+
+2017-10-06  Carlos O'Donell  <carlos@redhat.com>
+
+	[BZ #22111]
+	* malloc/malloc.c (tcache_shutting_down): Use bool type.
+	(tcache_thread_freeres): Set tcache_shutting_down before
+	freeing the tcache.
+	* malloc/Makefile (tests): Add tst-malloc-tcache-leak.
+	* malloc/tst-malloc-tcache-leak.c: New file.
+
+2017-10-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* math/test-math-iscanonical.cc (error): Replace bool with int.
+	(do_test): Return errors != 0.
+
+2017-10-03  Gabriel F. T. Gomes  <gabriel@inconstante.eti.br>
+
+	[BZ #22235]
+	* math/math.h: Trivial fix for unbalanced parentheses in comment.
+	* math/Makefile [CXX] (tests): Add test-math-iscanonical.cc.
+	(CFLAGS-test-math-iscanonical.cc): New variable.
+	* math/test-math-iscanonical.cc: New file.
+	* sysdeps/ieee754/ldbl-96/bits/iscanonical.h (iscanonical):
+	Provide a C++ implementation based on function overloading,
+	rather than using __MATH_TG, which uses C-only builtins.
+	* sysdeps/ieee754/ldbl-128ibm/bits/iscanonical.h (iscanonical):
+	Likewise.
+	* sysdeps/powerpc/powerpc64le/Makefile
+	(CFLAGS-test-math-iscanonical.cc): New variable.
+
+2017-08-22  Joseph Myers  <joseph@codesourcery.com>
+
+	[BZ #21987]
+	* sysdeps/unix/sysv/linux/sparc/bits/long-double.h: Remove file
+	and copy to ...
+	* sysdeps/unix/sysv/linux/sparc/sparc32/bits/long-double.h:
+	... here.
+	* sysdeps/unix/sysv/linux/sparc/sparc64/bits/long-double.h:
+	... and here.
+
+2017-09-28  Joseph Myers  <joseph@codesourcery.com>
+
+	[BZ #22225]
+	* sysdeps/ieee754/dbl-64/s_nearbyint.c (__nearbyint): Use
+	math_opt_barrier on argument when doing arithmetic on it.
+	* sysdeps/ieee754/dbl-64/wordsize-64/s_nearbyint.c (__nearbyint):
+	Likewise.  Use math_force_eval not math_opt_barrier after
+	arithmetic.
+	* sysdeps/ieee754/flt-32/s_nearbyintf.c (__nearbyintf): Use
+	math_opt_barrier on argument when doing arithmetic on it.
+	* sysdeps/ieee754/ldbl-128/s_nearbyintl.c (__nearbyintl):
+	Likewise.
+
+2017-09-22  Gabriel F. T. Gomes  <gabriel@inconstante.eti.br>
+
+	[BZ #22146]
+	math/math.h: Let fpclassify use the builtin in C++ mode, even
+	when optimazing for size.
+
+2017-08-22  Gabriel F. T. Gomes  <gftg@linux.vnet.ibm.com>
+
+	* include/libc-symbols.h: [!defined HAVE_GCC_IFUNC] (__ifunc):
+	Change the return type of the ifunc resolver to match the return
+	type of the target function.
+
+2017-08-22  Martin Sebor  <msebor@redhat.com>
+
+	* include/libc-symbols.h (__ifunc_resolver): Declare resolver
+	to return a pointer to the same type as the target function.
+
+2017-08-03  Alan Modra  <amodra@gmail.com>
+
+	* sysdeps/powerpc/mod-tlsopt-powerpc.c: Extract from
+	tst-tlsopt-powerpc.c with function name change and no test harness.
+	* sysdeps/powerpc/tst-tlsopt-powerpc.c: Remove body of test.
+	Call tls_get_addr_opt_test.
+	* sysdeps/powerpc/Makefile (LDFLAGS-tst-tlsopt-powerpc): Don't define.
+	(modules-names): Add mod-tlsopt-powerpc.
+	(mod-tlsopt-powerpc.so-no-z-defs): Define.
+	(tst-tlsopt-powerpc): Depend on .so.
+	* sysdeps/powerpc/powerpc64/tls-macros.h (__TLS_GET_ADDR): Don't
+	define.  Expand use in TLS_GD and TLS_LD.
+
+2017-09-11  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #21982]
+	* string/stratcliff.c (do_test): Declare size, nchars, inner,
+	middle and outer with size_t instead of int.  Repleace %d and
+	%Zd with %zu in printf.  Update "MAX (0, nchars - 128)" and
+	"MAX (outer, nchars - 64)" to support unsigned outer and
+	nchars.  Also exit loop when outer == 0.
+
+2017-09-08  Markus Trippelsdorf  <markus@trippelsdorf.de>
+
+	* sysdeps/x86_64/fpu/libm-test-ulps: Update for AMD Ryzen.
+
+2017-09-07  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* resolv/tst-resolv-qtypes.c (domain): Changed to
+	"const char domain[] =".
+
+2017-08-31  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #22051]
+	* Makerules (build-module-helper-objlist): Filter out
+	$(elf-objpfx)sofini.os.
+	(build-shlib-objlist): Append $(elf-objpfx)sofini.os if it is
+	needed.
+
+2017-08-30  Florian Weimer  <fweimer@redhat.com>
+
+	* malloc/dynarray_emplace_enlarge.c
+	(__libc_dynarray_emplace_enlarge): Set errno on overflow.
+	* malloc/dynarray_resize.c (__libc_dynarray_resize): Likewise.
+	* malloc/tst-dynarray.c (test_long_overflow): New function.
+	(do_test): Call it.
+
+2017-09-06  Florian Weimer  <fweimer@redhat.com>
+
+	* malloc/dynarray_emplace_enlarge.c
+	(__libc_dynarray_emplace_enlarge): Add missing else.
+
+2017-09-06  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #22096]
+	* resolv/resolv_conf.c (__resolv_conf_attach): Do not free conf in
+	case of failure to obtain the global conf object.
+
+2017-09-06  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #22095]
+	* resolv/res_init.c (res_vinit_1): Avoid memory leak in case of
+	dynarray allocation failure.
+
+2017-09-06  Florian Weimer  <fweimer@redhat.com>
+
+	Remove dead PTR IPv4-to-IPv6 mapping code from nss_dns.
+	* resolv/nss_dns/dns-host.c (getanswer_r): Remove dead code.
+	* resolv/tst-res_use_inet6.c (response_ptr_v4, response_ptr_v6):
+	New functions.
+	(response): Call them.  Add 'p', '6' flag processing.
+	(test_reverse): New function.
+	(test_get2_any): Call it.
+	(test_no_inet6): Add 'p' test.
+	(test_inet6): Likewise.
+
+2017-09-06  Florian Weimer  <fweimer@redhat.com>
+
+	Enhance tst-res_use_inet6 to test IPv4-to-IPv6 address mapping.
+	* resolv/tst-res_use_inet6.c (response): Process flags embedded in
+	the QNAME.
+	(test_gai): Adjust query names.  Add additional tests.
+	(test_get2_any, test_get2_no_inet6, test_get2_inet6): Split from
+	test_get2.  Adjust query names.  Add additional tests.
+	(test_no_inet6): New function, extracted from threadfunc.
+	(threadfunc): Call test_get2_any, test_get2_inet6, test_no_inet6.
+	Add additional tests.
+
+2017-09-01  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #21915]
+	[BZ #21922]
+	* sysdeps/posix/getaddrinfo.c (gethosts): Look at NSS function
+	result to determine success or failure, not the errno value.
+	* nss/Makefile (tests): Add tst-nss-files-hosts-erange.
+	(tst-nss-files-hosts-erange): Link with -ldl.
+	* nss/tst-nss-files-hosts-erange.c: New file.
+	* nss/tst-resolv-basic.c (response): Handle nodata.example.
+	(do_test): Add NO_DATA tests.
+	* resolv/tst-resolv-basic.c (test_nodata_nxdomain): New function.
+	(do_test): Call it.
+
+2017-09-01  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #21922]
+	* sysdeps/posix/getaddrinfo.c (gaih_inet): Report EAI_NODATA error
+	coming from gethostbyname2_r.
+
+2017-09-01  Florian Weimer  <fweimer@redhat.com>
+
+	* sysdeps/posix/getaddrinfo.c (gaih_inet): Only use h_errno if
+	status indicates it is set.
+
+2017-09-01  Florian Weimer  <fweimer@redhat.com>
+
+	* sysdeps/posix/getaddrinfo.c (gaih_inet): Make reporting of NSS
+	function lookup failures more reliable.
+
+2017-09-01  Florian Weimer  <fweimer@redhat.com>
+
+	* sysdeps/posix/getaddrinfo.c (gethosts): Use h_errno directly.
+	(getcanonname): Likewise.
+	(gaih_inet): Likewise.
+
+2017-09-01  Florian Weimer  <fweimer@redhat.com>
+
+	* sysdeps/posix/getaddrinfo.c (gethosts): Use errno directly.
+	(getcanonname): Likewise.
+	(gaih_inet): Likewise.
+
+2017-08-08  Florian Weimer  <fweimer@redhat.com>
+
+	* sysdeps/posix/getaddrinfo.c (gaih_inet): Remove unreachable
+	return statement.
+
+2017-08-22  Joseph Myers  <joseph@codesourcery.com>
+
+	* assert/Makefile [$(have-cxx-thread_local)]: Move conditional
+	variable definitions above inclusion of ../Rules.
+
+2017-08-28  Gabriel F. T. Gomes  <gftg@linux.vnet.ibm.com>
+
+	[BZ #21930]
+	* math/math.h [defined __cplusplus && defined __SUPPORT_SNAN__]
+	(iszero): New C++ implementation that does not use
+	fpclassify/__MATH_TG/__builtin_types_compatible_p, when
+	signaling nans are enabled, since __builtin_types_compatible_p
+	is a C-only feature.
+	* math/test-math-iszero.cc: When __HAVE_DISTINCT_FLOAT128 is
+	defined, include ieee754_float128.h for access to the union and
+	member ieee854_float128.ieee.
+	[__HAVE_DISTINCT_FLOAT128] (do_test): Call check_float128.
+	[__HAVE_DISTINCT_FLOAT128] (check_float128): New function.
+	* sysdeps/powerpc/powerpc64le/Makefile [subdir == math]
+	(CXXFLAGS-test-math-iszero.cc): Add -mfloat128 to the build
+	options of test-math-zero on powerpc64le.
+
+2017-08-24  Gabriel F. T. Gomes  <gftg@linux.vnet.ibm.com>
+
+	* math/math.h [defined __cplusplus] (issignaling): In the long
+	double case, call __issignalingl only if __NO_LONG_DOUBLE_MATH
+	is not defined.  Call __issignaling, otherwise.
+
+2017-08-22  Gabriel F. T. Gomes  <gftg@linux.vnet.ibm.com>
+
+	* math/math.h [defined __cplusplus] (issignaling): Provide a C++
+	definition for issignaling that does not rely on __MATH_TG,
+	since __MATH_TG uses __builtin_types_compatible_p, which is only
+	available in C mode.
+	(CFLAGS-test-math-issignaling.cc): New variable.
+	* math/Makefile [CXX] (tests): Add test-math-issignaling.
+	* math/test-math-issignaling.cc: New test for C++ implementation
+	of type-generic issignaling.
+	* sysdeps/powerpc/powerpc64le/Makefile [subdir == math]
+	(CXXFLAGS-test-math-issignaling.cc): Add -mfloat128 to the build
+	options of test-math-issignaling on powerpc64le.
+
+2017-08-16  Andreas Schwab  <schwab@suse.de>
+
+	[BZ #16750]
+	CVE-2009-5064
+	* elf/ldd.bash.in: Never run file directly.
+
+2017-08-10  Florian Weimer  <fweimer@redhat.com>
+
+	* inet/net-internal.h (__inet6_scopeid_pton): Remove
+	attribute_hidden, internal_function.
+	* inet/inet6_scopeid_pton.c (__inet6_scopeid_pton): Remove
+	internal_function.
+
+2017-08-21  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #21972]
+	* assert/assert.h (assert): Use static_cast (bool) for C++.
+	Use the ternary operator in the warning branch for GNU C.
+	* assert/Makefile (tests): Add tst-assert-c++, tst-assert-g++.
+	(CFLAGS-tst-assert-c++.o): Compile in C++11 mode.
+	(CFLAGS-tst-assert-g++.o): Compile in GnU C++11 mode.
+	(LDLIBS-tst-assert-c++, LDLIBS-tst-assert-g++): Link with libstdc++.
+	* assert/tst-assert-c++.cc, assert/tst-assert-g++.cc: New files.
+
+2017-08-18  Gabriel F. T. Gomes  <gftg@linux.vnet.ibm.com>
+
+	* misc/sys/cdefs.h (__HAVE_GENERIC_SELECTION): Define to 0, if
+	in C++ mode.
+
+2017-08-18  Gabriel F. T. Gomes  <gftg@linux.vnet.ibm.com>
+
+	[BZ #21930]
+	* math/math.h (isinf): Check if in C or C++ mode before using
+	__builtin_types_compatible_p, since this is a C mode feature.
+
+2017-08-10  Gabriel F. T. Gomes  <gftg@linux.vnet.ibm.com>
+
+	[BZ #21941]
+	* sysdeps/powerpc/fpu/math_private.h (__ieee754_sqrtf128): Since
+	xssqrtqp requires operands to be in Vector Registers
+	(Altivec/VMX), replace the register constraint 'wq' with 'v'.
+	* sysdeps/powerpc/powerpc64le/power9/fpu/e_sqrtf128.c
+	(__ieee754_sqrtf128): Likewise.
+
+2017-08-11  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #21242]
+	* assert/assert.h [__GNUC__ && !__STRICT_ANSI__] (assert):
+	Suppress pedantic warning resulting from statement expression.
+	(__ASSERT_FUNCTION): Add missing __extension__.
+
+2017-08-10  Florian Weimer  <fweimer@redhat.com>
+
+	* malloc/malloc.c (get_max_fast): Reimplement as an inline
+	function which calls __builtin_unreachable.
+
+2017-08-09  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #21932]
+	* nss/getXXbyYY_r.c (REENTRANT_NAME): Call __resolv_context_put
+	before early return.
+
+2017-08-09  Adhemerval Zanella  <adhemerval.zanella@linaro.org>
+
+	[BZ #21780]
+	* sysdeps/posix/preadv2.c (preadv2): Use ENOTSUP instead of
+	EOPNOTSUPP.
+	* sysdeps/posix/preadv64v2.c (preadv64v2): Likewise.
+	* sysdeps/posix/pwritev2.c (pwritev2): Likewise.
+	* sysdeps/posix/pwritev64v2.c (pwritev64v2): Likewise.
+	* sysdeps/unix/sysv/linux/preadv2.c (preadv2): Likewise.
+	* sysdeps/unix/sysv/linux/preadv64v2.c (preadv64v2): Likewise.
+	* sysdeps/unix/sysv/linux/pwritev2.c (pwritev2): Likewise.
+	* sysdeps/unix/sysv/linux/pwritev64v2.c (pwritev64v2): Likewise.
+
+2017-08-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	[BZ #21871]
+	* sysdeps/x86/cpu-features.c (init_cpu_features): Set
+	bit_arch_Use_dl_runtime_resolve_opt only with AVX512F.
+
+2017-08-03  Aurelien Jarno  <aurelien@aurel32.net>
+
+	* stdlib/getentropy.c (getentropy): Change return type to int.
+
+2017-08-03  Aurelien Jarno  <aurelien@aurel32.net>
+
+	* sysdeps/i386/i686/fpu/multiarch/libm-test-ulps: Regenerated.
+
+2017-08-03  Florian Weimer  <fweimer@redhat.com>
+
+	[BZ #21885]
+	* sysdeps/posix/getaddrinfo.c (gethosts): Release resolver context
+	on memory allocation failure.
+
 2017-08-02  Siddhesh Poyarekar  <siddhesh@sourceware.org>
 
 	* version.h (RELEASE): Set to "stable"
diff --git a/Makerules b/Makerules
index 9bb707c168..828a445f24 100644
--- a/Makerules
+++ b/Makerules
@@ -686,14 +686,17 @@ $(build-module-helper) -o $@ $(shlib-lds-flags) \
 $(call after-link,$@)
 endef
 
+# sofini.os must be placed last since it terminates .eh_frame section.
 build-module-helper-objlist = \
 	$(patsubst %_pic.a,$(whole-archive) %_pic.a $(no-whole-archive),\
 		   $(filter-out %.lds $(map-file) $(+preinit) $(+postinit) \
+				$(elf-objpfx)sofini.os \
 				$(link-libc-deps),$^))
 
 build-module-objlist = $(build-module-helper-objlist) $(LDLIBS-$(@F:%.so=%).so)
 build-shlib-objlist = $(build-module-helper-objlist) \
-		      $(LDLIBS-$(@F:lib%.so=%).so)
+		      $(LDLIBS-$(@F:lib%.so=%).so) \
+		      $(filter $(elf-objpfx)sofini.os,$^)
 
 # Don't try to use -lc when making libc.so itself.
 # Also omits crti.o and crtn.o, which we do not want
diff --git a/NEWS b/NEWS
index 8295f20c0a..d6d1f90008 100644
--- a/NEWS
+++ b/NEWS
@@ -5,6 +5,39 @@ See the end for copying conditions.
 Please send GNU C library bug reports via <http://sourceware.org/bugzilla/>
 using `glibc' in the "product" field.
 
+Version 2.26.1
+
+Security related changes:
+
+  CVE-2009-5064: The ldd script would sometimes run the program under
+  examination directly, without preventing code execution through the
+  dynamic linker.  (The glibc project disputes that this is a security
+  vulnerability; only trusted binaries must be examined using the ldd
+  script.)
+
+The following bugs are resolved with this release:
+
+  [16750] ldd: Never run file directly.
+  [21242] assert: Suppress pedantic warning caused by statement expression
+  [21780] posix: Set p{read,write}v2 to return ENOTSUP
+  [21871] x86-64: Use _dl_runtime_resolve_opt only with AVX512F
+  [21885] getaddrinfo: Release resolver context on error in gethosts
+  [21915] getaddrinfo: incorrect result handling for NSS service modules
+  [21922] getaddrinfo with AF_INET(6) returns EAI_NONAME, not EAI_NODATA
+  [21930] Do not use __builtin_types_compatible_p in C++ mode
+  [21932] Unpaired __resolv_context_get in generic get*_r implementation
+  [21941] powerpc: Restrict xssqrtqp operands to Vector Registers
+  [21972] assert macro requires operator== (int) for its argument type
+  [21982] string: stratcliff.c: error: assuming signed overflow does not
+    occur with -O3
+  [22051] libc: zero terminator in the middle of glibc's .eh_frame
+  [22095] resolv: Fix memory leak with OOM during resolv.conf parsing
+  [22096] resolv: __resolv_conf_attach must not free passed conf object
+  [22111] malloc: per thread cache is not returned when thread exits
+  [22146] Let fpclassify use the builtin when optimizing for size in C++ mode
+  [22225] math: nearbyint arithmetic moved before feholdexcept
+  [22235] Add C++ versions of iscanonical for ldbl-96 and ldbl-128ibm
+
 Version 2.26
 
 Major new features:
diff --git a/assert/Makefile b/assert/Makefile
index 1c3be9b01f..222ab516f0 100644
--- a/assert/Makefile
+++ b/assert/Makefile
@@ -25,6 +25,15 @@ include ../Makeconfig
 headers	:= assert.h
 
 routines := assert assert-perr __assert
-tests := test-assert test-assert-perr
+tests := test-assert test-assert-perr tst-assert-c++ tst-assert-g++
+
+ifeq ($(have-cxx-thread_local),yes)
+CFLAGS-tst-assert-c++.o = -std=c++11
+LDLIBS-tst-assert-c++ = -lstdc++
+CFLAGS-tst-assert-g++.o = -std=gnu++11
+LDLIBS-tst-assert-g++ = -lstdc++
+else
+tests-unsupported += tst-assert-c++ tst-assert-g++
+endif
 
 include ../Rules
diff --git a/assert/assert.h b/assert/assert.h
index 22f019537c..640c95c063 100644
--- a/assert/assert.h
+++ b/assert/assert.h
@@ -85,19 +85,29 @@ __END_DECLS
 /* When possible, define assert so that it does not add extra
    parentheses around EXPR.  Otherwise, those added parentheses would
    suppress warnings we'd expect to be detected by gcc's -Wparentheses.  */
-# if !defined __GNUC__ || defined __STRICT_ANSI__
+# if defined __cplusplus
+#  define assert(expr)							\
+     (static_cast <bool> (expr)						\
+      ? void (0)							\
+      : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))
+# elif !defined __GNUC__ || defined __STRICT_ANSI__
 #  define assert(expr)							\
     ((expr)								\
      ? __ASSERT_VOID_CAST (0)						\
      : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))
 # else
+/* The first occurrence of EXPR is not evaluated due to the sizeof,
+   but will trigger any pedantic warnings masked by the __extension__
+   for the second occurrence.  The ternary operator is required to
+   support function pointers and bit fields in this context, and to
+   suppress the evaluation of variable length arrays.  */
 #  define assert(expr)							\
-    ({									\
+  ((void) sizeof ((expr) ? 1 : 0), __extension__ ({			\
       if (expr)								\
         ; /* empty */							\
       else								\
         __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION);	\
-    })
+    }))
 # endif
 
 # ifdef	__USE_GNU
@@ -113,7 +123,7 @@ __END_DECLS
    C9x has a similar variable called __func__, but prefer the GCC one since
    it demangles C++ function names.  */
 # if defined __cplusplus ? __GNUC_PREREQ (2, 6) : __GNUC_PREREQ (2, 4)
-#   define __ASSERT_FUNCTION	__PRETTY_FUNCTION__
+#   define __ASSERT_FUNCTION	__extension__ __PRETTY_FUNCTION__
 # else
 #  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
 #   define __ASSERT_FUNCTION	__func__
diff --git a/assert/tst-assert-c++.cc b/assert/tst-assert-c++.cc
new file mode 100644
index 0000000000..12a5e690cb
--- /dev/null
+++ b/assert/tst-assert-c++.cc
@@ -0,0 +1,78 @@
+/* Tests for interactions between C++ and assert.
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <assert.h>
+
+/* The C++ standard requires that if the assert argument is a constant
+   subexpression, then the assert itself is one, too.  */
+constexpr int
+check_constexpr ()
+{
+  return (assert (true), 1);
+}
+
+/* Objects of this class can be contextually converted to bool, but
+   cannot be compared to int.  */
+struct no_int
+{
+  no_int () = default;
+  no_int (const no_int &) = delete;
+
+  explicit operator bool () const
+  {
+    return true;
+  }
+
+  bool operator! () const; /* No definition.  */
+  template <class T> bool operator== (T) const; /* No definition.  */
+  template <class T> bool operator!= (T) const; /* No definition.  */
+};
+
+/* This class tests that operator== is not used by assert.  */
+struct bool_and_int
+{
+  bool_and_int () = default;
+  bool_and_int (const no_int &) = delete;
+
+  explicit operator bool () const
+  {
+    return true;
+  }
+
+  bool operator! () const; /* No definition.  */
+  template <class T> bool operator== (T) const; /* No definition.  */
+  template <class T> bool operator!= (T) const; /* No definition.  */
+};
+
+static int
+do_test ()
+{
+  {
+    no_int value;
+    assert (value);
+  }
+
+  {
+    bool_and_int value;
+    assert (value);
+  }
+
+  return 0;
+}
+
+#include <support/test-driver.c>
diff --git a/assert/tst-assert-g++.cc b/assert/tst-assert-g++.cc
new file mode 100644
index 0000000000..8c06402825
--- /dev/null
+++ b/assert/tst-assert-g++.cc
@@ -0,0 +1,19 @@
+/* Tests for interactions between C++ and assert.  GNU C++11 version.
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <tst-assert-c++.cc>
diff --git a/elf/ldd.bash.in b/elf/ldd.bash.in
index 7dd1fccf24..686785e235 100644
--- a/elf/ldd.bash.in
+++ b/elf/ldd.bash.in
@@ -164,18 +164,6 @@ warning: you do not have execution permission for" "\`$file'" >&2
       fi
     done
     case $ret in
-    0)
-      # If the program exits with exit code 5, it means the process has been
-      # invoked with __libc_enable_secure.  Fall back to running it through
-      # the dynamic linker.
-      try_trace "$file"
-      rc=$?
-      if [ $rc = 5 ]; then
-	try_trace "$RTLD" "$file"
-	rc=$?
-      fi
-      [ $rc = 0 ] || result=1
-      ;;
     1)
       # This can be a non-ELF binary or no binary at all.
       nonelf "$file" || {
@@ -183,7 +171,7 @@ warning: you do not have execution permission for" "\`$file'" >&2
 	result=1
       }
       ;;
-    2)
+    0|2)
       try_trace "$RTLD" "$file" || result=1
       ;;
     *)
diff --git a/include/libc-symbols.h b/include/libc-symbols.h
index 3310e3a678..5bf57703a9 100644
--- a/include/libc-symbols.h
+++ b/include/libc-symbols.h
@@ -782,7 +782,8 @@ for linking")
 
 /* Helper / base  macros for indirect function symbols.  */
 #define __ifunc_resolver(type_name, name, expr, arg, init, classifier)	\
-  classifier inhibit_stack_protector void *name##_ifunc (arg)					\
+  classifier inhibit_stack_protector					\
+  __typeof (type_name) *name##_ifunc (arg)				\
   {									\
     init ();								\
     __typeof (type_name) *res = expr;					\
@@ -809,7 +810,7 @@ for linking")
 
 # define __ifunc(type_name, name, expr, arg, init)			\
   extern __typeof (type_name) name;					\
-  void *name##_ifunc (arg) __asm__ (#name);				\
+  __typeof (type_name) *name##_ifunc (arg) __asm__ (#name);		\
   __ifunc_resolver (type_name, name, expr, arg, init,)			\
  __asm__ (".type " #name ", %gnu_indirect_function");
 
diff --git a/inet/inet6_scopeid_pton.c b/inet/inet6_scopeid_pton.c
index e09b1cb34d..cc8803fa10 100644
--- a/inet/inet6_scopeid_pton.c
+++ b/inet/inet6_scopeid_pton.c
@@ -28,7 +28,7 @@
 
 /* Parse SOURCE as a scope ID for ADDRESS.  Return 0 on success and -1
    on error.  */
-internal_function int
+int
 __inet6_scopeid_pton (const struct in6_addr *address, const char *scope,
                       uint32_t *result)
 {
diff --git a/inet/net-internal.h b/inet/net-internal.h
index 2b2632c7ba..b2135893e8 100644
--- a/inet/net-internal.h
+++ b/inet/net-internal.h
@@ -25,8 +25,7 @@
 #include <sys/time.h>
 
 int __inet6_scopeid_pton (const struct in6_addr *address,
-                          const char *scope, uint32_t *result)
-  internal_function attribute_hidden;
+                          const char *scope, uint32_t *result);
 libc_hidden_proto (__inet6_scopeid_pton)
 
 
diff --git a/malloc/Makefile b/malloc/Makefile
index 3fa395b949..9e23db9343 100644
--- a/malloc/Makefile
+++ b/malloc/Makefile
@@ -34,6 +34,7 @@ tests := mallocbug tst-malloc tst-valloc tst-calloc tst-obstack \
 	 tst-interpose-nothread \
 	 tst-interpose-thread \
 	 tst-alloc_buffer \
+	 tst-malloc-tcache-leak \
 
 tests-static := \
 	 tst-interpose-static-nothread \
@@ -242,3 +243,5 @@ tst-dynarray-fail-ENV = MALLOC_TRACE=$(objpfx)tst-dynarray-fail.mtrace
 $(objpfx)tst-dynarray-fail-mem.out: $(objpfx)tst-dynarray-fail.out
 	$(common-objpfx)malloc/mtrace $(objpfx)tst-dynarray-fail.mtrace > $@; \
 	$(evaluate-test)
+
+$(objpfx)tst-malloc-tcache-leak: $(shared-thread-library)
diff --git a/malloc/dynarray_emplace_enlarge.c b/malloc/dynarray_emplace_enlarge.c
index dfc70017ce..a15245f4cb 100644
--- a/malloc/dynarray_emplace_enlarge.c
+++ b/malloc/dynarray_emplace_enlarge.c
@@ -17,6 +17,7 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include <dynarray.h>
+#include <errno.h>
 #include <malloc-internal.h>
 #include <stdlib.h>
 #include <string.h>
@@ -32,7 +33,7 @@ __libc_dynarray_emplace_enlarge (struct dynarray_header *list,
          size.  */
       if (element_size < 4)
         new_allocated = 16;
-      if (element_size < 8)
+      else if (element_size < 8)
         new_allocated = 8;
       else
         new_allocated = 4;
@@ -43,8 +44,11 @@ __libc_dynarray_emplace_enlarge (struct dynarray_header *list,
     {
       new_allocated = list->allocated + list->allocated / 2 + 1;
       if (new_allocated <= list->allocated)
-        /* Overflow.  */
-        return false;
+        {
+          /* Overflow.  */
+          __set_errno (ENOMEM);
+          return false;
+        }
     }
 
   size_t new_size;
diff --git a/malloc/dynarray_resize.c b/malloc/dynarray_resize.c
index e6dc9fbc68..63c981bf61 100644
--- a/malloc/dynarray_resize.c
+++ b/malloc/dynarray_resize.c
@@ -17,6 +17,7 @@
    <http://www.gnu.org/licenses/>.  */
 
 #include <dynarray.h>
+#include <errno.h>
 #include <malloc-internal.h>
 #include <stdlib.h>
 #include <string.h>
@@ -38,7 +39,11 @@ __libc_dynarray_resize (struct dynarray_header *list, size_t size,
 
   size_t new_size_bytes;
   if (check_mul_overflow_size_t (size, element_size, &new_size_bytes))
-    return false;
+    {
+      /* Overflow.  */
+      __set_errno (ENOMEM);
+      return false;
+    }
   void *new_array;
   if (list->array == scratch)
     {
diff --git a/malloc/malloc.c b/malloc/malloc.c
index 54e406bcb6..01ec1571b9 100644
--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -1658,6 +1658,9 @@ typedef struct malloc_chunk *mfastbinptr;
 #define arena_is_corrupt(A)	(((A)->flags & ARENA_CORRUPTION_BIT))
 #define set_arena_corrupt(A)	((A)->flags |= ARENA_CORRUPTION_BIT)
 
+/* Maximum size of memory handled in fastbins.  */
+static INTERNAL_SIZE_T global_max_fast;
+
 /*
    Set value of max_fast.
    Use impossibly small value if 0.
@@ -1668,8 +1671,20 @@ typedef struct malloc_chunk *mfastbinptr;
 #define set_max_fast(s) \
   global_max_fast = (((s) == 0)						      \
                      ? SMALLBIN_WIDTH : ((s + SIZE_SZ) & ~MALLOC_ALIGN_MASK))
-#define get_max_fast() global_max_fast
 
+static inline INTERNAL_SIZE_T
+get_max_fast (void)
+{
+  /* Tell the GCC optimizers that global_max_fast is never larger
+     than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in
+     _int_malloc after constant propagation of the size parameter.
+     (The code never executes because malloc preserves the
+     global_max_fast invariant, but the optimizers may not recognize
+     this.)  */
+  if (global_max_fast > MAX_FAST_SIZE)
+    __builtin_unreachable ();
+  return global_max_fast;
+}
 
 /*
    ----------- Internal state representation and initialization -----------
@@ -1797,9 +1812,6 @@ static struct malloc_par mp_ =
 #endif
 };
 
-/* Maximum size of memory handled in fastbins.  */
-static INTERNAL_SIZE_T global_max_fast;
-
 /*
    Initialize a malloc_state struct.
 
@@ -2940,7 +2952,7 @@ typedef struct tcache_perthread_struct
   tcache_entry *entries[TCACHE_MAX_BINS];
 } tcache_perthread_struct;
 
-static __thread char tcache_shutting_down = 0;
+static __thread bool tcache_shutting_down = false;
 static __thread tcache_perthread_struct *tcache = NULL;
 
 /* Caller must ensure that we know tc_idx is valid and there's room
@@ -2977,8 +2989,12 @@ tcache_thread_freeres (void)
   if (!tcache)
     return;
 
+  /* Disable the tcache and prevent it from being reinitialized.  */
   tcache = NULL;
+  tcache_shutting_down = true;
 
+  /* Free all of the entries and the tcache itself back to the arena
+     heap for coalescing.  */
   for (i = 0; i < TCACHE_MAX_BINS; ++i)
     {
       while (tcache_tmp->entries[i])
@@ -2990,8 +3006,6 @@ tcache_thread_freeres (void)
     }
 
   __libc_free (tcache_tmp);
-
-  tcache_shutting_down = 1;
 }
 text_set_element (__libc_thread_subfreeres, tcache_thread_freeres);
 
diff --git a/malloc/tst-dynarray.c b/malloc/tst-dynarray.c
index 2206d75e31..d11f7bb8a3 100644
--- a/malloc/tst-dynarray.c
+++ b/malloc/tst-dynarray.c
@@ -18,6 +18,9 @@
 
 #include "tst-dynarray-shared.h"
 
+#include <errno.h>
+#include <stdint.h>
+
 #define DYNARRAY_STRUCT dynarray_long
 #define DYNARRAY_ELEMENT long
 #define DYNARRAY_PREFIX dynarray_long_
@@ -463,6 +466,31 @@ test_long_init (void)
   }
 }
 
+/* Test overflow in resize.  */
+static void
+test_long_overflow (void)
+{
+  {
+    struct dynarray_long dyn;
+    dynarray_long_init (&dyn);
+    errno = EINVAL;
+    TEST_VERIFY (!dynarray_long_resize
+                 (&dyn, (SIZE_MAX / sizeof (long)) + 1));
+    TEST_VERIFY (errno == ENOMEM);
+    TEST_VERIFY (dynarray_long_has_failed (&dyn));
+  }
+
+  {
+    struct dynarray_long_noscratch dyn;
+    dynarray_long_noscratch_init (&dyn);
+    errno = EINVAL;
+    TEST_VERIFY (!dynarray_long_noscratch_resize
+                 (&dyn, (SIZE_MAX / sizeof (long)) + 1));
+    TEST_VERIFY (errno == ENOMEM);
+    TEST_VERIFY (dynarray_long_noscratch_has_failed (&dyn));
+  }
+}
+
 /* Test NUL-terminated string construction with the add function and
    the simple finalize function.  */
 static void
@@ -538,6 +566,7 @@ do_test (void)
   test_int ();
   test_str ();
   test_long_init ();
+  test_long_overflow ();
   test_zstr ();
   return 0;
 }
diff --git a/malloc/tst-malloc-tcache-leak.c b/malloc/tst-malloc-tcache-leak.c
new file mode 100644
index 0000000000..22c679b65b
--- /dev/null
+++ b/malloc/tst-malloc-tcache-leak.c
@@ -0,0 +1,112 @@
+/* Bug 22111: Test that threads do not leak their per thread cache.
+   Copyright (C) 2015-2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* The point of this test is to start and exit a large number of
+   threads, while at the same time looking to see if the used
+   memory grows with each round of threads run.  If the memory
+   grows above some linear bound we declare the test failed and
+   that the malloc implementation is leaking memory with each
+   thread.  This is a good indicator that the thread local cache
+   is leaking chunks.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <malloc.h>
+#include <pthread.h>
+#include <assert.h>
+
+#include <support/check.h>
+#include <support/support.h>
+#include <support/xthread.h>
+
+void *
+worker (void *data)
+{
+  void *ret;
+  /* Allocate an arbitrary amount of memory that is known to fit into
+     the thread local cache (tcache).  If we have at least 64 bins
+     (default e.g. TCACHE_MAX_BINS) we should be able to allocate 32
+     bytes and force malloc to fill the tcache.  We are assuming tcahce
+     init happens at the first small alloc, but it might in the future
+     be deferred to some other point.  Therefore to future proof this
+     test we include a full alloc/free/alloc cycle for the thread.  We
+     need a compiler barrier to avoid the removal of the useless
+     alloc/free.  We send some memory back to main to have the memory
+     freed after the thread dies, as just another check that the chunks
+     that were previously in the tcache are still OK to free after
+     thread death.  */
+  ret = xmalloc (32);
+  __asm__ volatile ("" ::: "memory");
+  free (ret);
+  return (void *) xmalloc (32);
+}
+
+static int
+do_test (void)
+{
+  pthread_t *thread;
+  struct mallinfo info_before, info_after;
+  void *retval;
+
+  /* This is an arbitrary choice. We choose a total of THREADS
+     threads created and joined.  This gives us enough iterations to
+     show a leak.  */
+  int threads = 100000;
+
+  /* Avoid there being 0 malloc'd data at this point by allocating the
+     pthread_t required to run the test.  */
+  thread = (pthread_t *) xcalloc (1, sizeof (pthread_t));
+
+  info_before = mallinfo ();
+
+  assert (info_before.uordblks != 0);
+
+  printf ("INFO: %d (bytes) are in use before starting threads.\n",
+          info_before.uordblks);
+
+  for (int loop = 0; loop < threads; loop++)
+    {
+      *thread = xpthread_create (NULL, worker, NULL);
+      retval = xpthread_join (*thread);
+      free (retval);
+    }
+
+  info_after = mallinfo ();
+  printf ("INFO: %d (bytes) are in use after all threads joined.\n",
+          info_after.uordblks);
+
+  /* We need to compare the memory in use before and the memory in use
+     after starting and joining THREADS threads.  We almost always grow
+     memory slightly, but not much. Consider that if even 1-byte leaked
+     per thread we'd have THREADS bytes of additional memory, and in
+     general the in-use at the start of main is quite low.  We will
+     always leak a full malloc chunk, and never just 1-byte, therefore
+     anything above "+ threads" from the start (constant offset) is a
+     leak.  Obviously this assumes no thread-related malloc'd internal
+     libc data structures persist beyond the thread death, and any that
+     did would limit the number of times you could call pthread_create,
+     which is a QoI we'd want to detect and fix.  */
+  if (info_after.uordblks > (info_before.uordblks + threads))
+    FAIL_EXIT1 ("Memory usage after threads is too high.\n");
+
+  /* Did not detect excessive memory usage.  */
+  free (thread);
+  exit (0);
+}
+
+#include <support/test-driver.c>
diff --git a/math/Makefile b/math/Makefile
index e09b0c0545..2c17c68eda 100644
--- a/math/Makefile
+++ b/math/Makefile
@@ -203,7 +203,8 @@ tests-static = test-fpucw-static test-fpucw-ieee-static \
 	       test-signgam-ullong-static test-signgam-ullong-init-static
 
 ifneq (,$(CXX))
-tests += test-math-isinff test-math-iszero
+tests += test-math-isinff test-math-iszero test-math-issignaling \
+	 test-math-iscanonical
 endif
 
 ifneq (no,$(PERL))
@@ -350,6 +351,8 @@ CFLAGS-test-signgam-ullong-init-static.c = -std=c99
 
 CFLAGS-test-math-isinff.cc = -std=gnu++11
 CFLAGS-test-math-iszero.cc = -std=gnu++11
+CFLAGS-test-math-issignaling.cc = -std=gnu++11
+CFLAGS-test-math-iscanonical.cc = -std=gnu++11
 
 CFLAGS-test-iszero-excess-precision.c = -fexcess-precision=standard
 CFLAGS-test-iseqsig-excess-precision.c = -fexcess-precision=standard
diff --git a/math/math.h b/math/math.h
index e21708045a..2b216c6da1 100644
--- a/math/math.h
+++ b/math/math.h
@@ -402,7 +402,13 @@ enum
 
 /* Return number of classification appropriate for X.  */
 # if __GNUC_PREREQ (4,4) && !defined __SUPPORT_SNAN__			      \
-     && !defined __OPTIMIZE_SIZE__
+     && (!defined __OPTIMIZE_SIZE__ || defined __cplusplus)
+     /* The check for __cplusplus allows the use of the builtin, even
+	when optimization for size is on.  This is provided for
+	libstdc++, only to let its configure test work when it is built
+	with -Os.  No further use of this definition of fpclassify is
+	expected in C++ mode, since libstdc++ provides its own version
+	of fpclassify in cmath (which undefines fpclassify).  */
 #  define fpclassify(x) __builtin_fpclassify (FP_NAN, FP_INFINITE,	      \
      FP_NORMAL, FP_SUBNORMAL, FP_ZERO, x)
 # else
@@ -442,8 +448,12 @@ enum
 
 /* Return nonzero value if X is positive or negative infinity.  */
 # if __HAVE_DISTINCT_FLOAT128 && !__GNUC_PREREQ (7,0) \
-     && !defined __SUPPORT_SNAN__
-   /* __builtin_isinf_sign is broken for float128 only before GCC 7.0.  */
+     && !defined __SUPPORT_SNAN__ && !defined __cplusplus
+   /* Since __builtin_isinf_sign is broken for float128 before GCC 7.0,
+      use the helper function, __isinff128, with older compilers.  This is
+      only provided for C mode, because in C++ mode, GCC has no support
+      for __builtin_types_compatible_p (and when in C++ mode, this macro is
+      not used anyway, because libstdc++ headers undefine it).  */
 #  define isinf(x) \
     (__builtin_types_compatible_p (__typeof (x), _Float128) \
      ? __isinff128 (x) : __builtin_isinf_sign (x))
@@ -470,7 +480,32 @@ enum
 # include <bits/iscanonical.h>
 
 /* Return nonzero value if X is a signaling NaN.  */
-# define issignaling(x) __MATH_TG ((x), __issignaling, (x))
+# ifndef __cplusplus
+#  define issignaling(x) __MATH_TG ((x), __issignaling, (x))
+# else
+   /* In C++ mode, __MATH_TG cannot be used, because it relies on
+      __builtin_types_compatible_p, which is a C-only builtin.  On the
+      other hand, overloading provides the means to distinguish between
+      the floating-point types.  The overloading resolution will match
+      the correct parameter (regardless of type qualifiers (i.e.: const
+      and volatile)).  */
+extern "C++" {
+inline int issignaling (float __val) { return __issignalingf (__val); }
+inline int issignaling (double __val) { return __issignaling (__val); }
+inline int
+issignaling (long double __val)
+{
+#  ifdef __NO_LONG_DOUBLE_MATH
+  return __issignaling (__val);
+#  else
+  return __issignalingl (__val);
+#  endif
+}
+#  if __HAVE_DISTINCT_FLOAT128
+inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }
+#  endif
+} /* extern C++ */
+# endif
 
 /* Return nonzero value if X is subnormal.  */
 # define issubnormal(x) (fpclassify (x) == FP_SUBNORMAL)
@@ -484,15 +519,40 @@ enum
 #  endif
 # else	/* __cplusplus */
 extern "C++" {
+#  ifdef __SUPPORT_SNAN__
+inline int
+iszero (float __val)
+{
+  return __fpclassifyf (__val) == FP_ZERO;
+}
+inline int
+iszero (double __val)
+{
+  return __fpclassify (__val) == FP_ZERO;
+}
+inline int
+iszero (long double __val)
+{
+#   ifdef __NO_LONG_DOUBLE_MATH
+  return __fpclassify (__val) == FP_ZERO;
+#   else
+  return __fpclassifyl (__val) == FP_ZERO;
+#   endif
+}
+#   if __HAVE_DISTINCT_FLOAT128
+inline int
+iszero (_Float128 __val)
+{
+  return __fpclassifyf128 (__val) == FP_ZERO;
+}
+#   endif
+#  else
 template <class __T> inline bool
 iszero (__T __val)
 {
-#  ifdef __SUPPORT_SNAN__
-  return fpclassify (__val) == FP_ZERO;
-#  else
   return __val == 0;
-#  endif
 }
+#  endif
 } /* extern C++ */
 # endif	/* __cplusplus */
 #endif /* Use IEC_60559_BFP_EXT.  */
diff --git a/math/test-math-iscanonical.cc b/math/test-math-iscanonical.cc
new file mode 100644
index 0000000000..4cfb1c5055
--- /dev/null
+++ b/math/test-math-iscanonical.cc
@@ -0,0 +1,48 @@
+/* Test for the C++ implementation of iscanonical.
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define _GNU_SOURCE 1
+#include <math.h>
+#include <stdio.h>
+
+static int errors;
+
+template <class T>
+static void
+check_type ()
+{
+  T val = 0;
+
+  /* Check if iscanonical is available in C++ mode (bug 22235).  */
+  if (iscanonical (val) == 0)
+    errors++;
+}
+
+static int
+do_test (void)
+{
+  check_type<float> ();
+  check_type<double> ();
+  check_type<long double> ();
+#if __HAVE_DISTINCT_FLOAT128
+  check_type<_Float128> ();
+#endif
+  return errors != 0;
+}
+
+#include <support/test-driver.c>
diff --git a/math/test-math-issignaling.cc b/math/test-math-issignaling.cc
new file mode 100644
index 0000000000..22ae9e1bca
--- /dev/null
+++ b/math/test-math-issignaling.cc
@@ -0,0 +1,113 @@
+/* Test for the C++ implementation of issignaling.
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define _GNU_SOURCE 1
+#include <math.h>
+#include <stdio.h>
+
+#include <limits>
+
+/* There is no signaling_NaN for _Float128 in std::numeric_limits.
+   Include ieee754_float128.h and use the bitfields in the union
+   ieee854_float128.ieee_nan to build a signaling NaN.  */
+#if __HAVE_DISTINCT_FLOAT128
+# include <ieee754_float128.h>
+#endif
+
+static bool errors;
+
+static void
+check (int actual, int expected, const char *actual_expr, int line)
+{
+  if (actual != expected)
+    {
+      errors = true;
+      printf ("%s:%d: error: %s\n", __FILE__, line, actual_expr);
+      printf ("%s:%d:   expected: %d\n", __FILE__, line, expected);
+      printf ("%s:%d:   actual: %d\n", __FILE__, line, actual);
+    }
+}
+
+#define CHECK(actual, expected) \
+  check ((actual), (expected), #actual, __LINE__)
+
+template <class T>
+static void
+check_type ()
+{
+  typedef std::numeric_limits<T> limits;
+  CHECK (issignaling (T{0}), 0);
+  if (limits::has_infinity)
+    {
+      CHECK (issignaling (limits::infinity ()), 0);
+      CHECK (issignaling (-limits::infinity ()), 0);
+    }
+  if (limits::has_quiet_NaN)
+    CHECK (issignaling (limits::quiet_NaN ()), 0);
+  if (limits::has_signaling_NaN)
+    CHECK (issignaling (limits::signaling_NaN ()), 1);
+}
+
+#if __HAVE_DISTINCT_FLOAT128
+static void
+check_float128 ()
+{
+  ieee854_float128 q;
+
+  q.d = 0;
+  CHECK (issignaling (q.d), 0);
+
+  /* Infinity.  */
+  q.ieee.negative = 0;
+  q.ieee.exponent = 0x7FFF;
+  q.ieee.mantissa0 = 0x0000;
+  q.ieee.mantissa1 = 0x00000000;
+  q.ieee.mantissa2 = 0x00000000;
+  q.ieee.mantissa3 = 0x00000000;
+  CHECK (issignaling (q.d), 0);
+
+  /* Quiet NaN.  */
+  q.ieee_nan.quiet_nan = 1;
+  q.ieee_nan.mantissa0 = 0x0000;
+  CHECK (issignaling (q.d), 0);
+
+  /* Still a quiet NaN.  */
+  q.ieee_nan.quiet_nan = 1;
+  q.ieee_nan.mantissa0 = 0x4000;
+  CHECK (issignaling (q.d), 0);
+
+  /* Signaling NaN.  */
+  q.ieee_nan.quiet_nan = 0;
+  q.ieee_nan.mantissa0 = 0x4000;
+  CHECK (issignaling (q.d), 1);
+}
+#endif
+
+static int
+do_test (void)
+{
+  check_type<float> ();
+  check_type<double> ();
+  check_type<long double> ();
+#if __HAVE_DISTINCT_FLOAT128
+  check_float128 ();
+#endif
+  return errors;
+}
+
+#include <support/test-driver.c>
diff --git a/math/test-math-iszero.cc b/math/test-math-iszero.cc
index 027e972654..5c07261626 100644
--- a/math/test-math-iszero.cc
+++ b/math/test-math-iszero.cc
@@ -22,6 +22,13 @@
 
 #include <limits>
 
+/* Support for _Float128 in std::numeric_limits is limited.
+   Include ieee754_float128.h and use the bitfields in the union
+   ieee854_float128.ieee_nan to build corner-case inputs.  */
+#if __HAVE_DISTINCT_FLOAT128
+# include <ieee754_float128.h>
+#endif
+
 static bool errors;
 
 static void
@@ -72,12 +79,84 @@ check_type ()
          std::numeric_limits<T>::has_denorm == std::denorm_absent);
 }
 
+#if __HAVE_DISTINCT_FLOAT128
+static void
+check_float128 ()
+{
+  ieee854_float128 q;
+
+  q.d = 0.0Q;
+  CHECK (iszero (q.d), 1);
+  q.d = -0.0Q;
+  CHECK (iszero (q.d), 1);
+  q.d = 1.0Q;
+  CHECK (iszero (q.d), 0);
+  q.d = -1.0Q;
+  CHECK (iszero (q.d), 0);
+
+  /* Normal min.  */
+  q.ieee.negative = 0;
+  q.ieee.exponent = 0x0001;
+  q.ieee.mantissa0 = 0x0000;
+  q.ieee.mantissa1 = 0x00000000;
+  q.ieee.mantissa2 = 0x00000000;
+  q.ieee.mantissa3 = 0x00000000;
+  CHECK (iszero (q.d), 0);
+  q.ieee.negative = 1;
+  CHECK (iszero (q.d), 0);
+
+  /* Normal max.  */
+  q.ieee.negative = 0;
+  q.ieee.exponent = 0x7FFE;
+  q.ieee.mantissa0 = 0xFFFF;
+  q.ieee.mantissa1 = 0xFFFFFFFF;
+  q.ieee.mantissa2 = 0xFFFFFFFF;
+  q.ieee.mantissa3 = 0xFFFFFFFF;
+  CHECK (iszero (q.d), 0);
+  q.ieee.negative = 1;
+  CHECK (iszero (q.d), 0);
+
+  /* Infinity.  */
+  q.ieee.negative = 0;
+  q.ieee.exponent = 0x7FFF;
+  q.ieee.mantissa0 = 0x0000;
+  q.ieee.mantissa1 = 0x00000000;
+  q.ieee.mantissa2 = 0x00000000;
+  q.ieee.mantissa3 = 0x00000000;
+  CHECK (iszero (q.d), 0);
+
+  /* Quiet NaN.  */
+  q.ieee_nan.quiet_nan = 1;
+  q.ieee_nan.mantissa0 = 0x0000;
+  CHECK (iszero (q.d), 0);
+
+  /* Signaling NaN.  */
+  q.ieee_nan.quiet_nan = 0;
+  q.ieee_nan.mantissa0 = 0x4000;
+  CHECK (iszero (q.d), 0);
+
+  /* Denormal min.  */
+  q.ieee.negative = 0;
+  q.ieee.exponent = 0x0000;
+  q.ieee.mantissa0 = 0x0000;
+  q.ieee.mantissa1 = 0x00000000;
+  q.ieee.mantissa2 = 0x00000000;
+  q.ieee.mantissa3 = 0x00000001;
+  CHECK (iszero (q.d), 0);
+  q.ieee.negative = 1;
+  CHECK (iszero (q.d), 0);
+}
+#endif
+
 static int
 do_test (void)
 {
   check_type<float> ();
   check_type<double> ();
   check_type<long double> ();
+#if __HAVE_DISTINCT_FLOAT128
+  check_float128 ();
+#endif
   return errors;
 }
 
diff --git a/misc/sys/cdefs.h b/misc/sys/cdefs.h
index 06523bfe9c..0c808216a4 100644
--- a/misc/sys/cdefs.h
+++ b/misc/sys/cdefs.h
@@ -464,17 +464,18 @@
 # define __glibc_macro_warning(msg)
 #endif
 
-/* Support for generic selection (ISO C11) is available in GCC since
-   version 4.9.  Previous versions do not provide generic selection,
-   even though they might set __STDC_VERSION__ to 201112L, when in
-   -std=c11 mode.  Thus, we must check for !defined __GNUC__ when
-   testing __STDC_VERSION__ for generic selection support.
+/* Generic selection (ISO C11) is a C-only feature, available in GCC
+   since version 4.9.  Previous versions do not provide generic
+   selection, even though they might set __STDC_VERSION__ to 201112L,
+   when in -std=c11 mode.  Thus, we must check for !defined __GNUC__
+   when testing __STDC_VERSION__ for generic selection support.
    On the other hand, Clang also defines __GNUC__, so a clang-specific
    check is required to enable the use of generic selection.  */
-#if __GNUC_PREREQ (4, 9) \
-    || __glibc_clang_has_extension (c_generic_selections) \
-    || (!defined __GNUC__ && defined __STDC_VERSION__ \
-	&& __STDC_VERSION__ >= 201112L)
+#if !defined __cplusplus \
+    && (__GNUC_PREREQ (4, 9) \
+	|| __glibc_clang_has_extension (c_generic_selections) \
+	|| (!defined __GNUC__ && defined __STDC_VERSION__ \
+	    && __STDC_VERSION__ >= 201112L))
 # define __HAVE_GENERIC_SELECTION 1
 #else
 # define __HAVE_GENERIC_SELECTION 0
diff --git a/nss/Makefile b/nss/Makefile
index d9f6d41181..91b1c21567 100644
--- a/nss/Makefile
+++ b/nss/Makefile
@@ -58,6 +58,11 @@ tests			= test-netdb test-digits-dots tst-nss-getpwent bug17079 \
 			  tst-nss-test5
 xtests			= bug-erange
 
+# Tests which need libdl
+ifeq (yes,$(build-shared))
+tests += tst-nss-files-hosts-erange
+endif
+
 # If we have a thread library then we can test cancellation against
 # some routines like getpwuid_r.
 ifeq (yes,$(have-thread-library))
@@ -154,3 +159,5 @@ $(patsubst %,$(objpfx)%.out,$(tests)) : \
 ifeq (yes,$(have-thread-library))
 $(objpfx)tst-cancel-getpwuid_r: $(shared-thread-library)
 endif
+
+$(objpfx)tst-nss-files-hosts-erange: $(libdl)
diff --git a/nss/getXXbyYY_r.c b/nss/getXXbyYY_r.c
index 6c547ea1ca..bce80e05dd 100644
--- a/nss/getXXbyYY_r.c
+++ b/nss/getXXbyYY_r.c
@@ -234,6 +234,9 @@ INTERNAL (REENTRANT_NAME) (ADD_PARAMS, LOOKUP_TYPE *resbuf, char *buffer,
 				      H_ERRNO_VAR_P))
     {
     case -1:
+# ifdef NEED__RES
+      __resolv_context_put (res_ctx);
+# endif
       return errno;
     case 1:
 #ifdef NEED_H_ERRNO
@@ -253,7 +256,12 @@ INTERNAL (REENTRANT_NAME) (ADD_PARAMS, LOOKUP_TYPE *resbuf, char *buffer,
       nscd_status = NSCD_NAME (ADD_VARIABLES, resbuf, buffer, buflen, result
 			       H_ERRNO_VAR);
       if (nscd_status >= 0)
-	return nscd_status;
+	{
+# ifdef NEED__RES
+	  __resolv_context_put (res_ctx);
+# endif
+	  return nscd_status;
+	}
     }
 #endif
 
diff --git a/nss/tst-nss-files-hosts-erange.c b/nss/tst-nss-files-hosts-erange.c
new file mode 100644
index 0000000000..beb7aa9fa0
--- /dev/null
+++ b/nss/tst-nss-files-hosts-erange.c
@@ -0,0 +1,109 @@
+/* Parse /etc/hosts in multi mode with a trailing long line (bug 21915).
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+
+#include <dlfcn.h>
+#include <errno.h>
+#include <gnu/lib-names.h>
+#include <netdb.h>
+#include <nss.h>
+#include <support/check.h>
+#include <support/check_nss.h>
+#include <support/namespace.h>
+#include <support/test-driver.h>
+#include <support/xunistd.h>
+
+struct support_chroot *chroot_env;
+
+#define X10 "XXXXXXXXXX"
+#define X100 X10 X10 X10 X10 X10 X10 X10 X10 X10 X10
+#define X1000 X100 X100 X100 X100 X100 X100 X100 X100 X100 X100
+
+static void
+prepare (int argc, char **argv)
+{
+  chroot_env = support_chroot_create
+    ((struct support_chroot_configuration)
+     {
+       .resolv_conf = "",
+       .hosts =
+         "127.0.0.1   localhost localhost.localdomain\n"
+         "::1         localhost localhost.localdomain\n"
+         "192.0.2.1   example.com\n"
+         "#" X1000 X100 "\n",
+       .host_conf = "multi on\n",
+     });
+}
+
+static int
+do_test (void)
+{
+  support_become_root ();
+  if (!support_can_chroot ())
+    return EXIT_UNSUPPORTED;
+
+  __nss_configure_lookup ("hosts", "files");
+  if (dlopen (LIBNSS_FILES_SO, RTLD_LAZY) == NULL)
+    FAIL_EXIT1 ("could not load " LIBNSS_DNS_SO ": %s", dlerror ());
+
+  xchroot (chroot_env->path_chroot);
+
+  errno = ERANGE;
+  h_errno = NETDB_INTERNAL;
+  check_hostent ("gethostbyname example.com",
+                 gethostbyname ("example.com"),
+                 "name: example.com\n"
+                 "address: 192.0.2.1\n");
+  errno = ERANGE;
+  h_errno = NETDB_INTERNAL;
+  check_hostent ("gethostbyname2 AF_INET example.com",
+                 gethostbyname2 ("example.com", AF_INET),
+                 "name: example.com\n"
+                 "address: 192.0.2.1\n");
+  {
+    struct addrinfo hints =
+      {
+        .ai_family = AF_UNSPEC,
+        .ai_socktype = SOCK_STREAM,
+        .ai_protocol = IPPROTO_TCP,
+      };
+    errno = ERANGE;
+    h_errno = NETDB_INTERNAL;
+    struct addrinfo *ai;
+    int ret = getaddrinfo ("example.com", "80", &hints, &ai);
+    check_addrinfo ("example.com AF_UNSPEC", ai, ret,
+                    "address: STREAM/TCP 192.0.2.1 80\n");
+    if (ret == 0)
+      freeaddrinfo (ai);
+
+    hints.ai_family = AF_INET;
+    errno = ERANGE;
+    h_errno = NETDB_INTERNAL;
+    ret = getaddrinfo ("example.com", "80", &hints, &ai);
+    check_addrinfo ("example.com AF_INET", ai, ret,
+                    "address: STREAM/TCP 192.0.2.1 80\n");
+    if (ret == 0)
+      freeaddrinfo (ai);
+  }
+
+  support_chroot_free (chroot_env);
+  return 0;
+}
+
+#define PREPARE prepare
+#include <support/test-driver.c>
diff --git a/po/fr.po b/po/fr.po
index 5a79695125..6764655d25 100644
--- a/po/fr.po
+++ b/po/fr.po
@@ -5920,7 +5920,7 @@ msgstr "Le fichier existe"
 #. TRANS also when you rename a file with @code{rename} (@pxref{Renaming Files}).
 #: sysdeps/gnu/errlist.c:211
 msgid "Invalid cross-device link"
-msgstr "Lien croisé de périphéque invalide"
+msgstr "Lien physique inter-périphérique invalide"
 
 #. TRANS The wrong type of device was given to a function that expects a
 #. TRANS particular sort of device.
diff --git a/po/sv.po b/po/sv.po
index 0ebfec5b7f..d10bfad482 100644
--- a/po/sv.po
+++ b/po/sv.po
@@ -5,12 +5,12 @@
 # Jan Djärv <jan.h.d@swipnet.se>, 1996, 1998, 2001, 2002, 2003, 2006, 2007, 2008, 2009, 2011, 2012, 2013, 2014, 2015.
 # Göran Uddeborg <goeran@uddeborg.se>, 2016, 2017.
 #
-# $Revision: 1.7 $
+# $Revision: 1.10 $
 msgid ""
 msgstr ""
-"Project-Id-Version: libc 2.25-pre1\n"
-"POT-Creation-Date: 2017-01-11 17:27+0530\n"
-"PO-Revision-Date: 2017-05-30 12:14+0200\n"
+"Project-Id-Version: libc 2.25.90\n"
+"POT-Creation-Date: 2017-07-25 12:32+0530\n"
+"PO-Revision-Date: 2017-08-20 18:21+0200\n"
 "Last-Translator: Göran Uddeborg <goeran@uddeborg.se>\n"
 "Language-Team: Swedish <tp-sv@listor.tp-sv.se>\n"
 "Language: sv\n"
@@ -478,19 +478,19 @@ msgstr "FEL I DYNAMISK LÄNKARE!!!"
 msgid "error while loading shared libraries"
 msgstr "fel när delade bibliotek laddades"
 
-#: elf/dl-fptr.c:88 sysdeps/hppa/dl-fptr.c:94
+#: elf/dl-fptr.c:88 sysdeps/hppa/dl-fptr.c:95
 msgid "cannot map pages for fdesc table"
 msgstr "kan inte minnesmappa sidor för fdesc-tabell"
 
-#: elf/dl-fptr.c:192 sysdeps/hppa/dl-fptr.c:207
+#: elf/dl-fptr.c:192 sysdeps/hppa/dl-fptr.c:213
 msgid "cannot map pages for fptr table"
 msgstr "kan inte minnesmappa sidor för fptr-tabell"
 
-#: elf/dl-fptr.c:221 sysdeps/hppa/dl-fptr.c:236
+#: elf/dl-fptr.c:221 sysdeps/hppa/dl-fptr.c:242
 msgid "internal error: symidx out of range of fptr table"
 msgstr "internt fel: symidx är utanför intervallet för fptr-tabellen"
 
-#: elf/dl-hwcaps.c:184 elf/dl-hwcaps.c:196
+#: elf/dl-hwcaps.c:191 elf/dl-hwcaps.c:203
 msgid "cannot create capability list"
 msgstr "kan inte skapa egenskapslista"
 
@@ -670,20 +670,20 @@ msgstr "ogiltig målnamnrymd för dlmopen()"
 msgid "cannot allocate memory in static TLS block"
 msgstr "kan inte allokera minne i statiskt TLS-block"
 
-#: elf/dl-reloc.c:212
+#: elf/dl-reloc.c:206
 msgid "cannot make segment writable for relocation"
 msgstr "kan inte göra segment skrivbart för relokering"
 
-#: elf/dl-reloc.c:283
+#: elf/dl-reloc.c:277
 #, c-format
 msgid "%s: out of memory to store relocation results for %s\n"
 msgstr "%s: slut på minne för att lagra relokeringsresultat för %s\n"
 
-#: elf/dl-reloc.c:299
+#: elf/dl-reloc.c:293
 msgid "cannot restore segment prot after reloc"
 msgstr "kan inte återställa segmenträttigheter efter relokering"
 
-#: elf/dl-reloc.c:330
+#: elf/dl-reloc.c:324
 msgid "cannot apply additional memory protection after relocation"
 msgstr "kan inte applicera extra minnesskydd efter relokering"
 
@@ -959,14 +959,14 @@ msgstr "Försök med \"ldd --help\" för mer information."
 msgid "missing file arguments"
 msgstr "filargument saknas"
 
-#. TRANS No such file or directory.  This is a ``file doesn't exist'' error
+#. TRANS This is a ``file doesn't exist'' error
 #. TRANS for ordinary files that are referenced in contexts where they are
 #. TRANS expected to already exist.
 #: elf/ldd.bash.in:147 sysdeps/gnu/errlist.c:37
 msgid "No such file or directory"
 msgstr "Filen eller katalogen finns inte"
 
-#: elf/ldd.bash.in:150 inet/rcmd.c:475
+#: elf/ldd.bash.in:150 inet/rcmd.c:480
 msgid "not regular file"
 msgstr "inte en normal fil"
 
@@ -1540,68 +1540,68 @@ msgstr "vid insättning i sökträd"
 msgid "cannot generate output file"
 msgstr "kan inte generera utfil"
 
-#: inet/rcmd.c:155
+#: inet/rcmd.c:157
 msgid "rcmd: Cannot allocate memory\n"
 msgstr "rcmd: Kan inte allokera minne\n"
 
-#: inet/rcmd.c:170
+#: inet/rcmd.c:174
 msgid "rcmd: socket: All ports in use\n"
 msgstr "rcmd: uttag (socket): Alla portar används\n"
 
-#: inet/rcmd.c:198
+#: inet/rcmd.c:202
 #, c-format
 msgid "connect to address %s: "
 msgstr "anslut till adress %s: "
 
-#: inet/rcmd.c:211
+#: inet/rcmd.c:215
 #, c-format
 msgid "Trying %s...\n"
 msgstr "Provar %s...\n"
 
-#: inet/rcmd.c:247
+#: inet/rcmd.c:251
 #, c-format
 msgid "rcmd: write (setting up stderr): %m\n"
 msgstr "rcmd: write: (sätter upp standard fel): %m\n"
 
-#: inet/rcmd.c:263
+#: inet/rcmd.c:267
 #, c-format
 msgid "rcmd: poll (setting up stderr): %m\n"
 msgstr "rcmd: poll (sätter upp standard fel): %m\n"
 
-#: inet/rcmd.c:266
+#: inet/rcmd.c:270
 msgid "poll: protocol failure in circuit setup\n"
 msgstr "poll: protokollfel i förbindelseuppsättning\n"
 
-#: inet/rcmd.c:298
+#: inet/rcmd.c:302
 msgid "socket: protocol failure in circuit setup\n"
 msgstr "uttag (socket): protokollfel i förbindelseuppsättning\n"
 
-#: inet/rcmd.c:322
+#: inet/rcmd.c:326
 #, c-format
 msgid "rcmd: %s: short read"
 msgstr "rcmd: %s: läsning gav för lite data"
 
-#: inet/rcmd.c:473
+#: inet/rcmd.c:478
 msgid "lstat failed"
 msgstr "misslyckades ta status (lstat)"
 
-#: inet/rcmd.c:480
+#: inet/rcmd.c:485
 msgid "cannot open"
 msgstr "kan inte öppna"
 
-#: inet/rcmd.c:482
+#: inet/rcmd.c:487
 msgid "fstat failed"
 msgstr "misslyckades ta status (fstat)"
 
-#: inet/rcmd.c:484
+#: inet/rcmd.c:489
 msgid "bad owner"
 msgstr "felaktig ägare"
 
-#: inet/rcmd.c:486
+#: inet/rcmd.c:491
 msgid "writeable by other than owner"
 msgstr "skrivbar för andra än ägaren"
 
-#: inet/rcmd.c:488
+#: inet/rcmd.c:493
 msgid "hard linked somewhere"
 msgstr "hårdlänkad någonstans"
 
@@ -3143,7 +3143,7 @@ msgstr "Okänt systemfel"
 msgid "unable to free arguments"
 msgstr "kan inte avallokera argument"
 
-#: nis/nis_error.h:1 nis/ypclnt.c:817 nis/ypclnt.c:905 posix/regcomp.c:137
+#: nis/nis_error.h:1 nis/ypclnt.c:824 nis/ypclnt.c:913 posix/regcomp.c:137
 #: sysdeps/gnu/errlist.c:21
 msgid "Success"
 msgstr "Lyckat"
@@ -3184,8 +3184,8 @@ msgstr "Generiskt systemfel"
 msgid "First/next chain broken"
 msgstr "Första/Nästa-kedja bruten"
 
-#. TRANS Permission denied; the file permissions do not allow the attempted operation.
-#: nis/nis_error.h:11 nis/ypclnt.c:862 sysdeps/gnu/errlist.c:158
+#. TRANS The file permissions do not allow the attempted operation.
+#: nis/nis_error.h:11 nis/ypclnt.c:869 sysdeps/gnu/errlist.c:158
 msgid "Permission denied"
 msgstr "Åtkomst nekas"
 
@@ -3337,128 +3337,128 @@ msgstr "Kan inte skapa process hos server"
 msgid "Master server busy, full dump rescheduled."
 msgstr "Huvudserver är upptagen, full dump åter schemalagd."
 
-#: nis/nis_local_names.c:121
+#: nis/nis_local_names.c:122
 #, c-format
 msgid "LOCAL entry for UID %d in directory %s not unique\n"
 msgstr "LOCAL-post för UID %d i katalog %s är inte unik\n"
 
-#: nis/nis_print.c:51
+#: nis/nis_print.c:52
 msgid "UNKNOWN"
 msgstr "OKÄND"
 
-#: nis/nis_print.c:109
+#: nis/nis_print.c:110
 msgid "BOGUS OBJECT\n"
 msgstr "SKENOBJEKT\n"
 
-#: nis/nis_print.c:112
+#: nis/nis_print.c:113
 msgid "NO OBJECT\n"
 msgstr "INGET OBJEKT\n"
 
-#: nis/nis_print.c:115
+#: nis/nis_print.c:116
 msgid "DIRECTORY\n"
 msgstr "KATALOG\n"
 
-#: nis/nis_print.c:118
+#: nis/nis_print.c:119
 msgid "GROUP\n"
 msgstr "GRUPP\n"
 
-#: nis/nis_print.c:121
+#: nis/nis_print.c:122
 msgid "TABLE\n"
 msgstr "TABELL\n"
 
-#: nis/nis_print.c:124
+#: nis/nis_print.c:125
 msgid "ENTRY\n"
 msgstr "POST\n"
 
-#: nis/nis_print.c:127
+#: nis/nis_print.c:128
 msgid "LINK\n"
 msgstr "LÄNK\n"
 
-#: nis/nis_print.c:130
+#: nis/nis_print.c:131
 msgid "PRIVATE\n"
 msgstr "PRIVAT\n"
 
-#: nis/nis_print.c:133
+#: nis/nis_print.c:134
 msgid "(Unknown object)\n"
 msgstr "(Okänt objekt)\n"
 
-#: nis/nis_print.c:167
+#: nis/nis_print.c:168
 #, c-format
 msgid "Name : `%s'\n"
 msgstr "Namn: \"%s\"\n"
 
-#: nis/nis_print.c:168
+#: nis/nis_print.c:169
 #, c-format
 msgid "Type : %s\n"
 msgstr "Typ: %s\n"
 
-#: nis/nis_print.c:173
+#: nis/nis_print.c:174
 msgid "Master Server :\n"
 msgstr "Huvudserver:\n"
 
-#: nis/nis_print.c:175
+#: nis/nis_print.c:176
 msgid "Replicate :\n"
 msgstr "Replikera:\n"
 
-#: nis/nis_print.c:176
+#: nis/nis_print.c:177
 #, c-format
 msgid "\tName       : %s\n"
 msgstr "\tNamn       : %s\n"
 
-#: nis/nis_print.c:177
+#: nis/nis_print.c:178
 msgid "\tPublic Key : "
 msgstr "\tPublik nyckel: "
 
-#: nis/nis_print.c:181
+#: nis/nis_print.c:182
 msgid "None.\n"
 msgstr "Ingen.\n"
 
-#: nis/nis_print.c:184
+#: nis/nis_print.c:185
 #, c-format
 msgid "Diffie-Hellmann (%d bits)\n"
 msgstr "Diffie-Hellmann (%d bitar)\n"
 
-#: nis/nis_print.c:189
+#: nis/nis_print.c:190
 #, c-format
 msgid "RSA (%d bits)\n"
 msgstr "RSA (%d bitar)\n"
 
-#: nis/nis_print.c:192
+#: nis/nis_print.c:193
 msgid "Kerberos.\n"
 msgstr "Kerberos.\n"
 
-#: nis/nis_print.c:195
+#: nis/nis_print.c:196
 #, c-format
 msgid "Unknown (type = %d, bits = %d)\n"
 msgstr "Okänd (typ = %d, bitar = %d)\n"
 
-#: nis/nis_print.c:206
+#: nis/nis_print.c:207
 #, c-format
 msgid "\tUniversal addresses (%u)\n"
 msgstr "\tUniversella adresser (%u)\n"
 
-#: nis/nis_print.c:228
+#: nis/nis_print.c:229
 msgid "Time to live : "
 msgstr "Livslängd: "
 
-#: nis/nis_print.c:230
+#: nis/nis_print.c:231
 msgid "Default Access rights :\n"
 msgstr "Standard åtkomsträttigheter:\n"
 
-#: nis/nis_print.c:239
+#: nis/nis_print.c:240
 #, c-format
 msgid "\tType         : %s\n"
 msgstr "\tTyp          : %s\n"
 
-#: nis/nis_print.c:240
+#: nis/nis_print.c:241
 msgid "\tAccess rights: "
 msgstr "\tRättigheter  : "
 
-#: nis/nis_print.c:254
+#: nis/nis_print.c:255
 msgid "Group Flags :"
 msgstr "Gruppflaggor: "
 
-#: nis/nis_print.c:257
+#: nis/nis_print.c:258
 msgid ""
 "\n"
 "Group Members :\n"
@@ -3466,95 +3466,95 @@ msgstr ""
 "\n"
 "Gruppmedlemmar:\n"
 
-#: nis/nis_print.c:269
+#: nis/nis_print.c:270
 #, c-format
 msgid "Table Type          : %s\n"
 msgstr "Tabelltyp           : %s\n"
 
-#: nis/nis_print.c:270
+#: nis/nis_print.c:271
 #, c-format
 msgid "Number of Columns   : %d\n"
 msgstr "Antal kolumner      : %d\n"
 
-#: nis/nis_print.c:271
+#: nis/nis_print.c:272
 #, c-format
 msgid "Character Separator : %c\n"
 msgstr "Teckenseparator     : %c\n"
 
-#: nis/nis_print.c:272
+#: nis/nis_print.c:273
 #, c-format
 msgid "Search Path         : %s\n"
 msgstr "Sökväg              : %s\n"
 
-#: nis/nis_print.c:273
+#: nis/nis_print.c:274
 msgid "Columns             :\n"
 msgstr "Kolumner            :\n"
 
-#: nis/nis_print.c:276
+#: nis/nis_print.c:277
 #, c-format
 msgid "\t[%d]\tName          : %s\n"
 msgstr "\t[%d]\tNamn          : %s\n"
 
-#: nis/nis_print.c:278
+#: nis/nis_print.c:279
 msgid "\t\tAttributes    : "
 msgstr "\t\tAttribut      : "
 
-#: nis/nis_print.c:280
+#: nis/nis_print.c:281
 msgid "\t\tAccess Rights : "
 msgstr "\t\tRättigheter   : "
 
-#: nis/nis_print.c:290
+#: nis/nis_print.c:291
 msgid "Linked Object Type : "
 msgstr "Länkad objekttyp   : "
 
-#: nis/nis_print.c:292
+#: nis/nis_print.c:293
 #, c-format
 msgid "Linked to : %s\n"
 msgstr "Länkad till: %s\n"
 
-#: nis/nis_print.c:302
+#: nis/nis_print.c:303
 #, c-format
 msgid "\tEntry data of type %s\n"
 msgstr "\tPostdata av typ %s\n"
 
-#: nis/nis_print.c:305
+#: nis/nis_print.c:306
 #, c-format
 msgid "\t[%u] - [%u bytes] "
 msgstr "\t[%u] - [%u byte] "
 
-#: nis/nis_print.c:308
+#: nis/nis_print.c:309
 msgid "Encrypted data\n"
 msgstr "Krypterat data\n"
 
-#: nis/nis_print.c:310
+#: nis/nis_print.c:311
 msgid "Binary data\n"
 msgstr "Binärdata\n"
 
-#: nis/nis_print.c:326
+#: nis/nis_print.c:327
 #, c-format
 msgid "Object Name   : %s\n"
 msgstr "Objektnamn    : %s\n"
 
-#: nis/nis_print.c:327
+#: nis/nis_print.c:328
 #, c-format
 msgid "Directory     : %s\n"
 msgstr "Katalog       : %s\n"
 
-#: nis/nis_print.c:328
+#: nis/nis_print.c:329
 #, c-format
 msgid "Owner         : %s\n"
 msgstr "Ägare         : %s\n"
 
-#: nis/nis_print.c:329
+#: nis/nis_print.c:330
 #, c-format
 msgid "Group         : %s\n"
 msgstr "Grupp         : %s\n"
 
-#: nis/nis_print.c:330
+#: nis/nis_print.c:331
 msgid "Access Rights : "
 msgstr "Rättigheter   : "
 
-#: nis/nis_print.c:332
+#: nis/nis_print.c:333
 #, c-format
 msgid ""
 "\n"
@@ -3563,90 +3563,90 @@ msgstr ""
 "\n"
 "Livslängd     : "
 
-#: nis/nis_print.c:335
+#: nis/nis_print.c:336
 #, c-format
 msgid "Creation Time : %s"
 msgstr "Skapad        : %s"
 
-#: nis/nis_print.c:337
+#: nis/nis_print.c:338
 #, c-format
 msgid "Mod. Time     : %s"
 msgstr "Ändr. tid     : %s"
 
-#: nis/nis_print.c:338
+#: nis/nis_print.c:339
 msgid "Object Type   : "
 msgstr "Objekttyp     : "
 
-#: nis/nis_print.c:358
+#: nis/nis_print.c:359
 #, c-format
 msgid "    Data Length = %u\n"
 msgstr "    Datalängd = %u\n"
 
-#: nis/nis_print.c:372
+#: nis/nis_print.c:373
 #, c-format
 msgid "Status            : %s\n"
 msgstr "Status            : %s\n"
 
-#: nis/nis_print.c:373
+#: nis/nis_print.c:374
 #, c-format
 msgid "Number of objects : %u\n"
 msgstr "Antal objekt      : %u\n"
 
-#: nis/nis_print.c:377
+#: nis/nis_print.c:378
 #, c-format
 msgid "Object #%d:\n"
 msgstr "Objekt nr %d:\n"
 
-#: nis/nis_print_group_entry.c:116
+#: nis/nis_print_group_entry.c:117
 #, c-format
 msgid "Group entry for \"%s.%s\" group:\n"
 msgstr "Gruppost för \"%s.%s\" grupp:\n"
 
-#: nis/nis_print_group_entry.c:124
+#: nis/nis_print_group_entry.c:125
 msgid "    Explicit members:\n"
 msgstr "    Explicita medlemmar:\n"
 
-#: nis/nis_print_group_entry.c:129
+#: nis/nis_print_group_entry.c:130
 msgid "    No explicit members\n"
 msgstr "    Inga explicita medlemmar\n"
 
-#: nis/nis_print_group_entry.c:132
+#: nis/nis_print_group_entry.c:133
 msgid "    Implicit members:\n"
 msgstr "    Implicita medlemmar:\n"
 
-#: nis/nis_print_group_entry.c:137
+#: nis/nis_print_group_entry.c:138
 msgid "    No implicit members\n"
 msgstr "    Inga implicita medlemmar\n"
 
-#: nis/nis_print_group_entry.c:140
+#: nis/nis_print_group_entry.c:141
 msgid "    Recursive members:\n"
 msgstr "    Rekursiva medlemmar:\n"
 
-#: nis/nis_print_group_entry.c:145
+#: nis/nis_print_group_entry.c:146
 msgid "    No recursive members\n"
 msgstr "    Inga rekursiva medlemmar\n"
 
-#: nis/nis_print_group_entry.c:148
+#: nis/nis_print_group_entry.c:149
 msgid "    Explicit nonmembers:\n"
 msgstr "    Explicita icke-medlemmar:\n"
 
-#: nis/nis_print_group_entry.c:153
+#: nis/nis_print_group_entry.c:154
 msgid "    No explicit nonmembers\n"
 msgstr "    Inga explicita icke-medlemmar\n"
 
-#: nis/nis_print_group_entry.c:156
+#: nis/nis_print_group_entry.c:157
 msgid "    Implicit nonmembers:\n"
 msgstr "    Implicita icke-medlemmar:\n"
 
-#: nis/nis_print_group_entry.c:161
+#: nis/nis_print_group_entry.c:162
 msgid "    No implicit nonmembers\n"
 msgstr "    Inga implicita icke-medlemmar\n"
 
-#: nis/nis_print_group_entry.c:164
+#: nis/nis_print_group_entry.c:165
 msgid "    Recursive nonmembers:\n"
 msgstr "    Rekursiva icke-medlemmar:\n"
 
-#: nis/nis_print_group_entry.c:169
+#: nis/nis_print_group_entry.c:170
 msgid "    No recursive nonmembers\n"
 msgstr "    Inga rekursiva icke-medlemmar\n"
 
@@ -3688,100 +3688,100 @@ msgstr "netname2user: LOCAL-post för %s i katalog %s är inte unik"
 msgid "netname2user: should not have uid 0"
 msgstr "netname2user: borde inte ha uid 0"
 
-#: nis/ypclnt.c:820
+#: nis/ypclnt.c:827
 msgid "Request arguments bad"
 msgstr "Argument för förfrågan felaktiga"
 
-#: nis/ypclnt.c:823
+#: nis/ypclnt.c:830
 msgid "RPC failure on NIS operation"
 msgstr "RPC-fel vid NIS-operation"
 
-#: nis/ypclnt.c:826
+#: nis/ypclnt.c:833
 msgid "Can't bind to server which serves this domain"
 msgstr "Kan inte ansluta till servern som betjänar denna domän"
 
-#: nis/ypclnt.c:829
+#: nis/ypclnt.c:836
 msgid "No such map in server's domain"
 msgstr "Ingen sådan tabell i serverns domän"
 
-#: nis/ypclnt.c:832
+#: nis/ypclnt.c:839
 msgid "No such key in map"
 msgstr "Ingen sådan nyckel i tabellen"
 
-#: nis/ypclnt.c:835
+#: nis/ypclnt.c:842
 msgid "Internal NIS error"
 msgstr "Internt NIS-fel"
 
-#: nis/ypclnt.c:838
+#: nis/ypclnt.c:845
 msgid "Local resource allocation failure"
 msgstr "Allokeringsfel för lokal resurs"
 
-#: nis/ypclnt.c:841
+#: nis/ypclnt.c:848
 msgid "No more records in map database"
 msgstr "Inga fler poster i tabelldatabasen"
 
-#: nis/ypclnt.c:844
+#: nis/ypclnt.c:851
 msgid "Can't communicate with portmapper"
 msgstr "Kan inte kommunicera med portmapper"
 
-#: nis/ypclnt.c:847
+#: nis/ypclnt.c:854
 msgid "Can't communicate with ypbind"
 msgstr "Kan inte kommunicera med ypbind"
 
-#: nis/ypclnt.c:850
+#: nis/ypclnt.c:857
 msgid "Can't communicate with ypserv"
 msgstr "Kan inte kommunicera med ypserv"
 
-#: nis/ypclnt.c:853
+#: nis/ypclnt.c:860
 msgid "Local domain name not set"
 msgstr "Lokalt domännamn inte satt"
 
-#: nis/ypclnt.c:856
+#: nis/ypclnt.c:863
 msgid "NIS map database is bad"
 msgstr "NIS tabelldatabas är felaktig"
 
-#: nis/ypclnt.c:859
+#: nis/ypclnt.c:866
 msgid "NIS client/server version mismatch - can't supply service"
 msgstr "NIS versionsskillnad klient/server - kan inte betjäna"
 
-#: nis/ypclnt.c:865
+#: nis/ypclnt.c:872
 msgid "Database is busy"
 msgstr "Databasen är upptagen"
 
-#: nis/ypclnt.c:868
+#: nis/ypclnt.c:875
 msgid "Unknown NIS error code"
 msgstr "Okänd NIS-felkod"
 
-#: nis/ypclnt.c:908
+#: nis/ypclnt.c:916
 msgid "Internal ypbind error"
 msgstr "Internt ypbind-fel"
 
-#: nis/ypclnt.c:911
+#: nis/ypclnt.c:919
 msgid "Domain not bound"
 msgstr "Domän inte bunden"
 
-#: nis/ypclnt.c:914
+#: nis/ypclnt.c:922
 msgid "System resource allocation failure"
 msgstr "Allokeringsfel för systemresurs"
 
-#: nis/ypclnt.c:917
+#: nis/ypclnt.c:925
 msgid "Unknown ypbind error"
 msgstr "Okänt ypbind-fel"
 
-#: nis/ypclnt.c:958
+#: nis/ypclnt.c:966
 msgid "yp_update: cannot convert host to netname\n"
 msgstr "yp_update: kan inte omvandla värd till nätnamn\n"
 
-#: nis/ypclnt.c:976
+#: nis/ypclnt.c:984
 msgid "yp_update: cannot get server address\n"
 msgstr "yp_update: kan inte hämta serveradress\n"
 
-#: nscd/aicache.c:84 nscd/hstcache.c:485
+#: nscd/aicache.c:85 nscd/hstcache.c:485
 #, c-format
 msgid "Haven't found \"%s\" in hosts cache!"
 msgstr "Hittar inte \"%s\" i värdcache!"
 
-#: nscd/aicache.c:86 nscd/hstcache.c:487
+#: nscd/aicache.c:87 nscd/hstcache.c:487
 #, c-format
 msgid "Reloading \"%s\" in hosts cache!"
 msgstr "Omladdar \"%s\" i värdcache!"
@@ -3815,269 +3815,264 @@ msgstr "beskär %s cache; tid %ld"
 msgid "considering %s entry \"%s\", timeout %<PRIu64>"
 msgstr "överväger %s-post \"%s\", tidsgräns %<PRIu64>"
 
-#: nscd/connections.c:548
+#: nscd/connections.c:537
 #, c-format
 msgid "invalid persistent database file \"%s\": %s"
 msgstr "ogiltig persistent databasfil \"%s\": %s"
 
-#: nscd/connections.c:556
+#: nscd/connections.c:545
 msgid "uninitialized header"
 msgstr "oinitierat huvud"
 
-#: nscd/connections.c:561
+#: nscd/connections.c:550
 msgid "header size does not match"
 msgstr "huvudstorlek stämmer inte"
 
-#: nscd/connections.c:571
+#: nscd/connections.c:560
 msgid "file size does not match"
 msgstr "filstorlek stämmer inte"
 
-#: nscd/connections.c:588
+#: nscd/connections.c:577
 msgid "verification failed"
 msgstr "verifikation misslyckades"
 
-#: nscd/connections.c:602
+#: nscd/connections.c:591
 #, c-format
 msgid "suggested size of table for database %s larger than the persistent database's table"
 msgstr "föreslagen storlek på tabellen för databas %s är större än den persistenta databasens tabell"
 
-#: nscd/connections.c:613 nscd/connections.c:697
+#: nscd/connections.c:602 nscd/connections.c:686
 #, c-format
 msgid "cannot create read-only descriptor for \"%s\"; no mmap"
 msgstr "kan inte skapa läsbar filidentifierare för \"%s\", ingen mmap"
 
-#: nscd/connections.c:629
+#: nscd/connections.c:618
 #, c-format
 msgid "cannot access '%s'"
 msgstr "kan inte komma åt \"%s\""
 
-#: nscd/connections.c:677
+#: nscd/connections.c:666
 #, c-format
 msgid "database for %s corrupted or simultaneously used; remove %s manually if necessary and restart"
 msgstr "databas för %s korrupt eller använd av flera samtidigt; ta bort %s manuellt om det behövs och starta om"
 
-#: nscd/connections.c:683
+#: nscd/connections.c:672
 #, c-format
 msgid "cannot create %s; no persistent database used"
 msgstr "kan inte skapa %s; ingen persistent databas används"
 
-#: nscd/connections.c:686
+#: nscd/connections.c:675
 #, c-format
 msgid "cannot create %s; no sharing possible"
 msgstr "kan inte skapa %s; ingen delning möjlig"
 
-#: nscd/connections.c:757
+#: nscd/connections.c:746
 #, c-format
 msgid "cannot write to database file %s: %s"
 msgstr "kan inte skriva till databasfil %s: %s"
 
-#: nscd/connections.c:796
-#, c-format
-msgid "cannot set socket to close on exec: %s; disabling paranoia mode"
-msgstr "kan inte sätta uttag (socket) att stängas vid programstart: %s; kopplar ur paranoialäge"
-
-#: nscd/connections.c:831
+#: nscd/connections.c:802
 #, c-format
 msgid "cannot open socket: %s"
 msgstr "kan inte öppna uttag (socket): %s"
 
-#: nscd/connections.c:850
+#: nscd/connections.c:821
 #, c-format
 msgid "cannot enable socket to accept connections: %s"
 msgstr "kan inte få uttag (socket) att acceptera förbindelser: %s"
 
-#: nscd/connections.c:907
+#: nscd/connections.c:878
 #, c-format
 msgid "disabled inotify-based monitoring for file `%s': %s"
 msgstr "avaktiverade inotify-baserad övervakning för filen ”%s”: %s"
 
-#: nscd/connections.c:911
+#: nscd/connections.c:882
 #, c-format
 msgid "monitoring file `%s` (%d)"
 msgstr "övervakar filen ”%s” (%d)"
 
-#: nscd/connections.c:924
+#: nscd/connections.c:895
 #, c-format
 msgid "disabled inotify-based monitoring for directory `%s': %s"
 msgstr "avaktiverade inotify-baserad övervakning av katalogen ”%s”: %s"
 
-#: nscd/connections.c:928
+#: nscd/connections.c:899
 #, c-format
 msgid "monitoring directory `%s` (%d)"
 msgstr "övervakar katalogen ”%s” (%d)"
 
-#: nscd/connections.c:956
+#: nscd/connections.c:927
 #, c-format
 msgid "monitoring file %s for database %s"
 msgstr "övervakar filen %s för databas %s"
 
-#: nscd/connections.c:966
+#: nscd/connections.c:937
 #, c-format
 msgid "stat failed for file `%s'; will try again later: %s"
 msgstr "stat misslyckades för filen ”%s”; kommer försöka igen senare: %s"
 
-#: nscd/connections.c:1085
+#: nscd/connections.c:1056
 #, c-format
 msgid "provide access to FD %d, for %s"
 msgstr "ge åtkomst till FD %d, för %s"
 
-#: nscd/connections.c:1097
+#: nscd/connections.c:1068
 #, c-format
 msgid "cannot handle old request version %d; current version is %d"
 msgstr "kan inte hantera äldre förfrågansversion %d, nuvarande version är %d"
 
-#: nscd/connections.c:1119
+#: nscd/connections.c:1090
 #, c-format
 msgid "request from %ld not handled due to missing permission"
 msgstr "begäran från %ld inte hanterad för att rättigheter saknas"
 
-#: nscd/connections.c:1124
+#: nscd/connections.c:1095
 #, c-format
 msgid "request from '%s' [%ld] not handled due to missing permission"
 msgstr "begäran från \"%s\" [%ld] inte hanterad för att rättigheter saknas"
 
-#: nscd/connections.c:1129
+#: nscd/connections.c:1100
 msgid "request not handled due to missing permission"
 msgstr "begäran inte hanterad för att rättigheter saknas"
 
-#: nscd/connections.c:1167 nscd/connections.c:1220
+#: nscd/connections.c:1138 nscd/connections.c:1191
 #, c-format
 msgid "cannot write result: %s"
 msgstr "kan inte skriva resultat: %s"
 
-#: nscd/connections.c:1311
+#: nscd/connections.c:1282
 #, c-format
 msgid "error getting caller's id: %s"
 msgstr "kunde inte hämta anropandes identitet: %s"
 
-#: nscd/connections.c:1371
+#: nscd/connections.c:1342
 #, c-format
 msgid "cannot open /proc/self/cmdline: %s; disabling paranoia mode"
 msgstr "kan inte öppna /proc/slef/cmdline: %s, kopplar ur paranoialäge"
 
-#: nscd/connections.c:1385
+#: nscd/connections.c:1356
 #, c-format
 msgid "cannot read /proc/self/cmdline: %s; disabling paranoia mode"
 msgstr "kan inte läsa /proc/self/cmdline: %s, kopplar ur paranoialäge"
 
-#: nscd/connections.c:1425
+#: nscd/connections.c:1396
 #, c-format
 msgid "cannot change to old UID: %s; disabling paranoia mode"
 msgstr "kan inte byta till föregående UID: %s; kopplar ur paranoialäge"
 
-#: nscd/connections.c:1435
+#: nscd/connections.c:1406
 #, c-format
 msgid "cannot change to old GID: %s; disabling paranoia mode"
 msgstr "kan inte byta till föregående GID: %s; kopplar ur paranoialäge"
 
-#: nscd/connections.c:1448
+#: nscd/connections.c:1419
 #, c-format
 msgid "cannot change to old working directory: %s; disabling paranoia mode"
 msgstr "kan inte byta till föregående arbetskatalog: %s; kopplar ur paranoialäge"
 
-#: nscd/connections.c:1494
+#: nscd/connections.c:1465
 #, c-format
 msgid "re-exec failed: %s; disabling paranoia mode"
 msgstr "återstart misslyckades: %s; kopplar ur paranoialäge"
 
-#: nscd/connections.c:1503
+#: nscd/connections.c:1474
 #, c-format
 msgid "cannot change current working directory to \"/\": %s"
 msgstr "kan inte byta aktuell katalog till \"/\": %s"
 
-#: nscd/connections.c:1696
+#: nscd/connections.c:1657
 #, c-format
 msgid "short read while reading request: %s"
 msgstr "fattas data vid läsning av begäran: %s"
 
-#: nscd/connections.c:1729
+#: nscd/connections.c:1690
 #, c-format
 msgid "key length in request too long: %d"
 msgstr "nyckellängd i begäran för lång: %d"
 
-#: nscd/connections.c:1742
+#: nscd/connections.c:1703
 #, c-format
 msgid "short read while reading request key: %s"
 msgstr "fattas data vid läsning av begäransnyckel: %s"
 
-#: nscd/connections.c:1752
+#: nscd/connections.c:1713
 #, c-format
 msgid "handle_request: request received (Version = %d) from PID %ld"
 msgstr "handle_request: begäran mottagen (Version = %d) från PID %ld"
 
-#: nscd/connections.c:1757
+#: nscd/connections.c:1718
 #, c-format
 msgid "handle_request: request received (Version = %d)"
 msgstr "handle_request: begäran mottagen (Version = %d)"
 
-#: nscd/connections.c:1897
+#: nscd/connections.c:1858
 #, c-format
 msgid "ignored inotify event for `%s` (file exists)"
 msgstr "ignorerade inotify-händelse för ”%s” (filen finns)"
 
-#: nscd/connections.c:1902
+#: nscd/connections.c:1863
 #, c-format
 msgid "monitored file `%s` was %s, removing watch"
 msgstr "den övervakade filen ”%s” var %s, tar bort vakten"
 
-#: nscd/connections.c:1910 nscd/connections.c:1952
+#: nscd/connections.c:1871 nscd/connections.c:1913
 #, c-format
 msgid "failed to remove file watch `%s`: %s"
 msgstr "misslyckades att ta bort filvakt ”%s”: %s"
 
-#: nscd/connections.c:1925
+#: nscd/connections.c:1886
 #, c-format
 msgid "monitored file `%s` was written to"
 msgstr "den övervakade filen ”%s” skrevs till"
 
-#: nscd/connections.c:1949
+#: nscd/connections.c:1910
 #, c-format
 msgid "monitored parent directory `%s` was %s, removing watch on `%s`"
 msgstr "den övervakade föräldrakatalogen ”%s” var %s, tar bort vakten av ”%s”"
 
-#: nscd/connections.c:1975
+#: nscd/connections.c:1936
 #, c-format
 msgid "monitored file `%s` was %s, adding watch"
 msgstr "den övervakade filen ”%s” var %s, lägger till vakt"
 
-#: nscd/connections.c:1987
+#: nscd/connections.c:1948
 #, c-format
 msgid "failed to add file watch `%s`: %s"
 msgstr "misslyckades med att lägga till filvakt ”%s”: %s"
 
-#: nscd/connections.c:2181 nscd/connections.c:2362
+#: nscd/connections.c:2126 nscd/connections.c:2291
 #, c-format
 msgid "disabled inotify-based monitoring after read error %d"
 msgstr "avaktiverade inotify-baserad övervakning efter läsfel %d"
 
-#: nscd/connections.c:2477
+#: nscd/connections.c:2406
 msgid "could not initialize conditional variable"
 msgstr "kan inte initiera villkorsvariabel"
 
-#: nscd/connections.c:2485
+#: nscd/connections.c:2414
 msgid "could not start clean-up thread; terminating"
 msgstr "kunde inte starta städtråd; avslutar"
 
-#: nscd/connections.c:2499
+#: nscd/connections.c:2428
 msgid "could not start any worker thread; terminating"
 msgstr "kunde inte starta någon arbetstråd; avslutar"
 
-#: nscd/connections.c:2554 nscd/connections.c:2556 nscd/connections.c:2572
-#: nscd/connections.c:2582 nscd/connections.c:2600 nscd/connections.c:2611
-#: nscd/connections.c:2621
+#: nscd/connections.c:2483 nscd/connections.c:2485 nscd/connections.c:2501
+#: nscd/connections.c:2511 nscd/connections.c:2529 nscd/connections.c:2540
+#: nscd/connections.c:2550
 #, c-format
 msgid "Failed to run nscd as user '%s'"
 msgstr "Misslyckades att köra nscd som användare \"%s\""
 
-#: nscd/connections.c:2574
+#: nscd/connections.c:2503
 msgid "initial getgrouplist failed"
 msgstr "första getgrouplist misslyckades"
 
-#: nscd/connections.c:2583
+#: nscd/connections.c:2512
 msgid "getgrouplist failed"
 msgstr "getgrouplist misslyckades"
 
-#: nscd/connections.c:2601
+#: nscd/connections.c:2530
 msgid "setgroups failed"
 msgstr "setgroups misslyckades"
 
@@ -4760,62 +4755,41 @@ msgstr "odefinierad"
 msgid "Unrecognized variable `%s'"
 msgstr "Okänd variabel \"%s\""
 
-#: posix/getopt.c:592 posix/getopt.c:621
+#: posix/getopt.c:277
 #, c-format
-msgid "%s: option '%s' is ambiguous; possibilities:"
-msgstr "%s: flaggan \"%s\" är tvetydig; alternativ:"
+msgid "%s: option '%s%s' is ambiguous\n"
+msgstr "%s: flaggan ”%s%s” är tvetydig\n"
 
-#: posix/getopt.c:662 posix/getopt.c:666
+#: posix/getopt.c:283
 #, c-format
-msgid "%s: option '--%s' doesn't allow an argument\n"
-msgstr "%s: flaggan \"--%s\" tar inget argument\n"
+msgid "%s: option '%s%s' is ambiguous; possibilities:"
+msgstr "%s: flaggan ”%s%s” är tvetydig; alternativ:"
 
-#: posix/getopt.c:675 posix/getopt.c:680
+#: posix/getopt.c:318
 #, c-format
-msgid "%s: option '%c%s' doesn't allow an argument\n"
-msgstr "%s: flaggan \"%c%s\" tar inget argument\n"
+msgid "%s: unrecognized option '%s%s'\n"
+msgstr "%s: okänd flagga ”%s%s”\n"
 
-#: posix/getopt.c:723 posix/getopt.c:742
+#: posix/getopt.c:344
 #, c-format
-msgid "%s: option '--%s' requires an argument\n"
-msgstr "%s: flaggan \"--%s\" kräver ett argument\n"
+msgid "%s: option '%s%s' doesn't allow an argument\n"
+msgstr "%s: flaggan ”%s%s” tar inget argument\n"
 
-#: posix/getopt.c:780 posix/getopt.c:783
+#: posix/getopt.c:359
 #, c-format
-msgid "%s: unrecognized option '--%s'\n"
-msgstr "%s: okänd flagga \"--%s\"\n"
+msgid "%s: option '%s%s' requires an argument\n"
+msgstr "%s: flaggan ”%s%s” kräver ett argument\n"
 
-#: posix/getopt.c:791 posix/getopt.c:794
-#, c-format
-msgid "%s: unrecognized option '%c%s'\n"
-msgstr "%s: okänd flagga \"%c%s\"\n"
-
-#: posix/getopt.c:843 posix/getopt.c:846
+#: posix/getopt.c:620
 #, c-format
 msgid "%s: invalid option -- '%c'\n"
 msgstr "%s: ogiltig flagga -- \"%c\"\n"
 
-#: posix/getopt.c:899 posix/getopt.c:916 posix/getopt.c:1126
-#: posix/getopt.c:1144
+#: posix/getopt.c:635 posix/getopt.c:681
 #, c-format
 msgid "%s: option requires an argument -- '%c'\n"
 msgstr "%s: flaggan kräver ett argument -- \"%c\"\n"
 
-#: posix/getopt.c:972 posix/getopt.c:988
-#, c-format
-msgid "%s: option '-W %s' is ambiguous\n"
-msgstr "%s: flaggan \"-W %s\" är tvetydig\n"
-
-#: posix/getopt.c:1012 posix/getopt.c:1030
-#, c-format
-msgid "%s: option '-W %s' doesn't allow an argument\n"
-msgstr "%s: flaggan \"-W %s\" tar inget argument\n"
-
-#: posix/getopt.c:1051 posix/getopt.c:1069
-#, c-format
-msgid "%s: option '-W %s' requires an argument\n"
-msgstr "%s: flaggan \"-W %s\" kräver ett argument\n"
-
 #: posix/regcomp.c:140
 msgid "No match"
 msgstr "Ingen träff"
@@ -4884,7 +4858,7 @@ msgstr "Obalanserade ) eller \\)"
 msgid "No previous regular expression"
 msgstr "Inget föregående reguljärt uttryck"
 
-#: posix/wordexp.c:1852
+#: posix/wordexp.c:1822
 msgid "parameter null or not set"
 msgstr "parameter är tom eller inte satt"
 
@@ -5069,7 +5043,7 @@ msgstr "Buffertplats för utdata tillgängligt"
 msgid "Input message available"
 msgstr "Inkommande meddelande tillgängligt"
 
-#: stdio-common/psiginfo-data.h:46 timezone/zdump.c:541 timezone/zic.c:483
+#: stdio-common/psiginfo-data.h:46 timezone/zdump.c:381 timezone/zic.c:520
 msgid "I/O error"
 msgstr "I/O-fel"
 
@@ -5149,170 +5123,170 @@ msgstr "Realtidssignal %d"
 msgid "Unknown signal %d"
 msgstr "Okänd signal %d"
 
-#: sunrpc/auth_unix.c:111 sunrpc/clnt_tcp.c:123 sunrpc/clnt_udp.c:135
-#: sunrpc/clnt_unix.c:124 sunrpc/svc_tcp.c:188 sunrpc/svc_tcp.c:233
-#: sunrpc/svc_udp.c:160 sunrpc/svc_unix.c:188 sunrpc/svc_unix.c:229
-#: sunrpc/xdr.c:627 sunrpc/xdr.c:787 sunrpc/xdr_array.c:101
-#: sunrpc/xdr_rec.c:152 sunrpc/xdr_ref.c:78
+#: sunrpc/auth_unix.c:112 sunrpc/clnt_tcp.c:124 sunrpc/clnt_udp.c:139
+#: sunrpc/clnt_unix.c:125 sunrpc/svc_tcp.c:189 sunrpc/svc_tcp.c:234
+#: sunrpc/svc_udp.c:161 sunrpc/svc_unix.c:189 sunrpc/svc_unix.c:230
+#: sunrpc/xdr.c:628 sunrpc/xdr.c:788 sunrpc/xdr_array.c:102
+#: sunrpc/xdr_rec.c:153 sunrpc/xdr_ref.c:79
 msgid "out of memory\n"
 msgstr "minnet slut\n"
 
-#: sunrpc/auth_unix.c:349
+#: sunrpc/auth_unix.c:350
 msgid "auth_unix.c: Fatal marshalling problem"
 msgstr "auth_unix.c: Fatalt kodningsproblem"
 
-#: sunrpc/clnt_perr.c:95 sunrpc/clnt_perr.c:111
+#: sunrpc/clnt_perr.c:96 sunrpc/clnt_perr.c:112
 #, c-format
 msgid "%s: %s; low version = %lu, high version = %lu"
 msgstr "%s: %s; undre version = %lu, övre version = %lu"
 
-#: sunrpc/clnt_perr.c:102
+#: sunrpc/clnt_perr.c:103
 #, c-format
 msgid "%s: %s; why = %s\n"
 msgstr "%s: %s; varför = %s\n"
 
-#: sunrpc/clnt_perr.c:104
+#: sunrpc/clnt_perr.c:105
 #, c-format
 msgid "%s: %s; why = (unknown authentication error - %d)\n"
 msgstr "%s: %s; varför = (okänt fel vid äkthetskontroll - %d)\n"
 
-#: sunrpc/clnt_perr.c:153
+#: sunrpc/clnt_perr.c:154
 msgid "RPC: Success"
 msgstr "RPC: Lyckat"
 
-#: sunrpc/clnt_perr.c:156
+#: sunrpc/clnt_perr.c:157
 msgid "RPC: Can't encode arguments"
 msgstr "RPC: Kan inte koda argumentet"
 
-#: sunrpc/clnt_perr.c:160
+#: sunrpc/clnt_perr.c:161
 msgid "RPC: Can't decode result"
 msgstr "RPC: Kan inte avkoda resultatet"
 
-#: sunrpc/clnt_perr.c:164
+#: sunrpc/clnt_perr.c:165
 msgid "RPC: Unable to send"
 msgstr "RPC: Kan inte skicka"
 
-#: sunrpc/clnt_perr.c:168
+#: sunrpc/clnt_perr.c:169
 msgid "RPC: Unable to receive"
 msgstr "RPC: Kan inte ta emot"
 
-#: sunrpc/clnt_perr.c:172
+#: sunrpc/clnt_perr.c:173
 msgid "RPC: Timed out"
 msgstr "RPC: Tiden löpte ut"
 
-#: sunrpc/clnt_perr.c:176
+#: sunrpc/clnt_perr.c:177
 msgid "RPC: Incompatible versions of RPC"
 msgstr "RPC: Inkompatibla versioner av RPC"
 
-#: sunrpc/clnt_perr.c:180
+#: sunrpc/clnt_perr.c:181
 msgid "RPC: Authentication error"
 msgstr "RPC: Fel vid äkthetskontroll"
 
-#: sunrpc/clnt_perr.c:184
+#: sunrpc/clnt_perr.c:185
 msgid "RPC: Program unavailable"
 msgstr "RPC: Programmet otillgängligt"
 
-#: sunrpc/clnt_perr.c:188
+#: sunrpc/clnt_perr.c:189
 msgid "RPC: Program/version mismatch"
 msgstr "RPC: Program/version-inkompatibilitet"
 
-#: sunrpc/clnt_perr.c:192
+#: sunrpc/clnt_perr.c:193
 msgid "RPC: Procedure unavailable"
 msgstr "RPC: Procedur inte tillgänglig"
 
-#: sunrpc/clnt_perr.c:196
+#: sunrpc/clnt_perr.c:197
 msgid "RPC: Server can't decode arguments"
 msgstr "RPC: Server kan inte avkoda argumenten"
 
-#: sunrpc/clnt_perr.c:200
+#: sunrpc/clnt_perr.c:201
 msgid "RPC: Remote system error"
 msgstr "RPC: Fjärrsystemsfel"
 
-#: sunrpc/clnt_perr.c:204
+#: sunrpc/clnt_perr.c:205
 msgid "RPC: Unknown host"
 msgstr "RPC: Okänd värdmaskin"
 
-#: sunrpc/clnt_perr.c:208
+#: sunrpc/clnt_perr.c:209
 msgid "RPC: Unknown protocol"
 msgstr "RPC: Okänt protokoll"
 
-#: sunrpc/clnt_perr.c:212
+#: sunrpc/clnt_perr.c:213
 msgid "RPC: Port mapper failure"
 msgstr "RPC: Fel i portöversättare"
 
-#: sunrpc/clnt_perr.c:216
+#: sunrpc/clnt_perr.c:217
 msgid "RPC: Program not registered"
 msgstr "RPC: Programmet inte registrerat"
 
-#: sunrpc/clnt_perr.c:220
+#: sunrpc/clnt_perr.c:221
 msgid "RPC: Failed (unspecified error)"
 msgstr "RPC: Misslyckades (ospecificerat fel)"
 
-#: sunrpc/clnt_perr.c:261
+#: sunrpc/clnt_perr.c:262
 msgid "RPC: (unknown error code)"
 msgstr "RPC: (okänd felkod)"
 
-#: sunrpc/clnt_perr.c:333
+#: sunrpc/clnt_perr.c:334
 msgid "Authentication OK"
 msgstr "Äkthetskontroll OK"
 
-#: sunrpc/clnt_perr.c:336
+#: sunrpc/clnt_perr.c:337
 msgid "Invalid client credential"
 msgstr "Ogiltiga klientreferenser"
 
-#: sunrpc/clnt_perr.c:340
+#: sunrpc/clnt_perr.c:341
 msgid "Server rejected credential"
 msgstr "Server förkastade kreditiv"
 
-#: sunrpc/clnt_perr.c:344
+#: sunrpc/clnt_perr.c:345
 msgid "Invalid client verifier"
 msgstr "Ogiltig klientverifierare"
 
-#: sunrpc/clnt_perr.c:348
+#: sunrpc/clnt_perr.c:349
 msgid "Server rejected verifier"
 msgstr "Server förkastade verifierare"
 
-#: sunrpc/clnt_perr.c:352
+#: sunrpc/clnt_perr.c:353
 msgid "Client credential too weak"
 msgstr "Klientens referenser är för svaga"
 
-#: sunrpc/clnt_perr.c:356
+#: sunrpc/clnt_perr.c:357
 msgid "Invalid server verifier"
 msgstr "Ogiltig serververifierare"
 
-#: sunrpc/clnt_perr.c:360
+#: sunrpc/clnt_perr.c:361
 msgid "Failed (unspecified error)"
 msgstr "Misslyckades (ospecificerat fel)"
 
-#: sunrpc/clnt_raw.c:115
+#: sunrpc/clnt_raw.c:116
 msgid "clnt_raw.c: fatal header serialization error"
 msgstr "clnt_raw.c: fatalt fel vid serialisering"
 
-#: sunrpc/pm_getmaps.c:77
+#: sunrpc/pm_getmaps.c:78
 msgid "pmap_getmaps.c: rpc problem"
 msgstr "pmap_getmaps.c rpc problem"
 
-#: sunrpc/pmap_clnt.c:127
+#: sunrpc/pmap_clnt.c:128
 msgid "Cannot register service"
 msgstr "Kan inte registrera tjänst"
 
-#: sunrpc/pmap_rmt.c:244
+#: sunrpc/pmap_rmt.c:245
 msgid "Cannot create socket for broadcast rpc"
 msgstr "Kan inte skapa uttag (socket) för utsändnings-rpc"
 
-#: sunrpc/pmap_rmt.c:251
+#: sunrpc/pmap_rmt.c:252
 msgid "Cannot set socket option SO_BROADCAST"
 msgstr "Kan inte sätta uttagsflaggan (socket option) SO_BROADCAST"
 
-#: sunrpc/pmap_rmt.c:303
+#: sunrpc/pmap_rmt.c:304
 msgid "Cannot send broadcast packet"
 msgstr "Kan inte skicka utsändningspaket"
 
-#: sunrpc/pmap_rmt.c:328
+#: sunrpc/pmap_rmt.c:329
 msgid "Broadcast poll problem"
 msgstr "Problem med poll vid utsändning"
 
-#: sunrpc/pmap_rmt.c:341
+#: sunrpc/pmap_rmt.c:342
 msgid "Cannot receive reply to broadcast"
 msgstr "Kan inte ta emot svar på utsändning"
 
@@ -5595,11 +5569,11 @@ msgstr "tom teckensträng"
 msgid "preprocessor error"
 msgstr "preprocessorfel"
 
-#: sunrpc/svc_run.c:71
+#: sunrpc/svc_run.c:72
 msgid "svc_run: - out of memory"
 msgstr "svc_run: - minnet slut"
 
-#: sunrpc/svc_run.c:91
+#: sunrpc/svc_run.c:92
 msgid "svc_run: - poll failed"
 msgstr "svc_run: - poll misslyckades"
 
@@ -5631,204 +5605,204 @@ msgstr "problem att svara till prog %d\n"
 msgid "never registered prog %d\n"
 msgstr "aldrig registrerat prog %d\n"
 
-#: sunrpc/svc_tcp.c:164
+#: sunrpc/svc_tcp.c:165
 msgid "svc_tcp.c - tcp socket creation problem"
 msgstr "svc_tcp.c - problem att skapa tcp-uttag (socket)"
 
-#: sunrpc/svc_tcp.c:179
+#: sunrpc/svc_tcp.c:180
 msgid "svc_tcp.c - cannot getsockname or listen"
 msgstr "svc_tcp.c - kan inte anropa getsockname eller listen"
 
-#: sunrpc/svc_udp.c:135
+#: sunrpc/svc_udp.c:136
 msgid "svcudp_create: socket creation problem"
 msgstr "svcudp_create: problem att skapa uttag (socket)"
 
-#: sunrpc/svc_udp.c:149
+#: sunrpc/svc_udp.c:150
 msgid "svcudp_create - cannot getsockname"
 msgstr "svcudp_create - kan inte anropa getsockname"
 
-#: sunrpc/svc_udp.c:181
+#: sunrpc/svc_udp.c:182
 msgid "svcudp_create: xp_pad is too small for IP_PKTINFO\n"
 msgstr "svcudp_create: xp_pad är för liten för IP_PKTINFO\n"
 
-#: sunrpc/svc_udp.c:480
+#: sunrpc/svc_udp.c:481
 msgid "enablecache: cache already enabled"
 msgstr "enablecache: cache redan påslagen"
 
-#: sunrpc/svc_udp.c:486
+#: sunrpc/svc_udp.c:487
 msgid "enablecache: could not allocate cache"
 msgstr "enablecache: kunde inte allokera cache"
 
-#: sunrpc/svc_udp.c:495
+#: sunrpc/svc_udp.c:496
 msgid "enablecache: could not allocate cache data"
 msgstr "enablecache: kunde inte allokera cache-data"
 
-#: sunrpc/svc_udp.c:503
+#: sunrpc/svc_udp.c:504
 msgid "enablecache: could not allocate cache fifo"
 msgstr "enablecache: kunde inte allokera cache-fifo"
 
-#: sunrpc/svc_udp.c:539
+#: sunrpc/svc_udp.c:540
 msgid "cache_set: victim not found"
 msgstr "cache_set: offer hittades inte"
 
-#: sunrpc/svc_udp.c:550
+#: sunrpc/svc_udp.c:551
 msgid "cache_set: victim alloc failed"
 msgstr "cache_set: offerallokering misslyckades"
 
-#: sunrpc/svc_udp.c:557
+#: sunrpc/svc_udp.c:558
 msgid "cache_set: could not allocate new rpc_buffer"
 msgstr "cache_set: kunde inte allokera ny rpc-buffert"
 
-#: sunrpc/svc_unix.c:162
+#: sunrpc/svc_unix.c:163
 msgid "svc_unix.c - AF_UNIX socket creation problem"
 msgstr "svc_unix.c - problem att skapa AF_UNIX uttag (socket)"
 
-#: sunrpc/svc_unix.c:178
+#: sunrpc/svc_unix.c:179
 msgid "svc_unix.c - cannot getsockname or listen"
 msgstr "svc_unix.c - kan inte anropa getsockname eller listen"
 
-#: sysdeps/generic/siglist.h:28
+#: sysdeps/generic/siglist.h:29
 msgid "Hangup"
 msgstr "Avringd"
 
-#: sysdeps/generic/siglist.h:29
+#: sysdeps/generic/siglist.h:30
 msgid "Interrupt"
 msgstr "Avbruten (SIGINT)"
 
-#: sysdeps/generic/siglist.h:30
+#: sysdeps/generic/siglist.h:31
 msgid "Quit"
 msgstr "Lämnad"
 
-#: sysdeps/generic/siglist.h:31
+#: sysdeps/generic/siglist.h:32
 msgid "Illegal instruction"
 msgstr "Otillåten instruktion"
 
-#: sysdeps/generic/siglist.h:32
+#: sysdeps/generic/siglist.h:33
 msgid "Trace/breakpoint trap"
 msgstr "Spårningsfälla"
 
-#: sysdeps/generic/siglist.h:33
+#: sysdeps/generic/siglist.h:34
 msgid "Aborted"
 msgstr "Avbruten (SIGABRT)"
 
-#: sysdeps/generic/siglist.h:34
+#: sysdeps/generic/siglist.h:35
 msgid "Floating point exception"
 msgstr "Flyttalsfel"
 
-#: sysdeps/generic/siglist.h:35
+#: sysdeps/generic/siglist.h:36
 msgid "Killed"
 msgstr "Dödad"
 
-#: sysdeps/generic/siglist.h:36
+#: sysdeps/generic/siglist.h:37
 msgid "Bus error"
 msgstr "Bussfel"
 
-#: sysdeps/generic/siglist.h:37
+#: sysdeps/generic/siglist.h:38
+msgid "Bad system call"
+msgstr "Felaktigt systemanrop"
+
+#: sysdeps/generic/siglist.h:39
 msgid "Segmentation fault"
 msgstr "Segmenteringsfel"
 
-#. TRANS Broken pipe; there is no process reading from the other end of a pipe.
+#. TRANS There is no process reading from the other end of a pipe.
 #. TRANS Every library function that returns this error code also generates a
 #. TRANS @code{SIGPIPE} signal; this signal terminates the program if not handled
 #. TRANS or blocked.  Thus, your program will never actually see @code{EPIPE}
 #. TRANS unless it has handled or blocked @code{SIGPIPE}.
-#: sysdeps/generic/siglist.h:38 sysdeps/gnu/errlist.c:360
+#: sysdeps/generic/siglist.h:40 sysdeps/gnu/errlist.c:360
 msgid "Broken pipe"
 msgstr "Brutet rör"
 
-#: sysdeps/generic/siglist.h:39
+#: sysdeps/generic/siglist.h:41
 msgid "Alarm clock"
 msgstr "Alarmklocka"
 
-#: sysdeps/generic/siglist.h:40
+#: sysdeps/generic/siglist.h:42
 msgid "Terminated"
 msgstr "Avslutad"
 
-#: sysdeps/generic/siglist.h:41
+#: sysdeps/generic/siglist.h:43
 msgid "Urgent I/O condition"
 msgstr "Akut I/O-tillstånd"
 
-#: sysdeps/generic/siglist.h:42
+#: sysdeps/generic/siglist.h:44
 msgid "Stopped (signal)"
 msgstr "Stoppad (signal)"
 
-#: sysdeps/generic/siglist.h:43
+#: sysdeps/generic/siglist.h:45
 msgid "Stopped"
 msgstr "Stoppad"
 
-#: sysdeps/generic/siglist.h:44
+#: sysdeps/generic/siglist.h:46
 msgid "Continued"
 msgstr "Återupptagen"
 
-#: sysdeps/generic/siglist.h:45
+#: sysdeps/generic/siglist.h:47
 msgid "Child exited"
 msgstr "Barnprocess avslutad"
 
-#: sysdeps/generic/siglist.h:46
+#: sysdeps/generic/siglist.h:48
 msgid "Stopped (tty input)"
 msgstr "Stoppad (terminalläsning)"
 
-#: sysdeps/generic/siglist.h:47
+#: sysdeps/generic/siglist.h:49
 msgid "Stopped (tty output)"
 msgstr "Stoppad (terminalskrivning)"
 
-#: sysdeps/generic/siglist.h:48
+#: sysdeps/generic/siglist.h:50
 msgid "I/O possible"
 msgstr "I/O möjligt"
 
-#: sysdeps/generic/siglist.h:49
+#: sysdeps/generic/siglist.h:51
 msgid "CPU time limit exceeded"
 msgstr "Begränsning av CPU-tid överskriden"
 
-#: sysdeps/generic/siglist.h:50
+#: sysdeps/generic/siglist.h:52
 msgid "File size limit exceeded"
 msgstr "Begränsning av filstorlek överskriden"
 
-#: sysdeps/generic/siglist.h:51
+#: sysdeps/generic/siglist.h:53
 msgid "Virtual timer expired"
 msgstr "Alarmklocka - virtuell tid"
 
-#: sysdeps/generic/siglist.h:52
+#: sysdeps/generic/siglist.h:54
 msgid "Profiling timer expired"
 msgstr "Profileringsklocka"
 
-#: sysdeps/generic/siglist.h:53
+#: sysdeps/generic/siglist.h:55
 msgid "User defined signal 1"
 msgstr "Användarsignal 1"
 
-#: sysdeps/generic/siglist.h:54
+#: sysdeps/generic/siglist.h:56
 msgid "User defined signal 2"
 msgstr "Användarsignal 2"
 
-#: sysdeps/generic/siglist.h:58
-msgid "EMT trap"
-msgstr "Emulatorfälla"
+#: sysdeps/generic/siglist.h:57
+msgid "Window changed"
+msgstr "Ändrat fönster"
 
 #: sysdeps/generic/siglist.h:61
-msgid "Bad system call"
-msgstr "Felaktigt systemanrop"
+msgid "EMT trap"
+msgstr "Emulatorfälla"
 
 #: sysdeps/generic/siglist.h:64
 msgid "Stack fault"
 msgstr "Stackfel"
 
 #: sysdeps/generic/siglist.h:67
-msgid "Information request"
-msgstr "Informationsbegäran"
-
-#: sysdeps/generic/siglist.h:69
 msgid "Power failure"
 msgstr "Strömavbrott"
 
-#: sysdeps/generic/siglist.h:72
+#: sysdeps/generic/siglist.h:70
+msgid "Information request"
+msgstr "Informationsbegäran"
+
+#: sysdeps/generic/siglist.h:73
 msgid "Resource lost"
 msgstr "Förlorad resurs"
 
-#: sysdeps/generic/siglist.h:75
-msgid "Window changed"
-msgstr "Ändrat fönster"
-
-#. TRANS Operation not permitted; only the owner of the file (or other resource)
+#. TRANS Only the owner of the file (or other resource)
 #. TRANS or processes with special privileges can perform the operation.
 #: sysdeps/gnu/errlist.c:26
 msgid "Operation not permitted"
@@ -5839,7 +5813,7 @@ msgstr "Operationen inte tillåten"
 msgid "No such process"
 msgstr "Processen finns inte"
 
-#. TRANS Interrupted function call; an asynchronous signal occurred and prevented
+#. TRANS An asynchronous signal occurred and prevented
 #. TRANS completion of the call.  When this happens, you should try the call
 #. TRANS again.
 #. TRANS
@@ -5850,12 +5824,12 @@ msgstr "Processen finns inte"
 msgid "Interrupted system call"
 msgstr "Avbrutet systemanrop"
 
-#. TRANS Input/output error; usually used for physical read or write errors.
+#. TRANS Usually used for physical read or write errors.
 #: sysdeps/gnu/errlist.c:70
 msgid "Input/output error"
 msgstr "In/ut-fel"
 
-#. TRANS No such device or address.  The system tried to use the device
+#. TRANS The system tried to use the device
 #. TRANS represented by a file you specified, and it couldn't find the device.
 #. TRANS This can mean that the device file was installed incorrectly, or that
 #. TRANS the physical device is missing or not correctly attached to the
@@ -5864,7 +5838,7 @@ msgstr "In/ut-fel"
 msgid "No such device or address"
 msgstr "Enheten eller adressen finns inte"
 
-#. TRANS Argument list too long; used when the arguments passed to a new program
+#. TRANS Used when the arguments passed to a new program
 #. TRANS being executed with one of the @code{exec} functions (@pxref{Executing a
 #. TRANS File}) occupy too much memory space.  This condition never arises on
 #. TRANS @gnuhurdsystems{}.
@@ -5878,21 +5852,21 @@ msgstr "Argumentlistan för lång"
 msgid "Exec format error"
 msgstr "Formatfel på körbar fil"
 
-#. TRANS Bad file descriptor; for example, I/O on a descriptor that has been
+#. TRANS For example, I/O on a descriptor that has been
 #. TRANS closed or reading from a descriptor open only for writing (or vice
 #. TRANS versa).
 #: sysdeps/gnu/errlist.c:116
 msgid "Bad file descriptor"
 msgstr "Felaktig filidentifierare"
 
-#. TRANS There are no child processes.  This error happens on operations that are
+#. TRANS This error happens on operations that are
 #. TRANS supposed to manipulate child processes, when there aren't any processes
 #. TRANS to manipulate.
 #: sysdeps/gnu/errlist.c:127
 msgid "No child processes"
 msgstr "Inga barnprocesser"
 
-#. TRANS Deadlock avoided; allocating a system resource would have resulted in a
+#. TRANS Allocating a system resource would have resulted in a
 #. TRANS deadlock situation.  The system does not guarantee that it will notice
 #. TRANS all such situations.  This error means you got lucky and the system
 #. TRANS noticed; it might just hang.  @xref{File Locks}, for an example.
@@ -5900,13 +5874,13 @@ msgstr "Inga barnprocesser"
 msgid "Resource deadlock avoided"
 msgstr "Resursdödläge undveks"
 
-#. TRANS No memory available.  The system cannot allocate more virtual memory
+#. TRANS The system cannot allocate more virtual memory
 #. TRANS because its capacity is full.
 #: sysdeps/gnu/errlist.c:149
 msgid "Cannot allocate memory"
 msgstr "Kan inte allokera minne"
 
-#. TRANS Bad address; an invalid pointer was detected.
+#. TRANS An invalid pointer was detected.
 #. TRANS On @gnuhurdsystems{}, this error never happens; you get a signal instead.
 #: sysdeps/gnu/errlist.c:168
 msgid "Bad address"
@@ -5919,14 +5893,14 @@ msgstr "Felaktig adress"
 msgid "Block device required"
 msgstr "Blockenhet krävs"
 
-#. TRANS Resource busy; a system resource that can't be shared is already in use.
+#. TRANS A system resource that can't be shared is already in use.
 #. TRANS For example, if you try to delete a file that is the root of a currently
 #. TRANS mounted filesystem, you get this error.
 #: sysdeps/gnu/errlist.c:190
 msgid "Device or resource busy"
 msgstr "Enhet eller resurs upptagen"
 
-#. TRANS File exists; an existing file was specified in a context where it only
+#. TRANS An existing file was specified in a context where it only
 #. TRANS makes sense to specify a new file.
 #: sysdeps/gnu/errlist.c:200
 msgid "File exists"
@@ -5950,13 +5924,13 @@ msgstr "Enheten finns inte"
 msgid "Not a directory"
 msgstr "Inte en katalog"
 
-#. TRANS File is a directory; you cannot open a directory for writing,
+#. TRANS You cannot open a directory for writing,
 #. TRANS or create or remove hard links to it.
 #: sysdeps/gnu/errlist.c:240
 msgid "Is a directory"
 msgstr "Är en katalog"
 
-#. TRANS Invalid argument.  This is used to indicate various kinds of problems
+#. TRANS This is used to indicate various kinds of problems
 #. TRANS with passing the wrong argument to a library function.
 #: sysdeps/gnu/errlist.c:250
 msgid "Invalid argument"
@@ -5995,12 +5969,12 @@ msgstr "Olämplig ioctl för enheten"
 msgid "Text file busy"
 msgstr "Kodfil upptagen"
 
-#. TRANS File too big; the size of a file would be larger than allowed by the system.
+#. TRANS The size of a file would be larger than allowed by the system.
 #: sysdeps/gnu/errlist.c:308
 msgid "File too large"
 msgstr "För stor fil"
 
-#. TRANS No space left on device; write operation on a file failed because the
+#. TRANS Write operation on a file failed because the
 #. TRANS disk is full.
 #: sysdeps/gnu/errlist.c:318
 msgid "No space left on device"
@@ -6016,26 +5990,26 @@ msgstr "Otillåten sökning"
 msgid "Read-only file system"
 msgstr "Skrivskyddat filsystem"
 
-#. TRANS Too many links; the link count of a single file would become too large.
+#. TRANS The link count of a single file would become too large.
 #. TRANS @code{rename} can cause this error if the file being renamed already has
 #. TRANS as many links as it can take (@pxref{Renaming Files}).
 #: sysdeps/gnu/errlist.c:347
 msgid "Too many links"
 msgstr "För många länkar"
 
-#. TRANS Domain error; used by mathematical functions when an argument value does
+#. TRANS Used by mathematical functions when an argument value does
 #. TRANS not fall into the domain over which the function is defined.
 #: sysdeps/gnu/errlist.c:370
 msgid "Numerical argument out of domain"
 msgstr "Numeriskt argument är utanför området"
 
-#. TRANS Range error; used by mathematical functions when the result value is
+#. TRANS Used by mathematical functions when the result value is
 #. TRANS not representable because of overflow or underflow.
 #: sysdeps/gnu/errlist.c:380
 msgid "Numerical result out of range"
 msgstr "Numeriskt resultat är utanför giltigt intervall"
 
-#. TRANS Resource temporarily unavailable; the call might work if you try again
+#. TRANS The call might work if you try again
 #. TRANS later.  The macro @code{EWOULDBLOCK} is another name for @code{EAGAIN};
 #. TRANS they are always the same in @theglibc{}.
 #. TRANS
@@ -6223,76 +6197,75 @@ msgstr "Destinationsadress krävs"
 msgid "Cannot send after transport endpoint shutdown"
 msgstr "Kan inte skicka efter att transportslutpunkten stängts"
 
-#. TRANS ???
-#: sysdeps/gnu/errlist.c:677
+#: sysdeps/gnu/errlist.c:676
 msgid "Too many references: cannot splice"
 msgstr "För många referenser: kan inte skarva"
 
 #. TRANS A socket operation with a specified timeout received no response during
 #. TRANS the timeout period.
-#: sysdeps/gnu/errlist.c:687
+#: sysdeps/gnu/errlist.c:686
 msgid "Connection timed out"
 msgstr "Förbindelsens tidsgräns löpte ut"
 
 #. TRANS A remote host refused to allow the network connection (typically because
 #. TRANS it is not running the requested service).
-#: sysdeps/gnu/errlist.c:697
+#: sysdeps/gnu/errlist.c:696
 msgid "Connection refused"
 msgstr "Förbindelsen förvägrad"
 
 #. TRANS Too many levels of symbolic links were encountered in looking up a file name.
 #. TRANS This often indicates a cycle of symbolic links.
-#: sysdeps/gnu/errlist.c:707
+#: sysdeps/gnu/errlist.c:706
 msgid "Too many levels of symbolic links"
 msgstr "För många nivåer av symboliska länkar"
 
 #. TRANS Filename too long (longer than @code{PATH_MAX}; @pxref{Limits for
 #. TRANS Files}) or host name too long (in @code{gethostname} or
 #. TRANS @code{sethostname}; @pxref{Host Identification}).
-#: sysdeps/gnu/errlist.c:718
+#: sysdeps/gnu/errlist.c:717
 msgid "File name too long"
 msgstr "För långt filnamn"
 
 #. TRANS The remote host for a requested network connection is down.
-#: sysdeps/gnu/errlist.c:727
+#: sysdeps/gnu/errlist.c:726
 msgid "Host is down"
 msgstr "Värddator är nere"
 
 #. TRANS The remote host for a requested network connection is not reachable.
-#: sysdeps/gnu/errlist.c:736
+#: sysdeps/gnu/errlist.c:735
 msgid "No route to host"
 msgstr "Ingen väg till värd"
 
 #. TRANS Directory not empty, where an empty directory was expected.  Typically,
 #. TRANS this error occurs when you are trying to delete a directory.
-#: sysdeps/gnu/errlist.c:746
+#: sysdeps/gnu/errlist.c:745
 msgid "Directory not empty"
 msgstr "Katalog inte tom"
 
 #. TRANS This means that the per-user limit on new process would be exceeded by
 #. TRANS an attempted @code{fork}.  @xref{Limits on Resources}, for details on
 #. TRANS the @code{RLIMIT_NPROC} limit.
-#: sysdeps/gnu/errlist.c:757
+#: sysdeps/gnu/errlist.c:756
 msgid "Too many processes"
 msgstr "För många processer"
 
 #. TRANS The file quota system is confused because there are too many users.
 #. TRANS @c This can probably happen in a GNU system when using NFS.
-#: sysdeps/gnu/errlist.c:767
+#: sysdeps/gnu/errlist.c:766
 msgid "Too many users"
 msgstr "För många användare"
 
 #. TRANS The user's disk quota was exceeded.
-#: sysdeps/gnu/errlist.c:776
+#: sysdeps/gnu/errlist.c:775
 msgid "Disk quota exceeded"
 msgstr "Diskkvot överskriden"
 
-#. TRANS Stale file handle.  This indicates an internal confusion in the
+#. TRANS This indicates an internal confusion in the
 #. TRANS file system which is due to file system rearrangements on the server host
 #. TRANS for NFS file systems or corruption in other file systems.
 #. TRANS Repairing this condition usually requires unmounting, possibly repairing
 #. TRANS and remounting the file system.
-#: sysdeps/gnu/errlist.c:789
+#: sysdeps/gnu/errlist.c:788
 msgid "Stale file handle"
 msgstr "Förlegat filhandtag"
 
@@ -6300,72 +6273,65 @@ msgstr "Förlegat filhandtag"
 #. TRANS already specifies an NFS-mounted file.
 #. TRANS (This is an error on some operating systems, but we expect it to work
 #. TRANS properly on @gnuhurdsystems{}, making this error code impossible.)
-#: sysdeps/gnu/errlist.c:801
+#: sysdeps/gnu/errlist.c:800
 msgid "Object is remote"
 msgstr "Är ett fjärrobjekt"
 
-#. TRANS ???
-#: sysdeps/gnu/errlist.c:810
+#: sysdeps/gnu/errlist.c:808
 msgid "RPC struct is bad"
 msgstr "RPC-strukturen är felaktig"
 
-#. TRANS ???
-#: sysdeps/gnu/errlist.c:819
+#: sysdeps/gnu/errlist.c:816
 msgid "RPC version wrong"
 msgstr "RPC-versionen är felaktig"
 
-#. TRANS ???
-#: sysdeps/gnu/errlist.c:828
+#: sysdeps/gnu/errlist.c:824
 msgid "RPC program not available"
 msgstr "RPC-programmet inte tillgängligt"
 
-#. TRANS ???
-#: sysdeps/gnu/errlist.c:837
+#: sysdeps/gnu/errlist.c:832
 msgid "RPC program version wrong"
 msgstr "RPC-programversionen är felaktig"
 
-#. TRANS ???
-#: sysdeps/gnu/errlist.c:846
+#: sysdeps/gnu/errlist.c:840
 msgid "RPC bad procedure for program"
 msgstr "Felaktig RPC-procedur för programmet"
 
-#. TRANS No locks available.  This is used by the file locking facilities; see
+#. TRANS This is used by the file locking facilities; see
 #. TRANS @ref{File Locks}.  This error is never generated by @gnuhurdsystems{}, but
 #. TRANS it can result from an operation to an NFS server running another
 #. TRANS operating system.
-#: sysdeps/gnu/errlist.c:858
+#: sysdeps/gnu/errlist.c:852
 msgid "No locks available"
 msgstr "Inga lås tillgängliga"
 
-#. TRANS Inappropriate file type or format.  The file was the wrong type for the
+#. TRANS The file was the wrong type for the
 #. TRANS operation, or a data file had the wrong format.
 #. TRANS
 #. TRANS On some systems @code{chmod} returns this error if you try to set the
 #. TRANS sticky bit on a non-directory file; @pxref{Setting Permissions}.
-#: sysdeps/gnu/errlist.c:871
+#: sysdeps/gnu/errlist.c:865
 msgid "Inappropriate file type or format"
 msgstr "Filtyp eller format olämplig"
 
-#. TRANS ???
-#: sysdeps/gnu/errlist.c:880
+#: sysdeps/gnu/errlist.c:873
 msgid "Authentication error"
 msgstr "Autentiseringsfel"
 
-#. TRANS ???
-#: sysdeps/gnu/errlist.c:889
+#: sysdeps/gnu/errlist.c:881
 msgid "Need authenticator"
 msgstr "Behöver autentiserare"
 
-#. TRANS Function not implemented.  This indicates that the function called is
+#. TRANS This indicates that the function called is
 #. TRANS not implemented at all, either in the C library itself or in the
 #. TRANS operating system.  When you get this error, you can be sure that this
 #. TRANS particular function will always fail with @code{ENOSYS} unless you
 #. TRANS install a new version of the C library or the operating system.
-#: sysdeps/gnu/errlist.c:902
+#: sysdeps/gnu/errlist.c:894
 msgid "Function not implemented"
 msgstr "Funktion inte implementerad"
 
-#. TRANS Not supported.  A function returns this error when certain parameter
+#. TRANS A function returns this error when certain parameter
 #. TRANS values are valid, but the functionality they request is not available.
 #. TRANS This can mean that the function does not implement a particular command
 #. TRANS or option value or flag bit at all.  For functions that operate on some
@@ -6377,13 +6343,13 @@ msgstr "Funktion inte implementerad"
 #. TRANS
 #. TRANS If the entire function is not available at all in the implementation,
 #. TRANS it returns @code{ENOSYS} instead.
-#: sysdeps/gnu/errlist.c:922
+#: sysdeps/gnu/errlist.c:914
 msgid "Not supported"
 msgstr "Stöds ej"
 
 #. TRANS While decoding a multibyte character the function came along an invalid
 #. TRANS or an incomplete sequence of bytes or the given wide character is invalid.
-#: sysdeps/gnu/errlist.c:932
+#: sysdeps/gnu/errlist.c:924
 msgid "Invalid or incomplete multibyte or wide character"
 msgstr "Ogiltigt eller ofullständigt flerbyte- eller brett tecken"
 
@@ -6393,276 +6359,276 @@ msgstr "Ogiltigt eller ofullständigt flerbyte- eller brett tecken"
 #. TRANS error because functions such as @code{read} and @code{write} translate
 #. TRANS it into a @code{SIGTTIN} or @code{SIGTTOU} signal.  @xref{Job Control},
 #. TRANS for information on process groups and these signals.
-#: sysdeps/gnu/errlist.c:946
+#: sysdeps/gnu/errlist.c:938
 msgid "Inappropriate operation for background process"
 msgstr "Operation för bakgrundsprocess olämplig"
 
 #. TRANS On @gnuhurdsystems{}, opening a file returns this error when the file is
 #. TRANS translated by a program and the translator program dies while starting
 #. TRANS up, before it has connected to the file.
-#: sysdeps/gnu/errlist.c:957
+#: sysdeps/gnu/errlist.c:949
 msgid "Translator died"
 msgstr "Översättaren dog"
 
 #. TRANS The experienced user will know what is wrong.
 #. TRANS @c This error code is a joke.  Its perror text is part of the joke.
 #. TRANS @c Don't change it.
-#: sysdeps/gnu/errlist.c:968
+#: sysdeps/gnu/errlist.c:960
 msgid "?"
 msgstr "?"
 
 #. TRANS You did @strong{what}?
-#: sysdeps/gnu/errlist.c:977
+#: sysdeps/gnu/errlist.c:969
 msgid "You really blew it this time"
 msgstr "Du strulade till det den här gången"
 
 #. TRANS Go home and have a glass of warm, dairy-fresh milk.
-#: sysdeps/gnu/errlist.c:986
+#: sysdeps/gnu/errlist.c:978
 msgid "Computer bought the farm"
 msgstr "Datorn packade ihop"
 
 #. TRANS This error code has no purpose.
-#: sysdeps/gnu/errlist.c:995
+#: sysdeps/gnu/errlist.c:987
 msgid "Gratuitous error"
 msgstr "Omotiverat fel"
 
-#: sysdeps/gnu/errlist.c:1003
+#: sysdeps/gnu/errlist.c:995
 msgid "Bad message"
 msgstr "Felaktigt meddelande"
 
-#: sysdeps/gnu/errlist.c:1011
+#: sysdeps/gnu/errlist.c:1003
 msgid "Identifier removed"
 msgstr "Identifierare borttagen"
 
-#: sysdeps/gnu/errlist.c:1019
+#: sysdeps/gnu/errlist.c:1011
 msgid "Multihop attempted"
 msgstr "Flerhopp försöktes"
 
-#: sysdeps/gnu/errlist.c:1027
+#: sysdeps/gnu/errlist.c:1019
 msgid "No data available"
 msgstr "Inga data tillgängliga"
 
-#: sysdeps/gnu/errlist.c:1035
+#: sysdeps/gnu/errlist.c:1027
 msgid "Link has been severed"
 msgstr "Länken har brutits"
 
-#: sysdeps/gnu/errlist.c:1043
+#: sysdeps/gnu/errlist.c:1035
 msgid "No message of desired type"
 msgstr "Inget meddelande av önskad typ"
 
-#: sysdeps/gnu/errlist.c:1051
+#: sysdeps/gnu/errlist.c:1043
 msgid "Out of streams resources"
 msgstr "Stream-resurserna är slut"
 
-#: sysdeps/gnu/errlist.c:1059
+#: sysdeps/gnu/errlist.c:1051
 msgid "Device not a stream"
 msgstr "Enheten är inte en stream"
 
-#: sysdeps/gnu/errlist.c:1067
+#: sysdeps/gnu/errlist.c:1059
 msgid "Value too large for defined data type"
 msgstr "Värdet för stort för definierad datatyp"
 
-#: sysdeps/gnu/errlist.c:1075
+#: sysdeps/gnu/errlist.c:1067
 msgid "Protocol error"
 msgstr "Protokollfel"
 
-#: sysdeps/gnu/errlist.c:1083
+#: sysdeps/gnu/errlist.c:1075
 msgid "Timer expired"
 msgstr "Klockan ringde"
 
-#. TRANS Operation canceled; an asynchronous operation was canceled before it
+#. TRANS An asynchronous operation was canceled before it
 #. TRANS completed.  @xref{Asynchronous I/O}.  When you call @code{aio_cancel},
 #. TRANS the normal result is for the operations affected to complete with this
 #. TRANS error; @pxref{Cancel AIO Operations}.
-#: sysdeps/gnu/errlist.c:1095
+#: sysdeps/gnu/errlist.c:1087
 msgid "Operation canceled"
 msgstr "Operationen avbruten"
 
-#: sysdeps/gnu/errlist.c:1103
+#: sysdeps/gnu/errlist.c:1095
 msgid "Interrupted system call should be restarted"
 msgstr "Avbrutet systemanrop borde omstartas"
 
-#: sysdeps/gnu/errlist.c:1111
+#: sysdeps/gnu/errlist.c:1103
 msgid "Channel number out of range"
 msgstr "Kanalnummer utanför giltigt intervall"
 
-#: sysdeps/gnu/errlist.c:1119
+#: sysdeps/gnu/errlist.c:1111
 msgid "Level 2 not synchronized"
 msgstr "Nivå 2 inte synkroniserad"
 
-#: sysdeps/gnu/errlist.c:1127
+#: sysdeps/gnu/errlist.c:1119
 msgid "Level 3 halted"
 msgstr "Nivå 3 stannad"
 
-#: sysdeps/gnu/errlist.c:1135
+#: sysdeps/gnu/errlist.c:1127
 msgid "Level 3 reset"
 msgstr "Nivå 3 omstartad"
 
-#: sysdeps/gnu/errlist.c:1143
+#: sysdeps/gnu/errlist.c:1135
 msgid "Link number out of range"
 msgstr "Länkantal utanför giltigt intervall"
 
-#: sysdeps/gnu/errlist.c:1151
+#: sysdeps/gnu/errlist.c:1143
 msgid "Protocol driver not attached"
 msgstr "Styrprogram för protokoll inte anslutet"
 
-#: sysdeps/gnu/errlist.c:1159
+#: sysdeps/gnu/errlist.c:1151
 msgid "No CSI structure available"
 msgstr "Inga CSI-strukturer tillgängliga"
 
-#: sysdeps/gnu/errlist.c:1167
+#: sysdeps/gnu/errlist.c:1159
 msgid "Level 2 halted"
 msgstr "Nivå 2 stannad"
 
-#: sysdeps/gnu/errlist.c:1175
+#: sysdeps/gnu/errlist.c:1167
 msgid "Invalid exchange"
 msgstr "Ogiltig växel"
 
-#: sysdeps/gnu/errlist.c:1183
+#: sysdeps/gnu/errlist.c:1175
 msgid "Invalid request descriptor"
-msgstr "Ogiltig begärandeidendiferare"
+msgstr "Ogiltig begärandeidentifierare"
 
-#: sysdeps/gnu/errlist.c:1191
+#: sysdeps/gnu/errlist.c:1183
 msgid "Exchange full"
 msgstr "Växeln full"
 
-#: sysdeps/gnu/errlist.c:1199
+#: sysdeps/gnu/errlist.c:1191
 msgid "No anode"
 msgstr "Ingen anod"
 
-#: sysdeps/gnu/errlist.c:1207
+#: sysdeps/gnu/errlist.c:1199
 msgid "Invalid request code"
 msgstr "Ogiltig begärandekod"
 
-#: sysdeps/gnu/errlist.c:1215
+#: sysdeps/gnu/errlist.c:1207
 msgid "Invalid slot"
 msgstr "Ogiltig plats"
 
-#: sysdeps/gnu/errlist.c:1223
+#: sysdeps/gnu/errlist.c:1215
 msgid "File locking deadlock error"
 msgstr "Fillåsning gav dödläge"
 
-#: sysdeps/gnu/errlist.c:1231
+#: sysdeps/gnu/errlist.c:1223
 msgid "Bad font file format"
 msgstr "Felaktigt format på typsnittsfil"
 
-#: sysdeps/gnu/errlist.c:1239
+#: sysdeps/gnu/errlist.c:1231
 msgid "Machine is not on the network"
 msgstr "Maskinen finns inte på nätverket"
 
-#: sysdeps/gnu/errlist.c:1247
+#: sysdeps/gnu/errlist.c:1239
 msgid "Package not installed"
 msgstr "Paketet är inte installerat"
 
-#: sysdeps/gnu/errlist.c:1255
+#: sysdeps/gnu/errlist.c:1247
 msgid "Advertise error"
 msgstr "Annonseringsfel"
 
-#: sysdeps/gnu/errlist.c:1263
+#: sysdeps/gnu/errlist.c:1255
 msgid "Srmount error"
 msgstr "Srmount-fel"
 
-#: sysdeps/gnu/errlist.c:1271
+#: sysdeps/gnu/errlist.c:1263
 msgid "Communication error on send"
 msgstr "Kommunikationsfel vid sändning"
 
-#: sysdeps/gnu/errlist.c:1279
+#: sysdeps/gnu/errlist.c:1271
 msgid "RFS specific error"
 msgstr "RFS-specifikt fel"
 
-#: sysdeps/gnu/errlist.c:1287
+#: sysdeps/gnu/errlist.c:1279
 msgid "Name not unique on network"
 msgstr "Namnet inte unikt i nätverket"
 
-#: sysdeps/gnu/errlist.c:1295
+#: sysdeps/gnu/errlist.c:1287
 msgid "File descriptor in bad state"
 msgstr "Filidentifierare i felaktigt tillstånd"
 
-#: sysdeps/gnu/errlist.c:1303
+#: sysdeps/gnu/errlist.c:1295
 msgid "Remote address changed"
 msgstr "Fjärradress ändrades"
 
-#: sysdeps/gnu/errlist.c:1311
+#: sysdeps/gnu/errlist.c:1303
 msgid "Can not access a needed shared library"
 msgstr "Kan inte komma åt ett nödvändigt delat bibliotek"
 
-#: sysdeps/gnu/errlist.c:1319
+#: sysdeps/gnu/errlist.c:1311
 msgid "Accessing a corrupted shared library"
 msgstr "Öppnar ett korrupt delat bibliotek"
 
-#: sysdeps/gnu/errlist.c:1327
+#: sysdeps/gnu/errlist.c:1319
 msgid ".lib section in a.out corrupted"
 msgstr ".lib-sektion i a.out korrupt"
 
-#: sysdeps/gnu/errlist.c:1335
+#: sysdeps/gnu/errlist.c:1327
 msgid "Attempting to link in too many shared libraries"
 msgstr "Försöker att länka in för många delade bibliotek"
 
-#: sysdeps/gnu/errlist.c:1343
+#: sysdeps/gnu/errlist.c:1335
 msgid "Cannot exec a shared library directly"
 msgstr "Kan inte köra ett delat bibliotek direkt"
 
-#: sysdeps/gnu/errlist.c:1351
+#: sysdeps/gnu/errlist.c:1343
 msgid "Streams pipe error"
 msgstr "Streams-rörfel"
 
-#: sysdeps/gnu/errlist.c:1359
+#: sysdeps/gnu/errlist.c:1351
 msgid "Structure needs cleaning"
 msgstr "Strukturen behöver städas"
 
-#: sysdeps/gnu/errlist.c:1367
+#: sysdeps/gnu/errlist.c:1359
 msgid "Not a XENIX named type file"
 msgstr "Inte en XENIX-namngiven fil"
 
-#: sysdeps/gnu/errlist.c:1375
+#: sysdeps/gnu/errlist.c:1367
 msgid "No XENIX semaphores available"
 msgstr "Inga XENIX-semaforer tillgängliga"
 
-#: sysdeps/gnu/errlist.c:1383
+#: sysdeps/gnu/errlist.c:1375
 msgid "Is a named type file"
 msgstr "Är av typ namnfil"
 
-#: sysdeps/gnu/errlist.c:1391
+#: sysdeps/gnu/errlist.c:1383
 msgid "Remote I/O error"
 msgstr "I/O-fel på fjärrmaskin"
 
-#: sysdeps/gnu/errlist.c:1399
+#: sysdeps/gnu/errlist.c:1391
 msgid "No medium found"
 msgstr "Inget medium funnet"
 
-#: sysdeps/gnu/errlist.c:1407
+#: sysdeps/gnu/errlist.c:1399
 msgid "Wrong medium type"
 msgstr "Fel medietyp"
 
-#: sysdeps/gnu/errlist.c:1415
+#: sysdeps/gnu/errlist.c:1407
 msgid "Required key not available"
 msgstr "Obligatorisk nyckel inte tillgänglig"
 
-#: sysdeps/gnu/errlist.c:1423
+#: sysdeps/gnu/errlist.c:1415
 msgid "Key has expired"
 msgstr "Nyckeln har gått ut"
 
-#: sysdeps/gnu/errlist.c:1431
+#: sysdeps/gnu/errlist.c:1423
 msgid "Key has been revoked"
 msgstr "Nyckeln har återkallats"
 
-#: sysdeps/gnu/errlist.c:1439
+#: sysdeps/gnu/errlist.c:1431
 msgid "Key was rejected by service"
 msgstr "Nyckeln accepterades inte av tjänsten"
 
-#: sysdeps/gnu/errlist.c:1447
+#: sysdeps/gnu/errlist.c:1439
 msgid "Owner died"
 msgstr "Ägaren dog"
 
-#: sysdeps/gnu/errlist.c:1455
+#: sysdeps/gnu/errlist.c:1447
 msgid "State not recoverable"
 msgstr "Det går inte att återhämta från tillståndet"
 
-#: sysdeps/gnu/errlist.c:1463
+#: sysdeps/gnu/errlist.c:1455
 msgid "Operation not possible due to RF-kill"
 msgstr "Operationen inte möjlig p.g.a. RF-kill"
 
-#: sysdeps/gnu/errlist.c:1471
+#: sysdeps/gnu/errlist.c:1463
 msgid "Memory page has hardware error"
 msgstr "Minnessida har hårdvarufel"
 
@@ -6767,73 +6733,90 @@ msgstr "kan inte öppna \"%s\""
 msgid "cannot read header from `%s'"
 msgstr "kan inte läsa huvud från \"%s\""
 
-#: timezone/zdump.c:494
+#: timezone/zdump.c:338
 msgid "has fewer than 3 characters"
 msgstr "har färre än 3 tecken"
 
-#: timezone/zdump.c:496
+#: timezone/zdump.c:340
 msgid "has more than 6 characters"
 msgstr "har fler än 6 tecken"
 
-#: timezone/zdump.c:498
+#: timezone/zdump.c:342
 msgid "has characters other than ASCII alphanumerics, '-' or '+'"
 msgstr "har andra tecken än ASCII alfanumeriska, ”-” eller ”+”"
 
-#: timezone/zdump.c:503
+#: timezone/zdump.c:347
 #, c-format
 msgid "%s: warning: zone \"%s\" abbreviation \"%s\" %s\n"
 msgstr "%s: varning: zon \"%s\" förkortning \"%s\": %s\n"
 
-#: timezone/zdump.c:553
+#: timezone/zdump.c:393
 #, c-format
 msgid ""
-"%s: usage: %s [--version] [--help] [-{vV}] [-{ct} [lo,]hi] zonename ...\n"
+"%s: usage: %s OPTIONS ZONENAME ...\n"
+"Options include:\n"
+"  -c [L,]U   Start at year L (default -500), end before year U (default 2500)\n"
+"  -t [L,]U   Start at time L, end before time U (in seconds since 1970)\n"
+"  -i         List transitions briefly (format is experimental)\n"
+"  -v         List transitions verbosely\n"
+"  -V         List transitions a bit less verbosely\n"
+"  --help     Output this help\n"
+"  --version  Output version info\n"
 "\n"
 "Report bugs to %s.\n"
 msgstr ""
-"%s: användning: %s [ --version ] [ --help ] [ -{vV} ] [ -{ct} [start,]slut] zonnamn ...\n"
+"%s: användning: %s FLAGGOR ZONNAMN …\n"
+"Flaggorna inkluderar:\n"
+"  -c [L,]Ö   Starta vid år L (standard -500), och sluta före år Ö (standard 2500)\n"
+"  -t [L,]Ö   Starta vid tid L, och sluta före tid Ö (i sekunder sedan 1970)\n"
+"  -i         Lista övergångar kort (formatet är experimentellt)\n"
+"  -v         Lista övergångar utförligt\n"
+"  -V         Lista övergångar lite mindre utförligt\n"
+"  --help     Skriv ut denna hjälp\n"
+"  --version  Skriv ut versionsinformation\n"
+"\n"
 "Rapportera fel till %s.\n"
 "Rapportera fel eller synpunkter på översättningen till <tp-sv@listor.tp-sv.se>.\n"
 
-#: timezone/zdump.c:635
+#: timezone/zdump.c:479
 #, c-format
 msgid "%s: wild -c argument %s\n"
 msgstr "%s: argument \"%s\" till flaggan -c har fel format\n"
 
-#: timezone/zdump.c:668
+#: timezone/zdump.c:512
 #, c-format
 msgid "%s: wild -t argument %s\n"
 msgstr "%s: argument \"%s\" till flaggan -t har fel format\n"
 
-#: timezone/zic.c:361
+#: timezone/zic.c:398
 #, c-format
 msgid "%s: Memory exhausted: %s\n"
 msgstr "%s: Minnet slut: %s\n"
 
-#: timezone/zic.c:369
+#: timezone/zic.c:406
 msgid "size overflow"
 msgstr "för stor storlek"
 
-#: timezone/zic.c:416
-msgid "int overflow"
-msgstr "för stort heltal"
+#: timezone/zic.c:454
+msgid "integer overflow"
+msgstr "heltalsspill"
 
-#: timezone/zic.c:451
+#: timezone/zic.c:488
 #, c-format
-msgid "\"%s\", line %d: "
-msgstr "\"%s\", rad %d: "
+msgid "\"%s\", line %<PRIdMAX>: "
+msgstr "”%s”, rad %<PRIdMAX>: "
 
-#: timezone/zic.c:454
+#: timezone/zic.c:491
 #, c-format
-msgid " (rule from \"%s\", line %d)"
-msgstr " (regel från \"%s\", rad %d)"
+msgid " (rule from \"%s\", line %<PRIdMAX>)"
+msgstr " (regel från ”%s”, rad %<PRIdMAX>)"
 
-#: timezone/zic.c:473
+#: timezone/zic.c:510
 #, c-format
 msgid "warning: "
 msgstr "varning: "
 
-#: timezone/zic.c:498
+#: timezone/zic.c:535
 #, c-format
 msgid ""
 "%s: usage is %s [ --version ] [ --help ] [ -v ] \\\n"
@@ -6849,361 +6832,382 @@ msgstr ""
 "Rapportera fel till %s.\n"
 "Rapportera fel eller synpunkter på översättningen till <tp-sv@listor.tp-sv.se>.\n"
 
-#: timezone/zic.c:534
+#: timezone/zic.c:558
+#, c-format
+msgid "%s: Can't chdir to %s: %s\n"
+msgstr "%s: Kan inte byta katalog till %s: %s\n"
+
+#: timezone/zic.c:590
 msgid "wild compilation-time specification of zic_t"
 msgstr "definitionen av zic_t vid kompilering är orimlig"
 
-#: timezone/zic.c:554
+#: timezone/zic.c:610
 #, c-format
 msgid "%s: More than one -d option specified\n"
 msgstr "%s: Flaggan -d given mer än en gång\n"
 
-#: timezone/zic.c:564
+#: timezone/zic.c:620
 #, c-format
 msgid "%s: More than one -l option specified\n"
 msgstr "%s: Flaggan -l given mer än en gång\n"
 
-#: timezone/zic.c:574
+#: timezone/zic.c:630
 #, c-format
 msgid "%s: More than one -p option specified\n"
 msgstr "%s: Flaggan -p given mer än en gång\n"
 
-#: timezone/zic.c:584
+#: timezone/zic.c:640
 #, c-format
 msgid "%s: More than one -y option specified\n"
 msgstr "%s: Flaggan -y given mer än en gång\n"
 
-#: timezone/zic.c:594
+#: timezone/zic.c:650
 #, c-format
 msgid "%s: More than one -L option specified\n"
 msgstr "%s: Flaggan -L given mer än en gång\n"
 
-#: timezone/zic.c:603
+#: timezone/zic.c:659
 msgid "-s ignored"
 msgstr "-s ignoreras"
 
-#: timezone/zic.c:641
+#: timezone/zic.c:698
 msgid "link to link"
 msgstr "länk till länk"
 
-#: timezone/zic.c:644 timezone/zic.c:648
+#: timezone/zic.c:701 timezone/zic.c:705
 msgid "command line"
 msgstr "kommandorad"
 
-#: timezone/zic.c:664
+#: timezone/zic.c:721
 msgid "empty file name"
 msgstr "tomt filnamn"
 
-#: timezone/zic.c:667
+#: timezone/zic.c:724
 #, c-format
 msgid "file name '%s' begins with '/'"
 msgstr "filnamnet ”%s” börjar med ”/”"
 
-#: timezone/zic.c:676
+#: timezone/zic.c:734
 #, c-format
 msgid "file name '%s' contains '%.*s' component"
 msgstr "filnamnet ”%s” innehåller en komponent ”%.*s”"
 
-#: timezone/zic.c:682
+#: timezone/zic.c:740
 #, c-format
 msgid "file name '%s' component contains leading '-'"
 msgstr "en komponent i filnamnet ”%s” innehåller en inledande ”-”"
 
-#: timezone/zic.c:685
+#: timezone/zic.c:743
 #, c-format
 msgid "file name '%s' contains overlength component '%.*s...'"
 msgstr "filnamnet ”%s” innehåller en för lång komponent ”%.*s…”"
 
-#: timezone/zic.c:713
+#: timezone/zic.c:771
 #, c-format
 msgid "file name '%s' contains byte '%c'"
 msgstr "filnamnet ”%s” innehåller en byte ”%c”"
 
-#: timezone/zic.c:714
+#: timezone/zic.c:772
 #, c-format
 msgid "file name '%s' contains byte '\\%o'"
 msgstr "filnamnet ”%s” innehåller en byte ”\\%o”"
 
-#: timezone/zic.c:757
+#: timezone/zic.c:842
+#, c-format
+msgid "%s: link from %s/%s failed: %s\n"
+msgstr "%s: länk från %s/%s misslyckades: %s\n"
+
+#: timezone/zic.c:852 timezone/zic.c:1815
+#, c-format
+msgid "%s: Can't remove %s/%s: %s\n"
+msgstr "%s: Kan inte ta bort %s/%s: %s\n"
+
+#: timezone/zic.c:874
 #, c-format
-msgid "%s: link from %s failed: %s"
-msgstr "%s: länk från %s misslyckades: %s"
+msgid "symbolic link used because hard link failed: %s"
+msgstr "symbolisk länk använd eftersom en hård länk misslyckades: %s"
 
-#: timezone/zic.c:792
-msgid "hard link failed, symbolic link used"
-msgstr "hård länk misslyckades, använder symbolisk länk"
+#: timezone/zic.c:882
+#, c-format
+msgid "%s: Can't read %s/%s: %s\n"
+msgstr "%s: Kan inte läsa %s/%s: %s\n"
 
-#: timezone/zic.c:802
+#: timezone/zic.c:889 timezone/zic.c:1828
 #, c-format
-msgid "%s: Can't read %s: %s\n"
-msgstr "%s: Kan inte läsa %s: %s\n"
+msgid "%s: Can't create %s/%s: %s\n"
+msgstr "%s: Kan inte skapa %s/%s: %s\n"
 
-#: timezone/zic.c:810 timezone/zic.c:1701
+#: timezone/zic.c:898
 #, c-format
-msgid "%s: Can't create %s: %s\n"
-msgstr "%s: Kan inte skapa %s: %s\n"
+msgid "copy used because hard link failed: %s"
+msgstr "kopiering använd eftersom en hård länk misslyckades: %s"
 
-#: timezone/zic.c:818
-msgid "link failed, copy used"
-msgstr "länka misslyckades, kopia skapad"
+#: timezone/zic.c:901
+#, c-format
+msgid "copy used because symbolic link failed: %s"
+msgstr "kopiering använd eftersom en symbolisk länk misslyckades: %s"
 
-#: timezone/zic.c:913 timezone/zic.c:915
+#: timezone/zic.c:1013 timezone/zic.c:1015
 msgid "same rule name in multiple files"
 msgstr "samma regelnamn i flera filer"
 
-#: timezone/zic.c:956
+#: timezone/zic.c:1056
 msgid "unruly zone"
 msgstr "besvärlig zon"
 
-#: timezone/zic.c:963
+#: timezone/zic.c:1063
 #, c-format
 msgid "%s in ruleless zone"
 msgstr "%s i zon utan regler"
 
-#: timezone/zic.c:983
+#: timezone/zic.c:1083
 msgid "standard input"
 msgstr "standard in"
 
-#: timezone/zic.c:988
+#: timezone/zic.c:1088
 #, c-format
 msgid "%s: Can't open %s: %s\n"
 msgstr "%s: Kan inte öppna %s: %s\n"
 
-#: timezone/zic.c:999
+#: timezone/zic.c:1099
 msgid "line too long"
 msgstr "för lång rad"
 
-#: timezone/zic.c:1019
+#: timezone/zic.c:1119
 msgid "input line of unknown type"
 msgstr "inrad av okänd typ"
 
-#: timezone/zic.c:1034
+#: timezone/zic.c:1134
 #, c-format
 msgid "%s: Leap line in non leap seconds file %s"
 msgstr "%s: \"Leap\"-rad i fil %s som inte är skottsekundsfil"
 
-#: timezone/zic.c:1042 timezone/zic.c:1447 timezone/zic.c:1469
+#: timezone/zic.c:1142 timezone/zic.c:1547 timezone/zic.c:1569
 #, c-format
 msgid "%s: panic: Invalid l_value %d\n"
 msgstr "%s: panik: Ogiltigt l_value %d\n"
 
-#: timezone/zic.c:1051
+#: timezone/zic.c:1151
 msgid "expected continuation line not found"
 msgstr "förväntad fortsättningsrad inte funnen"
 
-#: timezone/zic.c:1093 timezone/zic.c:2826
+#: timezone/zic.c:1193 timezone/zic.c:2976
 msgid "time overflow"
 msgstr "för stort tidsvärde"
 
-#: timezone/zic.c:1098
+#: timezone/zic.c:1198
 msgid "values over 24 hours not handled by pre-2007 versions of zic"
 msgstr "värden större än 24 timmar hanteras inte av zic-versioner före 2007"
 
-#: timezone/zic.c:1109
+#: timezone/zic.c:1209
 msgid "wrong number of fields on Rule line"
 msgstr "fel antal fält på \"Rule\"-rad"
 
-#: timezone/zic.c:1113
+#: timezone/zic.c:1213
 msgid "nameless rule"
 msgstr "namnlös regel"
 
-#: timezone/zic.c:1118
+#: timezone/zic.c:1218
 msgid "invalid saved time"
 msgstr "ogiltig sparad tid"
 
-#: timezone/zic.c:1135
+#: timezone/zic.c:1235
 msgid "wrong number of fields on Zone line"
 msgstr "fel antal fält på \"Zone\"-rad"
 
-#: timezone/zic.c:1140
+#: timezone/zic.c:1240
 #, c-format
 msgid "\"Zone %s\" line and -l option are mutually exclusive"
 msgstr "\"Zone %s\"-rad och flaggan -l är ömsesidigt uteslutande"
 
-#: timezone/zic.c:1146
+#: timezone/zic.c:1246
 #, c-format
 msgid "\"Zone %s\" line and -p option are mutually exclusive"
 msgstr "\"Zone %s\"-rad och flaggan -p är ömsesidigt uteslutande"
 
-#: timezone/zic.c:1154
+#: timezone/zic.c:1253
 #, c-format
-msgid "duplicate zone name %s (file \"%s\", line %d)"
-msgstr "dubblerat zonnamn %s (fil \"%s\", rad %d)"
+msgid "duplicate zone name %s (file \"%s\", line %<PRIdMAX>)"
+msgstr "dubblerat zonnamn %s (filen ”%s”, rad %<PRIdMAX>)"
 
-#: timezone/zic.c:1167
+#: timezone/zic.c:1267
 msgid "wrong number of fields on Zone continuation line"
 msgstr "fel antal fält på \"Zone\"-fortsättningsrad"
 
-#: timezone/zic.c:1207
+#: timezone/zic.c:1307
 msgid "invalid UT offset"
 msgstr "ogiltigt UT-tillägg"
 
-#: timezone/zic.c:1211
+#: timezone/zic.c:1311
 msgid "invalid abbreviation format"
 msgstr "ogiltigt förkortningsformat"
 
-#: timezone/zic.c:1220
+#: timezone/zic.c:1320
 #, c-format
 msgid "format '%s' not handled by pre-2015 versions of zic"
 msgstr "formatet ”%s” hanteras inte av versioner av zic före 2015"
 
-#: timezone/zic.c:1247
+#: timezone/zic.c:1347
 msgid "Zone continuation line end time is not after end time of previous line"
 msgstr "Zon-fortsättningsradens sluttid är inte efter sluttiden på föregående rad"
 
-#: timezone/zic.c:1274
+#: timezone/zic.c:1374
 msgid "wrong number of fields on Leap line"
 msgstr "fel antal fält på \"Leap\"-rad"
 
-#: timezone/zic.c:1283
+#: timezone/zic.c:1383
 msgid "invalid leaping year"
 msgstr "ogiltigt skottår"
 
-#: timezone/zic.c:1303 timezone/zic.c:1401
+#: timezone/zic.c:1403 timezone/zic.c:1501
 msgid "invalid month name"
 msgstr "ogiltigt månadsnamn"
 
-#: timezone/zic.c:1316 timezone/zic.c:1514 timezone/zic.c:1528
+#: timezone/zic.c:1416 timezone/zic.c:1614 timezone/zic.c:1628
 msgid "invalid day of month"
 msgstr "ogiltig dag i månaden"
 
-#: timezone/zic.c:1321
+#: timezone/zic.c:1421
 msgid "time too small"
 msgstr "tid för kort"
 
-#: timezone/zic.c:1325
+#: timezone/zic.c:1425
 msgid "time too large"
 msgstr "tid för lång"
 
-#: timezone/zic.c:1329 timezone/zic.c:1430
+#: timezone/zic.c:1429 timezone/zic.c:1530
 msgid "invalid time of day"
 msgstr "ogiltig tid på dagen"
 
-#: timezone/zic.c:1348
+#: timezone/zic.c:1448
 msgid "illegal CORRECTION field on Leap line"
 msgstr "otillåtet \"CORRECTION\"-fält på \"Leap\"-rad"
 
-#: timezone/zic.c:1353
+#: timezone/zic.c:1453
 msgid "illegal Rolling/Stationary field on Leap line"
 msgstr "otillåtet \"Rolling/Stationary\"-fält på \"Leap\"-rad"
 
-#: timezone/zic.c:1359
+#: timezone/zic.c:1459
 msgid "leap second precedes Big Bang"
 msgstr "skottsekund föregår Big Bang"
 
-#: timezone/zic.c:1372
+#: timezone/zic.c:1472
 msgid "wrong number of fields on Link line"
 msgstr "fel antal fält på \"Link\"-rad"
 
-#: timezone/zic.c:1376
+#: timezone/zic.c:1476
 msgid "blank FROM field on Link line"
 msgstr "tomt \"FROM\"-fält på \"Link\"-rad"
 
-#: timezone/zic.c:1451
+#: timezone/zic.c:1551
 msgid "invalid starting year"
 msgstr "ogiltigt startår"
 
-#: timezone/zic.c:1473
+#: timezone/zic.c:1573
 msgid "invalid ending year"
 msgstr "ogiltigt slutår"
 
-#: timezone/zic.c:1477
+#: timezone/zic.c:1577
 msgid "starting year greater than ending year"
 msgstr "startår är större än slutår"
 
-#: timezone/zic.c:1484
+#: timezone/zic.c:1584
 msgid "typed single year"
 msgstr "satte typ på endast ett år"
 
-#: timezone/zic.c:1519
+#: timezone/zic.c:1619
 msgid "invalid weekday name"
 msgstr "ogiltigt veckodagsnamn"
 
-#: timezone/zic.c:1638
+#: timezone/zic.c:1743
+#, c-format
+msgid "reference clients mishandle more than %d transition times"
+msgstr "referensklienter hanterar fler än %d övergångstider felaktigt"
+
+#: timezone/zic.c:1747
 msgid "pre-2014 clients may mishandle more than 1200 transition times"
 msgstr "klienter från före 2014 kan hantera fler än 1200 övergångstider felaktigt"
 
-#: timezone/zic.c:1691
-#, c-format
-msgid "%s: Can't remove %s: %s\n"
-msgstr "%s: Kan inte ta bort %s: %s\n"
+#: timezone/zic.c:1858
+msgid "too many transition times"
+msgstr "för många övergångstider"
 
-#: timezone/zic.c:1918
+#: timezone/zic.c:2047
 #, c-format
 msgid "%%z UTC offset magnitude exceeds 99:59:59"
 msgstr "%%z storleken på avståndet från UTC överstiger 99.59.59"
 
-#: timezone/zic.c:2291
+#: timezone/zic.c:2424
 msgid "no POSIX environment variable for zone"
 msgstr "ingen POSIX-miljövariabel för zon"
 
-#: timezone/zic.c:2297
+#: timezone/zic.c:2430
 #, c-format
 msgid "%s: pre-%d clients may mishandle distant timestamps"
 msgstr "%s: klienter före %d kan hantera avlägsna tidsstämplar felaktigt"
 
-#: timezone/zic.c:2428
+#: timezone/zic.c:2566
 msgid "two rules for same instant"
 msgstr "två regler för samma tillfälle"
 
-#: timezone/zic.c:2485
+#: timezone/zic.c:2627
 msgid "can't determine time zone abbreviation to use just after until time"
 msgstr "kan inte avgöra tidszonsförkortning att använda just efter \"until\"-tid"
 
-#: timezone/zic.c:2531 timezone/zic.c:2593
+#: timezone/zic.c:2725
 msgid "too many local time types"
 msgstr "för många lokala tidstyper"
 
-#: timezone/zic.c:2597
+#: timezone/zic.c:2729
 msgid "UT offset out of range"
 msgstr "UT-offset utanför giltigt intervall"
 
-#: timezone/zic.c:2621
+#: timezone/zic.c:2753
 msgid "too many leap seconds"
 msgstr "för många skottsekunder"
 
-#: timezone/zic.c:2627
+#: timezone/zic.c:2759
 msgid "repeated leap second moment"
 msgstr "upprepat skottsekundstillfälle"
 
-#: timezone/zic.c:2677
+#: timezone/zic.c:2830
 msgid "Wild result from command execution"
 msgstr "Vilt resultat från kommandokörning"
 
-#: timezone/zic.c:2678
+#: timezone/zic.c:2831
 #, c-format
 msgid "%s: command was '%s', result was %d\n"
 msgstr "%s: kommandot var \"%s\", resultatet blev %d\n"
 
-#: timezone/zic.c:2810
+#: timezone/zic.c:2961
 msgid "Odd number of quotation marks"
 msgstr "Ojämnt antal citationstecken"
 
-#: timezone/zic.c:2896
+#: timezone/zic.c:3046
 msgid "use of 2/29 in non leap-year"
 msgstr "använder 29/2 i icke-skottår"
 
-#: timezone/zic.c:2931
+#: timezone/zic.c:3081
 msgid "rule goes past start/end of month; will not work with pre-2004 versions of zic"
 msgstr "regeln går utanför start/slut på månad; fungerar inte med versioner av zic före 2004"
 
-#: timezone/zic.c:2958
+#: timezone/zic.c:3108
 msgid "time zone abbreviation has fewer than 3 characters"
 msgstr "tidszonsförkortning har färre än 3 tecken"
 
-#: timezone/zic.c:2960
+#: timezone/zic.c:3110
 msgid "time zone abbreviation has too many characters"
 msgstr "tidszonsförkortning har för många tecken"
 
-#: timezone/zic.c:2962
+#: timezone/zic.c:3112
 msgid "time zone abbreviation differs from POSIX standard"
 msgstr "tidszonsförkortning skiljer sig från POSIX-standarden"
 
-#: timezone/zic.c:2968
+#: timezone/zic.c:3118
 msgid "too many, or too long, time zone abbreviations"
 msgstr "för många eller för långa tidszonsförkortningar"
 
-#: timezone/zic.c:3004
+#: timezone/zic.c:3161
 #, c-format
 msgid "%s: Can't create directory %s: %s"
 msgstr "%s: Kan inte skapa katalog %s: %s"
diff --git a/resolv/nss_dns/dns-host.c b/resolv/nss_dns/dns-host.c
index 7cd54ab504..1e85e4f08f 100644
--- a/resolv/nss_dns/dns-host.c
+++ b/resolv/nss_dns/dns-host.c
@@ -889,19 +889,6 @@ getanswer_r (struct resolv_context *ctx,
 	  /* bind would put multiple PTR records as aliases, but we don't do
 	     that.  */
 	  result->h_name = bp;
-	  if (have_to_map)
-	    {
-	      n = strlen (bp) + 1;	/* for the \0 */
-	      if (__glibc_unlikely (n >= MAXHOSTNAMELEN))
-		{
-		  ++had_error;
-		  break;
-		}
-	      bp += n;
-	      linebuflen -= n;
-	      if (map_v4v6_hostent (result, &bp, &linebuflen))
-		goto too_small;
-	    }
 	  *h_errnop = NETDB_SUCCESS;
 	  return NSS_STATUS_SUCCESS;
 	case T_A:
diff --git a/resolv/res_init.c b/resolv/res_init.c
index fa46ce7813..4e1f9fe8de 100644
--- a/resolv/res_init.c
+++ b/resolv/res_init.c
@@ -446,6 +446,11 @@ res_vinit_1 (FILE *fp, struct resolv_conf_parser *parser)
                     (&parser->nameserver_list);
                   if (p != NULL)
                     *p = sa;
+                  else
+                    {
+                      free (sa);
+                      return false;
+                    }
                 }
               continue;
             }
diff --git a/resolv/resolv_conf.c b/resolv/resolv_conf.c
index f391d30c27..e0f296d02e 100644
--- a/resolv/resolv_conf.c
+++ b/resolv/resolv_conf.c
@@ -600,10 +600,7 @@ __resolv_conf_attach (struct __res_state *resp, struct resolv_conf *conf)
 
   struct resolv_conf_global *global_copy = get_locked_global ();
   if (global_copy == NULL)
-    {
-      free (conf);
-      return false;
-    }
+    return false;
 
   /* Try to find an unused index in the array.  */
   size_t index;
diff --git a/resolv/tst-res_use_inet6.c b/resolv/tst-res_use_inet6.c
index 6f3db08892..d819f921d6 100644
--- a/resolv/tst-res_use_inet6.c
+++ b/resolv/tst-res_use_inet6.c
@@ -16,21 +16,121 @@
    License along with the GNU C Library; if not, see
    <http://www.gnu.org/licenses/>.  */
 
+#include <ctype.h>
 #include <netdb.h>
 #include <resolv.h>
+#include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
+#include <support/check.h>
 #include <support/check_nss.h>
 #include <support/resolv_test.h>
+#include <support/support.h>
 #include <support/xthread.h>
 
+/* Handle IPv4 reverse lookup responses.  Product a PTR record
+   A-B-C-D.v4.example.  */
+static void
+response_ptr_v4 (const struct resolv_response_context *ctx,
+                 struct resolv_response_builder *b,
+                 const char *qname, uint16_t qclass, uint16_t qtype)
+{
+  int bytes[4];
+  int offset = -1;
+  TEST_VERIFY (sscanf (qname, "%d.%d.%d.%d.in-addr.arpa%n",
+                       bytes + 0, bytes + 1, bytes + 2, bytes + 3,
+                       &offset) == 4);
+  TEST_VERIFY (offset == strlen (qname));
+  resolv_response_init (b, (struct resolv_response_flags) {});
+  resolv_response_add_question (b, qname, qclass, qtype);
+  resolv_response_section (b, ns_s_an);
+  resolv_response_open_record (b, qname, qclass, T_PTR, 0);
+  char *name = xasprintf ("%d-%d-%d-%d.v4.example",
+                          bytes[3], bytes[2], bytes[1], bytes[0]);
+  resolv_response_add_name (b, name);
+  free (name);
+  resolv_response_close_record (b);
+}
+
+/* Handle IPv6 reverse lookup responses.  Produce a PTR record
+   <32 hex digits>.v6.example. */
+static void
+response_ptr_v6 (const struct resolv_response_context *ctx,
+                 struct resolv_response_builder *b,
+                 const char *qname, uint16_t qclass, uint16_t qtype)
+{
+
+  TEST_VERIFY_EXIT (strlen (qname) > 64);
+
+  char bytes[33];
+  for (int i = 0; i < 64; ++i)
+    if ((i % 2) == 0)
+      {
+        TEST_VERIFY (isxdigit ((unsigned char) qname[i]));
+        bytes[31 - i / 2] = qname[i];
+      }
+    else
+      TEST_VERIFY_EXIT (qname[i] == '.');
+  bytes[32] = '\0';
+
+    resolv_response_init (b, (struct resolv_response_flags) {});
+  resolv_response_add_question (b, qname, qclass, qtype);
+  resolv_response_section (b, ns_s_an);
+  resolv_response_open_record (b, qname, qclass, T_PTR, 0);
+  char *name = xasprintf ("%s.v6.example", bytes);
+  resolv_response_add_name (b, name);
+  free (name);
+  resolv_response_close_record (b);
+}
+
+/* Produce a response based on QNAME: Certain characters in the first
+   label of QNAME trigger the inclusion of resource records:
+
+   'a'   A record (IPv4 address)
+   'q'   AAAA record (quad A record, IPv6 address)
+   'p'   PTR record
+   'm'   record type must match QTYPE (no additional records)
+   '6'   stop flag processing if QTYPE == AAAA
+
+   For 'a' and 'q', QTYPE is ignored for record type selection if 'm'
+   is not specified.
+
+   in-addr.arpa and ip6.arpa queries are handled separately in
+   response_ptr_v4 and response_ptr_v6.  */
 static void
 response (const struct resolv_response_context *ctx,
           struct resolv_response_builder *b,
           const char *qname, uint16_t qclass, uint16_t qtype)
 {
-  bool include_both =  strcmp (qname, "both.example") == 0;
-  bool include_a = qtype == T_A || include_both;
-  bool include_aaaa = qtype == T_AAAA || include_both;
+  if (strstr (qname, ".in-addr.arpa") != NULL)
+    return response_ptr_v4 (ctx, b, qname, qclass, qtype);
+  else if (strstr (qname, ".ip6.arpa") != NULL)
+    return response_ptr_v6 (ctx, b, qname, qclass, qtype);
+
+  bool include_a = false;
+  bool include_aaaa = false;
+  bool include_match = false;
+  bool include_ptr = false;
+  for (const char *p = qname; *p != '.' && *p != '\0'; ++p)
+    {
+      if (*p == 'a')
+        include_a = true;
+      else if (*p == 'q')
+        include_aaaa = true;
+      else if (*p == 'm')
+        include_match = true;
+      else if (*p == 'p')
+        include_ptr = true;
+      else if (*p == '6' && qtype == T_AAAA)
+        break;
+    }
+  if (include_match)
+    {
+      if (qtype == T_A)
+        include_aaaa = false;
+      else if (qtype == T_AAAA)
+        include_a = false;
+    }
 
   resolv_response_init (b, (struct resolv_response_flags) {});
   resolv_response_add_question (b, qname, qclass, qtype);
@@ -44,11 +144,17 @@ response (const struct resolv_response_context *ctx,
     }
   if (include_aaaa)
     {
-        char ipv6[16]
-          = {0x20, 0x01, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
-        resolv_response_open_record (b, qname, qclass, T_AAAA, 0);
-        resolv_response_add_data (b, &ipv6, sizeof (ipv6));
-        resolv_response_close_record (b);
+      char ipv6[16]
+        = {0x20, 0x01, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
+      resolv_response_open_record (b, qname, qclass, T_AAAA, 0);
+      resolv_response_add_data (b, &ipv6, sizeof (ipv6));
+      resolv_response_close_record (b);
+    }
+  if (include_ptr)
+    {
+      resolv_response_open_record (b, qname, qclass, T_PTR, 0);
+      resolv_response_add_name (b, "ptr-target.example");
+      resolv_response_close_record (b);
     }
 }
 
@@ -64,16 +170,21 @@ test_gai (void)
         .ai_protocol = IPPROTO_TCP,
       };
     struct addrinfo *ai;
-    int ret = getaddrinfo ("www1.example", "80", &hints, &ai);
-    check_addrinfo ("getaddrinfo AF_UNSPEC www1.example", ai, ret,
+    int ret = getaddrinfo ("qam.example", "80", &hints, &ai);
+    check_addrinfo ("getaddrinfo AF_UNSPEC qam.example", ai, ret,
                     "address: STREAM/TCP 192.0.2.17 80\n"
                     "address: STREAM/TCP 2001:db8::1 80\n");
     if (ret == 0)
       freeaddrinfo (ai);
-    ret = getaddrinfo ("both.example", "80", &hints, &ai);
+    ret = getaddrinfo ("am.example", "80", &hints, &ai);
+    check_addrinfo ("getaddrinfo AF_UNSPEC am.example", ai, ret,
+                    "address: STREAM/TCP 192.0.2.17 80\n");
+    if (ret == 0)
+      freeaddrinfo (ai);
+    ret = getaddrinfo ("qa.example", "80", &hints, &ai);
     /* Combined A/AAAA responses currently result in address
        duplication.  */
-    check_addrinfo ("getaddrinfo AF_UNSPEC both.example", ai, ret,
+    check_addrinfo ("getaddrinfo AF_UNSPEC qa.example", ai, ret,
                     "address: STREAM/TCP 192.0.2.17 80\n"
                     "address: STREAM/TCP 192.0.2.17 80\n"
                     "address: STREAM/TCP 2001:db8::1 80\n"
@@ -89,13 +200,18 @@ test_gai (void)
         .ai_protocol = IPPROTO_TCP,
       };
     struct addrinfo *ai;
-    int ret = getaddrinfo ("www1.example", "80", &hints, &ai);
-    check_addrinfo ("getaddrinfo AF_INET www1.example", ai, ret,
+    int ret = getaddrinfo ("qam.example", "80", &hints, &ai);
+    check_addrinfo ("getaddrinfo AF_INET qam.example", ai, ret,
+                    "address: STREAM/TCP 192.0.2.17 80\n");
+    if (ret == 0)
+      freeaddrinfo (ai);
+    ret = getaddrinfo ("am.example", "80", &hints, &ai);
+    check_addrinfo ("getaddrinfo AF_INET am.example", ai, ret,
                     "address: STREAM/TCP 192.0.2.17 80\n");
     if (ret == 0)
       freeaddrinfo (ai);
-    ret = getaddrinfo ("both.example", "80", &hints, &ai);
-    check_addrinfo ("getaddrinfo AF_INET both.example", ai, ret,
+    ret = getaddrinfo ("qa.example", "80", &hints, &ai);
+    check_addrinfo ("getaddrinfo AF_INET qa.example", ai, ret,
                     "address: STREAM/TCP 192.0.2.17 80\n");
     if (ret == 0)
       freeaddrinfo (ai);
@@ -108,40 +224,196 @@ test_gai (void)
         .ai_protocol = IPPROTO_TCP,
       };
     struct addrinfo *ai;
-    int ret = getaddrinfo ("www1.example", "80", &hints, &ai);
+    int ret = getaddrinfo ("qa.example", "80", &hints, &ai);
     check_addrinfo ("getaddrinfo (AF_INET6)", ai, ret,
                     "address: STREAM/TCP 2001:db8::1 80\n");
     if (ret == 0)
       freeaddrinfo (ai);
-    ret = getaddrinfo ("both.example", "80", &hints, &ai);
-    check_addrinfo ("getaddrinfo AF_INET6 both.example", ai, ret,
+    ret = getaddrinfo ("am.example", "80", &hints, &ai);
+    check_addrinfo ("getaddrinfo AF_INET6 am.example", ai, ret,
+                    "error: No address associated with hostname\n");
+    if (ret == 0)
+      freeaddrinfo (ai);
+    ret = getaddrinfo ("qam.example", "80", &hints, &ai);
+    check_addrinfo ("getaddrinfo AF_INET6 qam.example", ai, ret,
                     "address: STREAM/TCP 2001:db8::1 80\n");
     if (ret == 0)
       freeaddrinfo (ai);
   }
 }
 
-/* Test that gethostbyname2 is not influenced by RES_USE_INET6.  */
+/* Test gethostbyaddr and getnameinfo.  The results are independent of
+   RES_USE_INET6.  */
 static void
-test_get2 (void)
+test_reverse (void)
 {
-  check_hostent ("gethostbyname2 AF_INET www1.example",
-                 gethostbyname2 ("www1.example", AF_INET),
-                 "name: www1.example\n"
+  {
+    char ipv4[4] = { 192, 0, 2, 17 };
+    check_hostent ("gethostbyaddr AF_INET",
+                   gethostbyaddr (ipv4, sizeof (ipv4), AF_INET),
+                   "name: 192-0-2-17.v4.example\n"
+                   "address: 192.0.2.17\n");
+  }
+  {
+    char ipv6[16]
+      = {0x20, 0x01, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
+    check_hostent ("gethostbyaddr AF_INET",
+                   gethostbyaddr (ipv6, sizeof (ipv6), AF_INET6),
+                   "name: 20010db8000000000000000000000001.v6.example\n"
+                   "address: 2001:db8::1\n");
+  }
+
+  {
+    struct sockaddr_in addr =
+      {
+        .sin_family = AF_INET,
+        .sin_addr = { .s_addr = htonl (0xc0000211) },
+        .sin_port = htons (80)
+      };
+    char host[NI_MAXHOST];
+    char service[NI_MAXSERV];
+    int ret = getnameinfo ((struct sockaddr *) &addr, sizeof (addr),
+                           host, sizeof (host), service, sizeof (service),
+                           NI_NUMERICSERV);
+    TEST_VERIFY (ret == 0);
+    TEST_VERIFY (strcmp (host, "192-0-2-17.v4.example") == 0);
+    TEST_VERIFY (strcmp (service, "80") == 0);
+  }
+  {
+    char ipv6[16]
+      = {0x20, 0x01, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
+    struct sockaddr_in6 addr =
+      {
+        .sin6_family = AF_INET6,
+        .sin6_port = htons (80),
+      };
+    TEST_VERIFY (sizeof (ipv6) == sizeof (addr.sin6_addr));
+    memcpy (&addr.sin6_addr, ipv6, sizeof (addr.sin6_addr));
+    char host[NI_MAXHOST];
+    char service[NI_MAXSERV];
+    int ret = getnameinfo ((struct sockaddr *) &addr, sizeof (addr),
+                           host, sizeof (host), service, sizeof (service),
+                           NI_NUMERICSERV);
+    TEST_VERIFY (ret == 0);
+    TEST_VERIFY
+      (strcmp (host, "20010db8000000000000000000000001.v6.example") == 0);
+    TEST_VERIFY (strcmp (service, "80") == 0);
+  }
+}
+
+/* Test that gethostbyname2 is mostly not influenced by
+   RES_USE_INET6.  */
+static void
+test_get2_any (void)
+{
+  check_hostent ("gethostbyname2 AF_INET am.example",
+                 gethostbyname2 ("am.example", AF_INET),
+                 "name: am.example\n"
+                 "address: 192.0.2.17\n");
+  check_hostent ("gethostbyname2 AF_INET a.example",
+                 gethostbyname2 ("a.example", AF_INET),
+                 "name: a.example\n"
                  "address: 192.0.2.17\n");
-  check_hostent ("gethostbyname2 AF_INET both.example",
-                 gethostbyname2 ("both.example", AF_INET),
-                 "name: both.example\n"
+  check_hostent ("gethostbyname2 AF_INET qm.example",
+                 gethostbyname2 ("qm.example", AF_INET),
+                 "error: NO_ADDRESS\n");
+  check_hostent ("gethostbyname2 AF_INET q.example",
+                 gethostbyname2 ("q.example", AF_INET),
+                 "error: NO_RECOVERY\n");
+  check_hostent ("gethostbyname2 AF_INET qam.example",
+                 gethostbyname2 ("qam.example", AF_INET),
+                 "name: qam.example\n"
+                 "address: 192.0.2.17\n");
+  check_hostent ("gethostbyname2 AF_INET qa.example",
+                 gethostbyname2 ("qa.example", AF_INET),
+                 "name: qa.example\n"
                  "address: 192.0.2.17\n");
 
-  check_hostent ("gethostbyname2 AF_INET6 www1.example",
-                 gethostbyname2 ("www1.example", AF_INET6),
-                 "name: www1.example\n"
+  check_hostent ("gethostbyname2 AF_INET6 qm.example",
+                 gethostbyname2 ("qm.example", AF_INET6),
+                 "name: qm.example\n"
+                 "address: 2001:db8::1\n");
+  check_hostent ("gethostbyname2 AF_INET6 q.example",
+                 gethostbyname2 ("q.example", AF_INET6),
+                 "name: q.example\n"
+                 "address: 2001:db8::1\n");
+  check_hostent ("gethostbyname2 AF_INET6 qam.example",
+                 gethostbyname2 ("qam.example", AF_INET6),
+                 "name: qam.example\n"
                  "address: 2001:db8::1\n");
-  check_hostent ("gethostbyname2 AF_INET6 both.example",
-                 gethostbyname2 ("both.example", AF_INET6),
-                 "name: both.example\n"
+  check_hostent ("gethostbyname2 AF_INET6 qa.example",
+                 gethostbyname2 ("qa.example", AF_INET6),
+                 "name: qa.example\n"
                  "address: 2001:db8::1\n");
+  /* Additional AF_INET6 tests depend on RES_USE_INET6; see below.  */
+
+  test_reverse ();
+}
+
+/* gethostbyname2 tests with RES_USE_INET6 disabled.  */
+static void
+test_get2_no_inet6 (void)
+{
+  test_get2_any ();
+
+  check_hostent ("gethostbyname2 AF_INET6 am.example",
+                 gethostbyname2 ("am.example", AF_INET6),
+                 "error: NO_ADDRESS\n");
+  check_hostent ("gethostbyname2 AF_INET6 a.example",
+                 gethostbyname2 ("a.example", AF_INET6),
+                 "error: NO_RECOVERY\n");
+}
+
+/* gethostbyname2 tests with RES_USE_INET6 enabled.  */
+static void
+test_get2_inet6 (void)
+{
+  test_get2_any ();
+
+  check_hostent ("gethostbyname2 AF_INET6 am.example",
+                 gethostbyname2 ("am.example", AF_INET6),
+                 "name: am.example\n"
+                 "address: ::ffff:192.0.2.17\n");
+  check_hostent ("gethostbyname2 AF_INET6 a.example",
+                 gethostbyname2 ("a.example", AF_INET6),
+                 "error: NO_RECOVERY\n");
+}
+
+/* Collection of tests which assume no RES_USE_INET6 flag.  */
+static void
+test_no_inet6 (void)
+{
+  check_hostent ("gethostbyname (\"a.example\")",
+                 gethostbyname ("a.example"),
+                 "name: a.example\n"
+                 "address: 192.0.2.17\n");
+  check_hostent ("gethostbyname (\"qa.example\")",
+                 gethostbyname ("qa.example"),
+                 "name: qa.example\n"
+                 "address: 192.0.2.17\n");
+  check_hostent ("gethostbyname (\"am.example\")",
+                 gethostbyname ("am.example"),
+                 "name: am.example\n"
+                 "address: 192.0.2.17\n");
+  check_hostent ("gethostbyname (\"amp.example\")",
+                 gethostbyname ("amp.example"),
+                 "name: amp.example\n"
+                 "address: 192.0.2.17\n");
+  check_hostent ("gethostbyname (\"qam.example\")",
+                 gethostbyname ("qam.example"),
+                 "name: qam.example\n"
+                 "address: 192.0.2.17\n");
+  check_hostent ("gethostbyname (\"q.example\")",
+                 gethostbyname ("q.example"),
+                 "error: NO_RECOVERY\n");
+  check_hostent ("gethostbyname (\"qm.example\")",
+                 gethostbyname ("qm.example"),
+                 "error: NO_ADDRESS\n");
+  test_get2_no_inet6 ();
+  test_get2_no_inet6 ();
+  test_gai ();
+  test_get2_no_inet6 ();
+  test_get2_no_inet6 ();
 }
 
 static void *
@@ -153,28 +425,64 @@ threadfunc (void *ignored)
        .response_callback = response
      });
 
-  check_hostent ("gethostbyname (\"www1.example\")",
-                 gethostbyname ("www1.example"),
-                 "name: www1.example\n"
-                 "address: 192.0.2.17\n");
-  check_hostent ("gethostbyname (\"both.example\")",
-                 gethostbyname ("both.example"),
-                 "name: both.example\n"
-                 "address: 192.0.2.17\n");
-  test_get2 ();
-  test_gai ();
+  TEST_VERIFY ((_res.options & RES_USE_INET6) == 0);
+  test_no_inet6 ();
 
   _res.options |= RES_USE_INET6;
-  check_hostent ("gethostbyname (\"www1.example\")",
-                 gethostbyname ("www1.example"),
-                 "name: www1.example\n"
+  check_hostent ("gethostbyname (\"a.inet6.example\")",
+                 gethostbyname ("a.inet6.example"),
+                 "error: NO_RECOVERY\n");
+  check_hostent ("gethostbyname (\"am.inet6.example\")",
+                 gethostbyname ("am.inet6.example"),
+                 "name: am.inet6.example\n"
+                 "address: ::ffff:192.0.2.17\n");
+  check_hostent ("gethostbyname (\"qa.inet6.example\")",
+                 gethostbyname ("qa.inet6.example"),
+                 "name: qa.inet6.example\n"
                  "address: 2001:db8::1\n");
-  check_hostent ("gethostbyname (\"both.example\")",
-                 gethostbyname ("both.example"),
-                 "name: both.example\n"
+  check_hostent ("gethostbyname (\"qam.inet6.example\")",
+                 gethostbyname ("qam.inet6.example"),
+                 "name: qam.inet6.example\n"
                  "address: 2001:db8::1\n");
-  test_get2 ();
+  check_hostent ("gethostbyname (\"q.inet6.example\")",
+                 gethostbyname ("q.inet6.example"),
+                 "name: q.inet6.example\n"
+                 "address: 2001:db8::1\n");
+  check_hostent ("gethostbyname (\"qm.inet6.example\")",
+                 gethostbyname ("qm.inet6.example"),
+                 "name: qm.inet6.example\n"
+                 "address: 2001:db8::1\n");
+  check_hostent ("gethostbyname (\"amp.inet6.example\")",
+                 gethostbyname ("amp.inet6.example"),
+                 "error: NO_RECOVERY\n");
+  check_hostent ("gethostbyname (\"qmp.inet6.example\")",
+                 gethostbyname ("qmp.inet6.example"),
+                 "name: qmp.inet6.example\n"
+                 "address: 2001:db8::1\n");
+  check_hostent ("gethostbyname (\"ap.inet6.example\")",
+                 gethostbyname ("ap.inet6.example"),
+                 "error: NO_RECOVERY\n");
+  check_hostent ("gethostbyname (\"6ap.inet6.example\")",
+                 gethostbyname ("6ap.inet6.example"),
+                 "name: 6ap.inet6.example\n"
+                 "address: ::ffff:192.0.2.17\n");
+  check_hostent ("gethostbyname (\"am6p.inet6.example\")",
+                 gethostbyname ("am6p.inet6.example"),
+                 "name: am6p.inet6.example\n"
+                 "address: ::ffff:192.0.2.17\n");
+  check_hostent ("gethostbyname (\"qp.inet6.example\")",
+                 gethostbyname ("qp.inet6.example"),
+                 "name: qp.inet6.example\n"
+                 "address: 2001:db8::1\n");
+  test_get2_inet6 ();
+  test_get2_inet6 ();
   test_gai ();
+  test_get2_inet6 ();
+  test_get2_inet6 ();
+
+  TEST_VERIFY (_res.options & RES_USE_INET6);
+  _res.options &= ~RES_USE_INET6;
+  test_no_inet6 ();
 
   resolv_test_end (obj);
 
diff --git a/resolv/tst-resolv-basic.c b/resolv/tst-resolv-basic.c
index 64eedbbd81..66a0e8a165 100644
--- a/resolv/tst-resolv-basic.c
+++ b/resolv/tst-resolv-basic.c
@@ -50,7 +50,7 @@ response (const struct resolv_response_context *ctx,
     qname_compare = qname + 2;
   else
     qname_compare = qname;
-  enum {www, alias, nxdomain, long_name} requested_qname;
+  enum {www, alias, nxdomain, long_name, nodata} requested_qname;
   if (strcmp (qname_compare, "www.example") == 0)
     requested_qname = www;
   else if (strcmp (qname_compare, "alias.example") == 0)
@@ -59,6 +59,8 @@ response (const struct resolv_response_context *ctx,
     requested_qname = nxdomain;
   else if (strcmp (qname_compare, LONG_NAME) == 0)
     requested_qname = long_name;
+  else if (strcmp (qname_compare, "nodata.example") == 0)
+    requested_qname = nodata;
   else
     {
       support_record_failure ();
@@ -87,6 +89,8 @@ response (const struct resolv_response_context *ctx,
       resolv_response_close_record (b);
       resolv_response_open_record (b, "www.example", qclass, qtype, 0);
       break;
+    case nodata:
+      return;
     case nxdomain:
       FAIL_EXIT1 ("unreachable");
     }
@@ -267,6 +271,55 @@ test_bug_21295 (void)
     }
 }
 
+/* Run tests which do not expect any data.  */
+static void
+test_nodata_nxdomain (void)
+{
+  /* Iterate through different address families.  */
+  int families[] = { AF_UNSPEC, AF_INET, AF_INET6, -1 };
+  for (int i = 0; families[i] >= 0; ++i)
+    /* If do_tcp, prepend "t." to the name to trigger TCP
+       fallback.  */
+    for (int do_tcp = 0; do_tcp < 2; ++do_tcp)
+      /* If do_nxdomain, trigger an NXDOMAIN error (DNS failure),
+         otherwise use a NODATA response (empty but successful
+         answer).  */
+      for (int do_nxdomain = 0; do_nxdomain < 2; ++do_nxdomain)
+        {
+          int family = families[i];
+          char *name = xasprintf ("%s%s.example",
+                                  do_tcp ? "t." : "",
+                                  do_nxdomain ? "nxdomain" : "nodata");
+
+          if (family != AF_UNSPEC)
+            {
+              if (do_nxdomain)
+                check_h (name, family, "error: HOST_NOT_FOUND\n");
+              else
+                check_h (name, family, "error: NO_ADDRESS\n");
+            }
+
+          const char *expected;
+          if (do_nxdomain)
+            expected = "error: Name or service not known\n";
+          else
+            expected = "error: No address associated with hostname\n";
+
+          check_ai (name, "80", family, expected);
+
+          struct addrinfo hints =
+            {
+              .ai_family = family,
+              .ai_flags = AI_V4MAPPED | AI_ALL,
+            };
+          check_ai_hints (name, "80", hints, expected);
+          hints.ai_flags |= AI_CANONNAME;
+          check_ai_hints (name, "80", hints, expected);
+
+          free (name);
+        }
+}
+
 static int
 do_test (void)
 {
@@ -439,29 +492,8 @@ do_test (void)
             "address: DGRAM/UDP 2001:db8::4 80\n"
             "address: RAW/IP 2001:db8::4 80\n");
 
-  check_h ("nxdomain.example", AF_INET,
-           "error: HOST_NOT_FOUND\n");
-  check_h ("nxdomain.example", AF_INET6,
-           "error: HOST_NOT_FOUND\n");
-  check_ai ("nxdomain.example", "80", AF_UNSPEC,
-            "error: Name or service not known\n");
-  check_ai ("nxdomain.example", "80", AF_INET,
-            "error: Name or service not known\n");
-  check_ai ("nxdomain.example", "80", AF_INET6,
-            "error: Name or service not known\n");
-
-  check_h ("t.nxdomain.example", AF_INET,
-           "error: HOST_NOT_FOUND\n");
-  check_h ("t.nxdomain.example", AF_INET6,
-           "error: HOST_NOT_FOUND\n");
-  check_ai ("t.nxdomain.example", "80", AF_UNSPEC,
-            "error: Name or service not known\n");
-  check_ai ("t.nxdomain.example", "80", AF_INET,
-            "error: Name or service not known\n");
-  check_ai ("t.nxdomain.example", "80", AF_INET6,
-            "error: Name or service not known\n");
-
   test_bug_21295 ();
+  test_nodata_nxdomain ();
 
   resolv_test_end (aux);
 
diff --git a/resolv/tst-resolv-qtypes.c b/resolv/tst-resolv-qtypes.c
index 06ea3dbd14..da3325f80c 100644
--- a/resolv/tst-resolv-qtypes.c
+++ b/resolv/tst-resolv-qtypes.c
@@ -50,7 +50,7 @@ response (const struct resolv_response_context *ctx,
   resolv_response_close_record (b);
 }
 
-static const char * const domain = "www.example.com";
+static const char domain[] = "www.example.com";
 
 static int
 wrap_res_query (int type, unsigned char *answer, int answer_length)
diff --git a/stdlib/getentropy.c b/stdlib/getentropy.c
index a71d4cd8f5..a88bbf8de3 100644
--- a/stdlib/getentropy.c
+++ b/stdlib/getentropy.c
@@ -21,7 +21,7 @@
 
 /* Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on
    success and -1 on failure.  */
-ssize_t
+int
 getentropy (void *buffer, size_t length)
 {
   __set_errno (ENOSYS);
diff --git a/string/stratcliff.c b/string/stratcliff.c
index e28b0c5058..4320336c9a 100644
--- a/string/stratcliff.c
+++ b/string/stratcliff.c
@@ -58,8 +58,8 @@
 int
 do_test (void)
 {
-  int size = sysconf (_SC_PAGESIZE);
-  int nchars = size / sizeof (CHAR);
+  size_t size = sysconf (_SC_PAGESIZE);
+  size_t nchars = size / sizeof (CHAR);
   CHAR *adr;
   CHAR *dest;
   int result = 0;
@@ -80,7 +80,17 @@ do_test (void)
     }
   else
     {
-      int inner, middle, outer;
+      size_t inner, middle, outer, nchars64, max128;
+
+      if (nchars > 64)
+	nchars64 = nchars - 64;
+      else
+	nchars64 = 0;
+
+      if (nchars > 128)
+	max128 = nchars - 128;
+      else
+	max128 = 0;
 
       mprotect (adr, size, PROT_NONE);
       mprotect (adr + 2 * nchars, size, PROT_NONE);
@@ -93,59 +103,65 @@ do_test (void)
       MEMSET (adr, L('T'), nchars);
 
       /* strlen/wcslen test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (inner = MAX (outer, nchars - 64); inner < nchars; ++inner)
+	  for (inner = MAX (outer, nchars64); inner < nchars; ++inner)
 	    {
 	      adr[inner] = L('\0');
 
 	      if (STRLEN (&adr[outer]) != (size_t) (inner - outer))
 		{
-		  printf ("%s flunked for outer = %d, inner = %d\n",
+		  printf ("%s flunked for outer = %zu, inner = %zu\n",
 			  STRINGIFY (STRLEN), outer, inner);
 		  result = 1;
 		}
 
 	      adr[inner] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* strnlen/wcsnlen test */
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars; outer >= max128; --outer)
 	{
-	  for (inner = MAX (outer, nchars - 64); inner < nchars; ++inner)
+	  for (inner = MAX (outer, nchars64); inner < nchars; ++inner)
 	    {
 	      adr[inner] = L('\0');
 
 	      if (STRNLEN (&adr[outer], inner - outer + 1)
 		  != (size_t) (inner - outer))
 		{
-		  printf ("%s flunked for outer = %d, inner = %d\n",
+		  printf ("%s flunked for outer = %zu, inner = %zu\n",
 			  STRINGIFY (STRNLEN), outer, inner);
 		  result = 1;
 		}
 
 	      adr[inner] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars; outer >= max128; --outer)
 	{
-	  for (inner = MAX (outer, nchars - 64); inner <= nchars; ++inner)
+	  for (inner = MAX (outer, nchars64); inner <= nchars; ++inner)
 	    {
 	      if (STRNLEN (&adr[outer], inner - outer)
 		  != (size_t) (inner - outer))
 		{
-		  printf ("%s flunked bounded for outer = %d, inner = %d\n",
+		  printf ("%s flunked bounded for outer = %zu, inner = %zu\n",
 			  STRINGIFY (STRNLEN), outer, inner);
 		  result = 1;
 		}
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* strchr/wcschr test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (middle = MAX (outer, nchars - 64); middle < nchars; ++middle)
+	  for (middle = MAX (outer, nchars64); middle < nchars; ++middle)
 	    {
 	      for (inner = middle; inner < nchars; ++inner)
 		{
@@ -158,8 +174,8 @@ do_test (void)
 		      || (inner != middle
 			  && (cp - &adr[outer]) != middle - outer))
 		    {
-		      printf ("%s flunked for outer = %d, middle = %d, "
-			      "inner = %d\n",
+		      printf ("%s flunked for outer = %zu, middle = %zu, "
+			      "inner = %zu\n",
 			      STRINGIFY (STRCHR), outer, middle, inner);
 		      result = 1;
 		    }
@@ -168,6 +184,8 @@ do_test (void)
 		  adr[middle] = L('T');
 		}
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* Special test.  */
@@ -180,9 +198,9 @@ do_test (void)
 	}
 
       /* strrchr/wcsrchr test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (middle = MAX (outer, nchars - 64); middle < nchars; ++middle)
+	  for (middle = MAX (outer, nchars64); middle < nchars; ++middle)
 	    {
 	      for (inner = middle; inner < nchars; ++inner)
 		{
@@ -195,8 +213,8 @@ do_test (void)
 		      || (inner != middle
 			  && (cp - &adr[outer]) != middle - outer))
 		    {
-		      printf ("%s flunked for outer = %d, middle = %d, "
-			      "inner = %d\n",
+		      printf ("%s flunked for outer = %zu, middle = %zu, "
+			      "inner = %zu\n",
 			      STRINGIFY (STRRCHR), outer, middle, inner);
 		      result = 1;
 		    }
@@ -205,12 +223,14 @@ do_test (void)
 		  adr[middle] = L('T');
 		}
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* memchr test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (middle = MAX (outer, nchars - 64); middle < nchars; ++middle)
+	  for (middle = MAX (outer, nchars64); middle < nchars; ++middle)
 	    {
 	      adr[middle] = L('V');
 
@@ -218,32 +238,36 @@ do_test (void)
 
 	      if (cp - &adr[outer] != middle - outer)
 		{
-		  printf ("%s flunked for outer = %d, middle = %d\n",
+		  printf ("%s flunked for outer = %zu, middle = %zu\n",
 			  STRINGIFY (MEMCHR), outer, middle);
 		  result = 1;
 		}
 
 	      adr[middle] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars; outer >= max128; --outer)
 	{
 	  CHAR *cp = MEMCHR (&adr[outer], L('V'), nchars - outer);
 
 	  if (cp != NULL)
 	    {
-	      printf ("%s flunked for outer = %d\n",
+	      printf ("%s flunked for outer = %zu\n",
 		      STRINGIFY (MEMCHR), outer);
 	      result = 1;
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* These functions only exist for single-byte characters.  */
 #ifndef WCSTEST
       /* rawmemchr test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (middle = MAX (outer, nchars - 64); middle < nchars; ++middle)
+	  for (middle = MAX (outer, nchars64); middle < nchars; ++middle)
 	    {
 	      adr[middle] = L('V');
 
@@ -251,19 +275,21 @@ do_test (void)
 
 	      if (cp - &adr[outer] != middle - outer)
 		{
-		  printf ("%s flunked for outer = %d, middle = %d\n",
+		  printf ("%s flunked for outer = %zu, middle = %zu\n",
 			  STRINGIFY (rawmemchr), outer, middle);
 		  result = 1;
 		}
 
 	      adr[middle] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* memrchr test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (middle = MAX (outer, nchars - 64); middle < nchars; ++middle)
+	  for (middle = MAX (outer, nchars64); middle < nchars; ++middle)
 	    {
 	      adr[middle] = L('V');
 
@@ -271,44 +297,50 @@ do_test (void)
 
 	      if (cp - &adr[outer] != middle - outer)
 		{
-		  printf ("%s flunked for outer = %d, middle = %d\n",
+		  printf ("%s flunked for outer = %zu, middle = %zu\n",
 			  STRINGIFY (memrchr), outer, middle);
 		  result = 1;
 		}
 
 	      adr[middle] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars; outer >= max128; --outer)
 	{
 	  CHAR *cp = memrchr (&adr[outer], L('V'), nchars - outer);
 
 	  if (cp != NULL)
 	    {
-	      printf ("%s flunked for outer = %d\n",
+	      printf ("%s flunked for outer = %zu\n",
 		      STRINGIFY (memrchr), outer);
 	      result = 1;
 	    }
+	  if (outer == 0)
+	    break;
 	}
 #endif
 
       /* strcpy/wcscpy test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (inner = MAX (outer, nchars - 64); inner < nchars; ++inner)
+	  for (inner = MAX (outer, nchars64); inner < nchars; ++inner)
 	    {
 	      adr[inner] = L('\0');
 
 	      if (STRCPY (dest, &adr[outer]) != dest
 		  || STRLEN (dest) != (size_t) (inner - outer))
 		{
-		  printf ("%s flunked for outer = %d, inner = %d\n",
+		  printf ("%s flunked for outer = %zu, inner = %zu\n",
 			  STRINGIFY (STRCPY), outer, inner);
 		  result = 1;
 		}
 
 	      adr[inner] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* strcmp/wcscmp tests */
@@ -322,14 +354,14 @@ do_test (void)
 
 	    if (STRCMP (adr + middle, dest + nchars - outer) <= 0)
 	      {
-		printf ("%s 1 flunked for outer = %d, middle = %d\n",
+		printf ("%s 1 flunked for outer = %zu, middle = %zu\n",
 			STRINGIFY (STRCMP), outer, middle);
 		result = 1;
 	      }
 
 	    if (STRCMP (dest + nchars - outer, adr + middle) >= 0)
 	      {
-		printf ("%s 2 flunked for outer = %d, middle = %d\n",
+		printf ("%s 2 flunked for outer = %zu, middle = %zu\n",
 			STRINGIFY (STRCMP), outer, middle);
 		result = 1;
 	      }
@@ -348,16 +380,16 @@ do_test (void)
 	      {
 		if (STRNCMP (adr + middle, dest + nchars - outer, inner) != 0)
 		  {
-		    printf ("%s 1 flunked for outer = %d, middle = %d, "
-			    "inner = %d\n",
+		    printf ("%s 1 flunked for outer = %zu, middle = %zu, "
+			    "inner = %zu\n",
 			    STRINGIFY (STRNCMP), outer, middle, inner);
 		    result = 1;
 		  }
 
 		if (STRNCMP (dest + nchars - outer, adr + middle, inner) != 0)
 		  {
-		    printf ("%s 2 flunked for outer = %d, middle = %d, "
-			    "inner = %d\n",
+		    printf ("%s 2 flunked for outer = %zu, middle = %zu, "
+			    "inner = %zu\n",
 			    STRINGIFY (STRNCMP), outer, middle, inner);
 		    result = 1;
 		  }
@@ -365,14 +397,14 @@ do_test (void)
 
 	    if (STRNCMP (adr + middle, dest + nchars - outer, outer) >= 0)
 	      {
-		printf ("%s 1 flunked for outer = %d, middle = %d, full\n",
+		printf ("%s 1 flunked for outer = %zu, middle = %zu, full\n",
 			STRINGIFY (STRNCMP), outer, middle);
 		result = 1;
 	      }
 
 	    if (STRNCMP (dest + nchars - outer, adr + middle, outer) <= 0)
 	      {
-		printf ("%s 2 flunked for outer = %d, middle = %d, full\n",
+		printf ("%s 2 flunked for outer = %zu, middle = %zu, full\n",
 			STRINGIFY (STRNCMP), outer, middle);
 		result = 1;
 	      }
@@ -380,7 +412,7 @@ do_test (void)
 
       /* strncpy/wcsncpy tests */
       adr[nchars - 1] = L('T');
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars; outer >= max128; --outer)
 	{
 	  size_t len;
 
@@ -389,17 +421,19 @@ do_test (void)
 	      if (STRNCPY (dest, &adr[outer], len) != dest
 		  || MEMCMP (dest, &adr[outer], len) != 0)
 		{
-		  printf ("outer %s flunked for outer = %d, len = %Zd\n",
+		  printf ("outer %s flunked for outer = %zu, len = %zu\n",
 			  STRINGIFY (STRNCPY), outer, len);
 		  result = 1;
 		}
 	    }
+	  if (outer == 0)
+	    break;
 	}
       adr[nchars - 1] = L('\0');
 
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (inner = MAX (outer, nchars - 64); inner < nchars; ++inner)
+	  for (inner = MAX (outer, nchars64); inner < nchars; ++inner)
 	    {
 	      size_t len;
 
@@ -413,8 +447,8 @@ do_test (void)
 		      || (inner - outer < len
 			  && STRLEN (dest) != (inner - outer)))
 		    {
-		      printf ("%s flunked for outer = %d, inner = %d, "
-			      "len = %Zd\n",
+		      printf ("%s flunked for outer = %zu, inner = %zu, "
+			      "len = %zu\n",
 			      STRINGIFY (STRNCPY), outer, inner, len);
 		      result = 1;
 		    }
@@ -424,8 +458,8 @@ do_test (void)
 		      || (inner - outer < len
 			  && STRLEN (dest + 1) != (inner - outer)))
 		    {
-		      printf ("%s+1 flunked for outer = %d, inner = %d, "
-			      "len = %Zd\n",
+		      printf ("%s+1 flunked for outer = %zu, inner = %zu, "
+			      "len = %zu\n",
 			      STRINGIFY (STRNCPY), outer, inner, len);
 		      result = 1;
 		    }
@@ -433,29 +467,33 @@ do_test (void)
 
 	      adr[inner] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* stpcpy/wcpcpy test */
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (inner = MAX (outer, nchars - 64); inner < nchars; ++inner)
+	  for (inner = MAX (outer, nchars64); inner < nchars; ++inner)
 	    {
 	      adr[inner] = L('\0');
 
 	      if ((STPCPY (dest, &adr[outer]) - dest) != inner - outer)
 		{
-		  printf ("%s flunked for outer = %d, inner = %d\n",
+		  printf ("%s flunked for outer = %zu, inner = %zu\n",
 			  STRINGIFY (STPCPY), outer, inner);
 		  result = 1;
 		}
 
 	      adr[inner] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* stpncpy/wcpncpy test */
       adr[nchars - 1] = L('T');
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars; outer >= max128; --outer)
 	{
 	  size_t len;
 
@@ -464,17 +502,19 @@ do_test (void)
 	      if (STPNCPY (dest, &adr[outer], len) != dest + len
 		  || MEMCMP (dest, &adr[outer], len) != 0)
 		{
-		  printf ("outer %s flunked for outer = %d, len = %Zd\n",
+		  printf ("outer %s flunked for outer = %zu, len = %zu\n",
 			  STRINGIFY (STPNCPY), outer, len);
 		  result = 1;
 		}
 	    }
+	  if (outer == 0)
+	    break;
 	}
       adr[nchars - 1] = L('\0');
 
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
+      for (outer = nchars - 1; outer >= max128; --outer)
 	{
-	  for (middle = MAX (outer, nchars - 64); middle < nchars; ++middle)
+	  for (middle = MAX (outer, nchars64); middle < nchars; ++middle)
 	    {
 	      adr[middle] = L('\0');
 
@@ -483,8 +523,8 @@ do_test (void)
 		  if ((STPNCPY (dest, &adr[outer], inner) - dest)
 		      != MIN (inner, middle - outer))
 		    {
-		      printf ("%s flunked for outer = %d, middle = %d, "
-			      "inner = %d\n",
+		      printf ("%s flunked for outer = %zu, middle = %zu, "
+			      "inner = %zu\n",
 			      STRINGIFY (STPNCPY), outer, middle, inner);
 		      result = 1;
 		    }
@@ -492,66 +532,84 @@ do_test (void)
 
 	      adr[middle] = L('T');
 	    }
+	  if (outer == 0)
+	    break;
 	}
 
       /* memcpy/wmemcpy test */
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
-	for (inner = 0; inner < nchars - outer; ++inner)
-	  if (MEMCPY (dest, &adr[outer], inner) !=  dest)
-	    {
-	      printf ("%s flunked for outer = %d, inner = %d\n",
-		      STRINGIFY (MEMCPY), outer, inner);
-	      result = 1;
-	    }
+      for (outer = nchars; outer >= max128; --outer)
+	{
+	  for (inner = 0; inner < nchars - outer; ++inner)
+	    if (MEMCPY (dest, &adr[outer], inner) !=  dest)
+	      {
+		printf ("%s flunked for outer = %zu, inner = %zu\n",
+			STRINGIFY (MEMCPY), outer, inner);
+		result = 1;
+	      }
+	  if (outer == 0)
+	    break;
+	}
 
       /* mempcpy/wmempcpy test */
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
-	for (inner = 0; inner < nchars - outer; ++inner)
-	  if (MEMPCPY (dest, &adr[outer], inner) !=  dest + inner)
-	    {
-	      printf ("%s flunked for outer = %d, inner = %d\n",
-		      STRINGIFY (MEMPCPY), outer, inner);
-	      result = 1;
-	    }
+      for (outer = nchars; outer >= max128; --outer)
+	{
+	  for (inner = 0; inner < nchars - outer; ++inner)
+	    if (MEMPCPY (dest, &adr[outer], inner) !=  dest + inner)
+	      {
+		printf ("%s flunked for outer = %zu, inner = %zu\n",
+			STRINGIFY (MEMPCPY), outer, inner);
+		result = 1;
+	      }
+	  if (outer == 0)
+	    break;
+	}
 
       /* This function only exists for single-byte characters.  */
 #ifndef WCSTEST
       /* memccpy test */
       memset (adr, '\0', nchars);
-      for (outer = nchars; outer >= MAX (0, nchars - 128); --outer)
-	for (inner = 0; inner < nchars - outer; ++inner)
-	  if (memccpy (dest, &adr[outer], L('\1'), inner) != NULL)
-	    {
-	      printf ("memccpy flunked full copy for outer = %d, inner = %d\n",
-		      outer, inner);
-	      result = 1;
-	    }
-      for (outer = nchars - 1; outer >= MAX (0, nchars - 128); --outer)
-	for (middle = 0; middle < nchars - outer; ++middle)
-	  {
-	    memset (dest, L('\2'), middle + 1);
-	    for (inner = 0; inner < middle; ++inner)
+      for (outer = nchars; outer >= max128; --outer)
+	{
+	  for (inner = 0; inner < nchars - outer; ++inner)
+	    if (memccpy (dest, &adr[outer], L('\1'), inner) != NULL)
 	      {
-		adr[outer + inner] = L('\1');
-
-		if (memccpy (dest, &adr[outer], '\1', middle + 128)
-		    !=  dest + inner + 1)
-		  {
-		    printf ("\
-memccpy flunked partial copy for outer = %d, middle = %d, inner = %d\n",
-			    outer, middle, inner);
-		    result = 1;
-		  }
-		else if (dest[inner + 1] != L('\2'))
-		  {
-		    printf ("\
-memccpy copied too much for outer = %d, middle = %d, inner = %d\n",
-			    outer, middle, inner);
-		    result = 1;
-		  }
-		adr[outer + inner] = L('\0');
+		printf ("memccpy flunked full copy for outer = %zu, inner = %zu\n",
+			outer, inner);
+		result = 1;
 	      }
-	  }
+	  if (outer == 0)
+	    break;
+	}
+      for (outer = nchars - 1; outer >= max128; --outer)
+	{
+	  for (middle = 0; middle < nchars - outer; ++middle)
+	    {
+	      memset (dest, L('\2'), middle + 1);
+	      for (inner = 0; inner < middle; ++inner)
+		{
+		  adr[outer + inner] = L('\1');
+
+		  if (memccpy (dest, &adr[outer], '\1', middle + 128)
+		      !=  dest + inner + 1)
+		    {
+		      printf ("\
+			      memccpy flunked partial copy for outer = %zu, middle = %zu, inner = %zu\n",
+			      outer, middle, inner);
+		      result = 1;
+		    }
+		  else if (dest[inner + 1] != L('\2'))
+		    {
+		      printf ("\
+			      memccpy copied too much for outer = %zu, middle = %zu, inner = %zu\n",
+			      outer, middle, inner);
+		      result = 1;
+		    }
+		  adr[outer + inner] = L('\0');
+		}
+	    }
+	  if (outer == 0)
+	    break;
+	}
 #endif
     }
 
diff --git a/support/namespace.h b/support/namespace.h
index 859c2fda3f..9eddb1a0e9 100644
--- a/support/namespace.h
+++ b/support/namespace.h
@@ -66,7 +66,9 @@ struct support_chroot_configuration
 {
   /* File contents.  The files are not created if the field is
      NULL.  */
-  const char *resolv_conf;
+  const char *resolv_conf;      /* /etc/resolv.conf.  */
+  const char *hosts;            /* /etc/hosts.  */
+  const char *host_conf;        /* /etc/host.conf.  */
 };
 
 /* The result of the creation of a chroot.  */
@@ -78,8 +80,11 @@ struct support_chroot
   /* Path to the chroot directory.  */
   char *path_chroot;
 
-  /* Path to the /etc/resolv.conf file.  */
-  char *path_resolv_conf;
+  /* Paths to files in the chroot.  These are absolute and outside of
+     the chroot.  */
+  char *path_resolv_conf;       /* /etc/resolv.conf.  */
+  char *path_hosts;             /* /etc/hosts.  */
+  char *path_host_conf;         /* /etc/host.conf.  */
 };
 
 /* Create a chroot environment.  The returned data should be freed
diff --git a/support/support_chroot.c b/support/support_chroot.c
index c0807b313a..f3ef551b05 100644
--- a/support/support_chroot.c
+++ b/support/support_chroot.c
@@ -24,6 +24,23 @@
 #include <support/test-driver.h>
 #include <support/xunistd.h>
 
+/* If CONTENTS is not NULL, write it to the file at DIRECTORY/RELPATH,
+   and store the name in *ABSPATH.  If CONTENTS is NULL, store NULL in
+   *ABSPATH.  */
+static void
+write_file (const char *directory, const char *relpath, const char *contents,
+            char **abspath)
+{
+  if (contents != NULL)
+    {
+      *abspath = xasprintf ("%s/%s", directory, relpath);
+      add_temp_file (*abspath);
+      support_write_file_string (*abspath, contents);
+    }
+  else
+    *abspath = NULL;
+}
+
 struct support_chroot *
 support_chroot_create (struct support_chroot_configuration conf)
 {
@@ -39,15 +56,10 @@ support_chroot_create (struct support_chroot_configuration conf)
   xmkdir (path_etc, 0777);
   add_temp_file (path_etc);
 
-  if (conf.resolv_conf != NULL)
-    {
-      /* Create an empty resolv.conf file.  */
-      chroot->path_resolv_conf = xasprintf ("%s/resolv.conf", path_etc);
-      add_temp_file (chroot->path_resolv_conf);
-      support_write_file_string (chroot->path_resolv_conf, conf.resolv_conf);
-    }
-  else
-    chroot->path_resolv_conf = NULL;
+  write_file (path_etc, "resolv.conf", conf.resolv_conf,
+              &chroot->path_resolv_conf);
+  write_file (path_etc, "hosts", conf.hosts, &chroot->path_hosts);
+  write_file (path_etc, "host.conf", conf.host_conf, &chroot->path_host_conf);
 
   free (path_etc);
 
@@ -67,5 +79,7 @@ support_chroot_free (struct support_chroot *chroot)
 {
   free (chroot->path_chroot);
   free (chroot->path_resolv_conf);
+  free (chroot->path_hosts);
+  free (chroot->path_host_conf);
   free (chroot);
 }
diff --git a/sysdeps/aarch64/multiarch/Makefile b/sysdeps/aarch64/multiarch/Makefile
index 78d52c717d..9aa1e79a80 100644
--- a/sysdeps/aarch64/multiarch/Makefile
+++ b/sysdeps/aarch64/multiarch/Makefile
@@ -1,3 +1,4 @@
 ifeq ($(subdir),string)
-sysdep_routines += memcpy_generic memcpy_thunderx
+sysdep_routines += memcpy_generic memcpy_thunderx memcpy_falkor \
+		   memmove_falkor
 endif
diff --git a/sysdeps/aarch64/multiarch/ifunc-impl-list.c b/sysdeps/aarch64/multiarch/ifunc-impl-list.c
index 32056bcec3..2cb74d5b43 100644
--- a/sysdeps/aarch64/multiarch/ifunc-impl-list.c
+++ b/sysdeps/aarch64/multiarch/ifunc-impl-list.c
@@ -25,7 +25,7 @@
 #include <stdio.h>
 
 /* Maximum number of IFUNC implementations.  */
-#define MAX_IFUNC	2
+#define MAX_IFUNC	3
 
 size_t
 __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
@@ -40,9 +40,11 @@ __libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,
   /* Support sysdeps/aarch64/multiarch/memcpy.c and memmove.c.  */
   IFUNC_IMPL (i, name, memcpy,
 	      IFUNC_IMPL_ADD (array, i, memcpy, 1, __memcpy_thunderx)
+	      IFUNC_IMPL_ADD (array, i, memcpy, 1, __memcpy_falkor)
 	      IFUNC_IMPL_ADD (array, i, memcpy, 1, __memcpy_generic))
   IFUNC_IMPL (i, name, memmove,
 	      IFUNC_IMPL_ADD (array, i, memmove, 1, __memmove_thunderx)
+	      IFUNC_IMPL_ADD (array, i, memmove, 1, __memmove_falkor)
 	      IFUNC_IMPL_ADD (array, i, memmove, 1, __memmove_generic))
 
   return i;
diff --git a/sysdeps/aarch64/multiarch/memcpy.c b/sysdeps/aarch64/multiarch/memcpy.c
index 9f73efbba7..b395df1c63 100644
--- a/sysdeps/aarch64/multiarch/memcpy.c
+++ b/sysdeps/aarch64/multiarch/memcpy.c
@@ -30,9 +30,14 @@ extern __typeof (__redirect_memcpy) __libc_memcpy;
 
 extern __typeof (__redirect_memcpy) __memcpy_generic attribute_hidden;
 extern __typeof (__redirect_memcpy) __memcpy_thunderx attribute_hidden;
+extern __typeof (__redirect_memcpy) __memcpy_falkor attribute_hidden;
 
 libc_ifunc (__libc_memcpy,
-            IS_THUNDERX (midr) ? __memcpy_thunderx : __memcpy_generic);
+            (IS_THUNDERX (midr)
+	     ? __memcpy_thunderx
+	     : (IS_FALKOR (midr)
+		? __memcpy_falkor
+		: __memcpy_generic)));
 
 # undef memcpy
 strong_alias (__libc_memcpy, memcpy);
diff --git a/sysdeps/aarch64/multiarch/memcpy_falkor.S b/sysdeps/aarch64/multiarch/memcpy_falkor.S
new file mode 100644
index 0000000000..dea4f225ee
--- /dev/null
+++ b/sysdeps/aarch64/multiarch/memcpy_falkor.S
@@ -0,0 +1,184 @@
+/* Optimized memcpy for Qualcomm Falkor processor.
+   Copyright (C) 2017 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/* Assumptions:
+
+   ARMv8-a, AArch64, falkor, unaligned accesses.  */
+
+#define dstin	x0
+#define src	x1
+#define count	x2
+#define dst	x3
+#define srcend	x4
+#define dstend	x5
+#define A_l	x6
+#define A_lw	w6
+#define A_h	x7
+#define A_hw	w7
+#define tmp1	x14
+
+/* Copies are split into 3 main cases:
+
+   1. Small copies of up to 32 bytes
+   2. Medium copies of 33..128 bytes which are fully unrolled
+   3. Large copies of more than 128 bytes.
+
+   Large copies align the sourceto a quad word and use an unrolled loop
+   processing 64 bytes per iteration.
+
+   FALKOR-SPECIFIC DESIGN:
+
+   The smallest copies (32 bytes or less) focus on optimal pipeline usage,
+   which is why the redundant copies of 0-3 bytes have been replaced with
+   conditionals, since the former would unnecessarily break across multiple
+   issue groups.  The medium copy group has been enlarged to 128 bytes since
+   bumping up the small copies up to 32 bytes allows us to do that without
+   cost and also allows us to reduce the size of the prep code before loop64.
+
+   All copies are done only via two registers r6 and r7.  This is to ensure
+   that all loads hit a single hardware prefetcher which can get correctly
+   trained to prefetch a single stream.
+
+   The non-temporal stores help optimize cache utilization.  */
+
+#if IS_IN (libc)
+ENTRY_ALIGN (__memcpy_falkor, 6)
+
+	cmp	count, 32
+	add	srcend, src, count
+	add	dstend, dstin, count
+	b.ls	L(copy32)
+	ldp	A_l, A_h, [src]
+	cmp	count, 128
+	stp	A_l, A_h, [dstin]
+	b.hi	L(copy_long)
+
+	/* Medium copies: 33..128 bytes.  */
+	sub	tmp1, count, 1
+	ldp	A_l, A_h, [src, 16]
+	stp	A_l, A_h, [dstin, 16]
+	tbz	tmp1, 6, 1f
+	ldp	A_l, A_h, [src, 32]
+	stp	A_l, A_h, [dstin, 32]
+	ldp	A_l, A_h, [src, 48]
+	stp	A_l, A_h, [dstin, 48]
+	ldp	A_l, A_h, [srcend, -64]
+	stp	A_l, A_h, [dstend, -64]
+	ldp	A_l, A_h, [srcend, -48]
+	stp	A_l, A_h, [dstend, -48]
+1:
+	ldp	A_l, A_h, [srcend, -32]
+	stp	A_l, A_h, [dstend, -32]
+	ldp	A_l, A_h, [srcend, -16]
+	stp	A_l, A_h, [dstend, -16]
+	ret
+
+	.p2align 4
+	/* Small copies: 0..32 bytes.  */
+L(copy32):
+	/* 16-32 */
+	cmp	count, 16
+	b.lo	1f
+	ldp	A_l, A_h, [src]
+	stp	A_l, A_h, [dstin]
+	ldp	A_l, A_h, [srcend, -16]
+	stp	A_l, A_h, [dstend, -16]
+	ret
+	.p2align 4
+1:
+	/* 8-15 */
+	tbz	count, 3, 1f
+	ldr	A_l, [src]
+	str	A_l, [dstin]
+	ldr	A_l, [srcend, -8]
+	str	A_l, [dstend, -8]
+	ret
+	.p2align 4
+1:
+	/* 4-7 */
+	tbz	count, 2, 1f
+	ldr	A_lw, [src]
+	str	A_lw, [dstin]
+	ldr	A_lw, [srcend, -4]
+	str	A_lw, [dstend, -4]
+	ret
+	.p2align 4
+1:
+	/* 2-3 */
+	tbz	count, 1, 1f
+	ldrh	A_lw, [src]
+	strh	A_lw, [dstin]
+	ldrh	A_lw, [srcend, -2]
+	strh	A_lw, [dstend, -2]
+	ret
+	.p2align 4
+1:
+	/* 0-1 */
+	tbz	count, 0, 1f
+	ldrb	A_lw, [src]
+	strb	A_lw, [dstin]
+1:
+	ret
+
+	/* Align SRC to 16 bytes and copy; that way at least one of the
+	   accesses is aligned throughout the copy sequence.
+
+	   The count is off by 0 to 15 bytes, but this is OK because we trim
+	   off the last 64 bytes to copy off from the end.  Due to this the
+	   loop never runs out of bounds.  */
+	.p2align 6
+L(copy_long):
+	sub	count, count, 64 + 16
+	and	tmp1, src, 15
+	bic	src, src, 15
+	sub	dst, dstin, tmp1
+	add	count, count, tmp1
+
+L(loop64):
+	ldp	A_l, A_h, [src, 16]!
+	stnp	A_l, A_h, [dst, 16]
+	ldp	A_l, A_h, [src, 16]!
+	subs	count, count, 64
+	stnp	A_l, A_h, [dst, 32]
+	ldp	A_l, A_h, [src, 16]!
+	stnp	A_l, A_h, [dst, 48]
+	ldp	A_l, A_h, [src, 16]!
+	stnp	A_l, A_h, [dst, 64]
+	add	dst, dst, 64
+	b.hi	L(loop64)
+
+	/* Write the last full set of 64 bytes.  The remainder is at most 64
+	   bytes, so it is safe to always copy 64 bytes from the end even if
+	   there is just 1 byte left.  */
+L(last64):
+	ldp	A_l, A_h, [srcend, -64]
+	stnp	A_l, A_h, [dstend, -64]
+	ldp	A_l, A_h, [srcend, -48]
+	stnp	A_l, A_h, [dstend, -48]
+	ldp	A_l, A_h, [srcend, -32]
+	stnp	A_l, A_h, [dstend, -32]
+	ldp	A_l, A_h, [srcend, -16]
+	stnp	A_l, A_h, [dstend, -16]
+	ret
+
+END (__memcpy_falkor)
+libc_hidden_builtin_def (__memcpy_falkor)
+#endif
diff --git a/sysdeps/aarch64/multiarch/memmove.c b/sysdeps/aarch64/multiarch/memmove.c
index 34c6b29bd5..016f03ee50 100644
--- a/sysdeps/aarch64/multiarch/memmove.c
+++ b/sysdeps/aarch64/multiarch/memmove.c
@@ -30,9 +30,14 @@ extern __typeof (__redirect_memmove) __libc_memmove;
 
 extern __typeof (__redirect_memmove) __memmove_generic attribute_hidden;
 extern __typeof (__redirect_memmove) __memmove_thunderx attribute_hidden;
+extern __typeof (__redirect_memmove) __memmove_falkor attribute_hidden;
 
 libc_ifunc (__libc_memmove,
-            IS_THUNDERX (midr) ? __memmove_thunderx : __memmove_generic);
+            (IS_THUNDERX (midr)
+	     ? __memmove_thunderx
+	     : (IS_FALKOR (midr)
+		? __memmove_falkor
+		: __memmove_generic)));
 
 # undef memmove
 strong_alias (__libc_memmove, memmove);
diff --git a/sysdeps/aarch64/multiarch/memmove_falkor.S b/sysdeps/aarch64/multiarch/memmove_falkor.S
new file mode 100644
index 0000000000..3a4e6a2a8e
--- /dev/null
+++ b/sysdeps/aarch64/multiarch/memmove_falkor.S
@@ -0,0 +1,232 @@
+/* Copyright (C) 2017 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/* Assumptions: ARMv8-a, AArch64, falkor, unaligned accesses.  */
+
+#define dstin	x0
+#define src	x1
+#define count	x2
+#define dstlen	x3
+#define dst	x3
+#define srcend	x4
+#define dstend	x5
+#define A_l	x6
+#define A_lw	w6
+#define A_h	x7
+#define A_hw	w7
+#define B_l	x8
+#define B_lw	w8
+#define B_h	x9
+#define C_l	x10
+#define C_h	x11
+#define D_l	x12
+#define D_h	x13
+#define E_l	src
+#define E_h	count
+#define F_l	srcend
+#define F_h	dst
+#define tmp1	x14
+
+/* Alias with A_l and A_h to train the prefetcher.  */
+#define Q_l	x22
+#define Q_h	x23
+
+/* RATIONALE:
+
+   The copy has 4 distinct parts:
+   * Small copies of 16 bytes and under
+   * Medium sized copies of 17-96 bytes
+   * Large copies where the source address is higher than the destination
+     (forward copies)
+   * Large copies where the destination address is higher than the source
+     (copy backward, or move).
+
+   We use only two registerpairs x6,x7 and x22,x23 for the copies and copy 32
+   bytes at a time to correctly train the hardware prefetcher for better
+   throughput.  */
+ENTRY_ALIGN (__memmove_falkor, 6)
+
+	sub	tmp1, dstin, src
+	add	srcend, src, count
+	add	dstend, dstin, count
+	cmp	count, 96
+	ccmp	tmp1, count, 2, hi
+	b.lo	L(move_long)
+
+	cmp	count, 16
+	b.ls	L(copy16)
+	cmp	count, 96
+	b.hi	L(copy_long)
+
+	/* Medium copies: 17..96 bytes.  */
+	sub	tmp1, count, 1
+	ldp	A_l, A_h, [src]
+	tbnz	tmp1, 6, L(copy96)
+	ldp	D_l, D_h, [srcend, -16]
+	tbz	tmp1, 5, 1f
+	ldp	B_l, B_h, [src, 16]
+	ldp	C_l, C_h, [srcend, -32]
+	stp	B_l, B_h, [dstin, 16]
+	stp	C_l, C_h, [dstend, -32]
+1:
+	stp	A_l, A_h, [dstin]
+	stp	D_l, D_h, [dstend, -16]
+	ret
+
+	.p2align 4
+	/* Small copies: 0..16 bytes.  */
+L(copy16):
+	cmp	count, 8
+	b.lo	1f
+	ldr	A_l, [src]
+	ldr	A_h, [srcend, -8]
+	str	A_l, [dstin]
+	str	A_h, [dstend, -8]
+	ret
+	.p2align 4
+1:
+	/* 4-7 */
+	tbz	count, 2, 1f
+	ldr	A_lw, [src]
+	ldr	A_hw, [srcend, -4]
+	str	A_lw, [dstin]
+	str	A_hw, [dstend, -4]
+	ret
+	.p2align 4
+1:
+	/* 2-3 */
+	tbz	count, 1, 1f
+	ldrh	A_lw, [src]
+	ldrh	A_hw, [srcend, -2]
+	strh	A_lw, [dstin]
+	strh	A_hw, [dstend, -2]
+	ret
+	.p2align 4
+1:
+	/* 0-1 */
+	tbz	count, 0, 1f
+	ldrb	A_lw, [src]
+	strb	A_lw, [dstin]
+1:	ret
+
+	.p2align 4
+	/* Copy 64..96 bytes.  Copy 64 bytes from the start and
+	   32 bytes from the end.  */
+L(copy96):
+	ldp	B_l, B_h, [src, 16]
+	ldp	C_l, C_h, [src, 32]
+	ldp	D_l, D_h, [src, 48]
+	ldp	E_l, E_h, [srcend, -32]
+	ldp	F_l, F_h, [srcend, -16]
+	stp	A_l, A_h, [dstin]
+	stp	B_l, B_h, [dstin, 16]
+	stp	C_l, C_h, [dstin, 32]
+	stp	D_l, D_h, [dstin, 48]
+	stp	E_l, E_h, [dstend, -32]
+	stp	F_l, F_h, [dstend, -16]
+	ret
+
+	/* Align SRC to 16 byte alignment so that we don't cross cache line
+	   boundaries on both loads and stores.  There are at least 96 bytes
+	   to copy, so copy 16 bytes unaligned and then align.  The loop
+	   copies 32 bytes per iteration and prefetches one iteration ahead.  */
+
+	.p2align 4
+L(copy_long):
+	sub	count, count, 64 + 16	/* Test and readjust count.  */
+	mov	B_l, Q_l
+	mov	B_h, Q_h
+	ldp	A_l, A_h, [src]
+	and	tmp1, src, 15
+	bic	src, src, 15
+	sub	dst, dstin, tmp1
+	add	count, count, tmp1	/* Count is now 16 too large.  */
+	ldp	Q_l, Q_h, [src, 16]!
+	stp	A_l, A_h, [dstin]
+	ldp	A_l, A_h, [src, 16]!
+
+L(loop64):
+	subs	count, count, 32
+	stp	Q_l, Q_h, [dst, 16]
+	ldp	Q_l, Q_h, [src, 16]!
+	stp	A_l, A_h, [dst, 32]!
+	ldp	A_l, A_h, [src, 16]!
+	b.hi	L(loop64)
+
+	/* Write the last full set of 32 bytes.  The remainder is at most 32
+	   bytes, so it is safe to always copy 32 bytes from the end even if
+	   there is just 1 byte left.  */
+L(last64):
+	ldp	C_l, C_h, [srcend, -32]
+	stp	Q_l, Q_h, [dst, 16]
+	ldp	Q_l, Q_h, [srcend, -16]
+	stp	A_l, A_h, [dst, 32]
+	stp	C_l, C_h, [dstend, -32]
+	stp	Q_l, Q_h, [dstend, -16]
+	mov	Q_l, B_l
+	mov	Q_h, B_h
+	ret
+
+	.p2align 4
+L(move_long):
+	cbz	tmp1, 3f
+
+	mov	B_l, Q_l
+	mov	B_h, Q_h
+
+	/* Align SRCEND to 16 byte alignment so that we don't cross cache line
+	   boundaries on both loads and stores.  There are at least 96 bytes
+	   to copy, so copy 16 bytes unaligned and then align.  The loop
+	   copies 32 bytes per iteration and prefetches one iteration ahead.  */
+
+	ldp	A_l, A_h, [srcend, -16]
+	and	tmp1, srcend, 15
+	sub	srcend, srcend, tmp1
+	ldp	Q_l, Q_h, [srcend, -16]!
+	stp	A_l, A_h, [dstend, -16]
+	sub	count, count, tmp1
+	ldp	A_l, A_h, [srcend, -16]!
+	sub	dstend, dstend, tmp1
+	sub	count, count, 64
+
+1:
+	subs	count, count, 32
+	stp	Q_l, Q_h, [dstend, -16]
+	ldp	Q_l, Q_h, [srcend, -16]!
+	stp	A_l, A_h, [dstend, -32]!
+	ldp	A_l, A_h, [srcend, -16]!
+	b.hi	1b
+
+	/* Write the last full set of 32 bytes.  The remainder is at most 32
+	   bytes, so it is safe to always copy 32 bytes from the start even if
+	   there is just 1 byte left.  */
+2:
+	ldp	C_l, C_h, [src, 16]
+	stp	Q_l, Q_h, [dstend, -16]
+	ldp	Q_l, Q_h, [src]
+	stp	A_l, A_h, [dstend, -32]
+	stp	C_l, C_h, [dstin, 16]
+	stp	Q_l, Q_h, [dstin]
+	mov	Q_l, B_l
+	mov	Q_h, B_h
+3:	ret
+
+END (__memmove_falkor)
+libc_hidden_builtin_def (__memmove_falkor)
diff --git a/sysdeps/i386/i686/fpu/multiarch/libm-test-ulps b/sysdeps/i386/i686/fpu/multiarch/libm-test-ulps
index 81dd1a09ea..053f5ec972 100644
--- a/sysdeps/i386/i686/fpu/multiarch/libm-test-ulps
+++ b/sysdeps/i386/i686/fpu/multiarch/libm-test-ulps
@@ -58,7 +58,7 @@ double: 1
 float128: 2
 idouble: 1
 ifloat128: 2
-ildouble: 4
+ildouble: 5
 ldouble: 3
 
 Function: "asin":
@@ -1154,8 +1154,8 @@ float128: 4
 idouble: 3
 ifloat: 3
 ifloat128: 4
-ildouble: 7
-ldouble: 7
+ildouble: 8
+ldouble: 8
 
 Function: Imaginary part of "clog10_upward":
 double: 1
@@ -2013,8 +2013,8 @@ double: 3
 float: 4
 idouble: 3
 ifloat: 4
-ildouble: 5
-ldouble: 5
+ildouble: 6
+ldouble: 6
 
 Function: "hypot":
 double: 1
@@ -2205,8 +2205,8 @@ float128: 8
 idouble: 3
 ifloat: 4
 ifloat128: 8
-ildouble: 5
-ldouble: 5
+ildouble: 6
+ldouble: 6
 
 Function: "log":
 double: 1
diff --git a/sysdeps/ieee754/dbl-64/s_nearbyint.c b/sysdeps/ieee754/dbl-64/s_nearbyint.c
index dec0c5d6ee..6e3f8316b1 100644
--- a/sysdeps/ieee754/dbl-64/s_nearbyint.c
+++ b/sysdeps/ieee754/dbl-64/s_nearbyint.c
@@ -48,7 +48,7 @@ __nearbyint (double x)
       if (j0 < 0)
 	{
 	  libc_feholdexcept (&env);
-	  w = TWO52[sx] + x;
+	  w = TWO52[sx] + math_opt_barrier (x);
 	  t = w - TWO52[sx];
 	  math_force_eval (t);
 	  libc_fesetenv (&env);
@@ -65,7 +65,7 @@ __nearbyint (double x)
 	return x;                       /* x is integral */
     }
   libc_feholdexcept (&env);
-  w = TWO52[sx] + x;
+  w = TWO52[sx] + math_opt_barrier (x);
   t = w - TWO52[sx];
   math_force_eval (t);
   libc_fesetenv (&env);
diff --git a/sysdeps/ieee754/dbl-64/wordsize-64/s_nearbyint.c b/sysdeps/ieee754/dbl-64/wordsize-64/s_nearbyint.c
index 8293819981..7d135b54e4 100644
--- a/sysdeps/ieee754/dbl-64/wordsize-64/s_nearbyint.c
+++ b/sysdeps/ieee754/dbl-64/wordsize-64/s_nearbyint.c
@@ -42,9 +42,9 @@ __nearbyint(double x)
 	if(__builtin_expect(j0<52, 1)) {
 	    if(j0<0) {
 		libc_feholdexcept (&env);
-		double w = TWO52[sx]+x;
+		double w = TWO52[sx] + math_opt_barrier (x);
 		double t =  w-TWO52[sx];
-		math_opt_barrier(t);
+		math_force_eval (t);
 		libc_fesetenv (&env);
 		return __copysign (t, x);
 	    }
@@ -53,9 +53,9 @@ __nearbyint(double x)
 	    else return x;		/* x is integral */
 	}
 	libc_feholdexcept (&env);
-	double w = TWO52[sx]+x;
+	double w = TWO52[sx] + math_opt_barrier (x);
 	double t = w-TWO52[sx];
-	math_opt_barrier (t);
+	math_force_eval (t);
 	libc_fesetenv (&env);
 	return t;
 }
diff --git a/sysdeps/ieee754/flt-32/s_nearbyintf.c b/sysdeps/ieee754/flt-32/s_nearbyintf.c
index 5aebefafcf..b06df6b3c8 100644
--- a/sysdeps/ieee754/flt-32/s_nearbyintf.c
+++ b/sysdeps/ieee754/flt-32/s_nearbyintf.c
@@ -37,7 +37,7 @@ __nearbyintf(float x)
 	if(j0<23) {
 	    if(j0<0) {
 		libc_feholdexceptf (&env);
-		w = TWO23[sx]+x;
+		w = TWO23[sx] + math_opt_barrier (x);
 		t =  w-TWO23[sx];
 		math_force_eval (t);
 		libc_fesetenvf (&env);
@@ -50,7 +50,7 @@ __nearbyintf(float x)
 	    else return x;		/* x is integral */
 	}
 	libc_feholdexceptf (&env);
-	w = TWO23[sx]+x;
+	w = TWO23[sx] + math_opt_barrier (x);
 	t = w-TWO23[sx];
 	math_force_eval (t);
 	libc_fesetenvf (&env);
diff --git a/sysdeps/ieee754/ldbl-128/s_nearbyintl.c b/sysdeps/ieee754/ldbl-128/s_nearbyintl.c
index 1565a8183f..98a33d24a7 100644
--- a/sysdeps/ieee754/ldbl-128/s_nearbyintl.c
+++ b/sysdeps/ieee754/ldbl-128/s_nearbyintl.c
@@ -45,7 +45,7 @@ _Float128 __nearbyintl(_Float128 x)
 	if(j0<112) {
 	    if(j0<0) {
 		feholdexcept (&env);
-	        w = TWO112[sx]+x;
+	        w = TWO112[sx] + math_opt_barrier (x);
 	        t = w-TWO112[sx];
 		math_force_eval (t);
 	        fesetenv (&env);
@@ -58,7 +58,7 @@ _Float128 __nearbyintl(_Float128 x)
 	    else return x;		/* x is integral */
 	}
 	feholdexcept (&env);
-	w = TWO112[sx]+x;
+	w = TWO112[sx] + math_opt_barrier (x);
 	t = w-TWO112[sx];
 	math_force_eval (t);
 	fesetenv (&env);
diff --git a/sysdeps/ieee754/ldbl-128ibm/bits/iscanonical.h b/sysdeps/ieee754/ldbl-128ibm/bits/iscanonical.h
index 7ddb368d26..f756857c03 100644
--- a/sysdeps/ieee754/ldbl-128ibm/bits/iscanonical.h
+++ b/sysdeps/ieee754/ldbl-128ibm/bits/iscanonical.h
@@ -37,5 +37,22 @@ extern int __iscanonicall (long double __x)
    conversion, before being discarded; in IBM long double, there are
    encodings that are not consistently handled as corresponding to any
    particular value of the type, and we return 0 for those.  */
-# define iscanonical(x) __MATH_TG ((x), __iscanonical, (x))
-#endif
+# ifndef __cplusplus
+#  define iscanonical(x) __MATH_TG ((x), __iscanonical, (x))
+# else
+/* In C++ mode, __MATH_TG cannot be used, because it relies on
+   __builtin_types_compatible_p, which is a C-only builtin.  On the
+   other hand, overloading provides the means to distinguish between
+   the floating-point types.  The overloading resolution will match
+   the correct parameter (regardless of type qualifiers (i.e.: const
+   and volatile)).  */
+extern "C++" {
+inline int iscanonical (float __val) { return __iscanonicalf (__val); }
+inline int iscanonical (double __val) { return __iscanonical (__val); }
+inline int iscanonical (long double __val) { return __iscanonicall (__val); }
+#  if __HAVE_DISTINCT_FLOAT128
+inline int iscanonical (_Float128 __val) { return __iscanonicalf128 (__val); }
+#  endif
+}
+# endif /* __cplusplus */
+#endif /* __NO_LONG_DOUBLE_MATH */
diff --git a/sysdeps/ieee754/ldbl-96/bits/iscanonical.h b/sysdeps/ieee754/ldbl-96/bits/iscanonical.h
index 4a4f4ad024..cfa36a0c2a 100644
--- a/sysdeps/ieee754/ldbl-96/bits/iscanonical.h
+++ b/sysdeps/ieee754/ldbl-96/bits/iscanonical.h
@@ -34,4 +34,21 @@ extern int __iscanonicall (long double __x)
    conversion, before being discarded; in extended precision, there
    are encodings that are not consistently handled as corresponding to
    any particular value of the type, and we return 0 for those.  */
-#define iscanonical(x) __MATH_TG ((x), __iscanonical, (x))
+#ifndef __cplusplus
+# define iscanonical(x) __MATH_TG ((x), __iscanonical, (x))
+#else
+/* In C++ mode, __MATH_TG cannot be used, because it relies on
+   __builtin_types_compatible_p, which is a C-only builtin.  On the
+   other hand, overloading provides the means to distinguish between
+   the floating-point types.  The overloading resolution will match
+   the correct parameter (regardless of type qualifiers (i.e.: const
+   and volatile)).  */
+extern "C++" {
+inline int iscanonical (float __val) { return __iscanonicalf (__val); }
+inline int iscanonical (double __val) { return __iscanonical (__val); }
+inline int iscanonical (long double __val) { return __iscanonicall (__val); }
+# if __HAVE_DISTINCT_FLOAT128
+inline int iscanonical (_Float128 __val) { return __iscanonicalf128 (__val); }
+# endif
+}
+#endif /* __cplusplus */
diff --git a/sysdeps/posix/getaddrinfo.c b/sysdeps/posix/getaddrinfo.c
index efa7118498..2c4b6d6793 100644
--- a/sysdeps/posix/getaddrinfo.c
+++ b/sysdeps/posix/getaddrinfo.c
@@ -241,46 +241,43 @@ convert_hostent_to_gaih_addrtuple (const struct addrinfo *req,
 
 #define gethosts(_family, _type) \
  {									      \
-  int herrno;								      \
   struct hostent th;							      \
-  struct hostent *h;							      \
   char *localcanon = NULL;						      \
   no_data = 0;								      \
-  while (1) {								      \
-    rc = 0;								      \
-    status = DL_CALL_FCT (fct, (name, _family, &th,			      \
-				tmpbuf->data, tmpbuf->length,		      \
-				&rc, &herrno, NULL, &localcanon));	      \
-    if (rc != ERANGE || herrno != NETDB_INTERNAL)			      \
-      break;								      \
-    if (!scratch_buffer_grow (tmpbuf))					      \
-      {									      \
-	result = -EAI_MEMORY;						      \
-	goto free_and_return;						      \
-      }									      \
-  }									      \
-  if (status == NSS_STATUS_SUCCESS && rc == 0)				      \
-    h = &th;								      \
-  else									      \
-    h = NULL;								      \
-  if (rc != 0)								      \
+  while (1)								      \
     {									      \
-      if (herrno == NETDB_INTERNAL)					      \
+      status = DL_CALL_FCT (fct, (name, _family, &th,			      \
+				  tmpbuf->data, tmpbuf->length,		      \
+				  &errno, &h_errno, NULL, &localcanon));      \
+      if (status != NSS_STATUS_TRYAGAIN || h_errno != NETDB_INTERNAL	      \
+	  || errno != ERANGE)						      \
+	break;								      \
+      if (!scratch_buffer_grow (tmpbuf))				      \
+	{								      \
+	  __resolv_context_enable_inet6 (res_ctx, res_enable_inet6);	      \
+	  __resolv_context_put (res_ctx);				      \
+	  result = -EAI_MEMORY;						      \
+	  goto free_and_return;						      \
+	}								      \
+    }									      \
+  if (status == NSS_STATUS_NOTFOUND					      \
+      || status == NSS_STATUS_TRYAGAIN || status == NSS_STATUS_UNAVAIL)	      \
+    {									      \
+      if (h_errno == NETDB_INTERNAL)					      \
 	{								      \
-	  __set_h_errno (herrno);					      \
 	  __resolv_context_enable_inet6 (res_ctx, res_enable_inet6);	      \
 	  __resolv_context_put (res_ctx);				      \
 	  result = -EAI_SYSTEM;						      \
 	  goto free_and_return;						      \
 	}								      \
-      if (herrno == TRY_AGAIN)						      \
+      if (h_errno == TRY_AGAIN)						      \
 	no_data = EAI_AGAIN;						      \
       else								      \
-	no_data = herrno == NO_DATA;					      \
+	no_data = h_errno == NO_DATA;					      \
     }									      \
-  else if (h != NULL)							      \
+  else if (status == NSS_STATUS_SUCCESS)				      \
     {									      \
-      if (!convert_hostent_to_gaih_addrtuple (req, _family,h, &addrmem))      \
+      if (!convert_hostent_to_gaih_addrtuple (req, _family, &th, &addrmem))   \
 	{								      \
 	  __resolv_context_enable_inet6 (res_ctx, res_enable_inet6);	      \
 	  __resolv_context_put (res_ctx);				      \
@@ -332,10 +329,8 @@ getcanonname (service_user *nip, struct gaih_addrtuple *at, const char *name)
   if (cfct != NULL)
     {
       char buf[256];
-      int herrno;
-      int rc;
       if (DL_CALL_FCT (cfct, (at->name ?: name, buf, sizeof (buf),
-			      &s, &rc, &herrno)) != NSS_STATUS_SUCCESS)
+			      &s, &errno, &h_errno)) != NSS_STATUS_SUCCESS)
 	/* If the canonical name cannot be determined, use the passed
 	   string.  */
 	s = (char *) name;
@@ -351,7 +346,6 @@ gaih_inet (const char *name, const struct gaih_service *service,
   const struct gaih_typeproto *tp = gaih_inet_typeproto;
   struct gaih_servtuple *st = (struct gaih_servtuple *) &nullserv;
   struct gaih_addrtuple *at = NULL;
-  int rc;
   bool got_ipv6 = false;
   const char *canon = NULL;
   const char *orig_name = name;
@@ -393,7 +387,8 @@ gaih_inet (const char *name, const struct gaih_service *service,
 	      st = (struct gaih_servtuple *)
 		alloca_account (sizeof (struct gaih_servtuple), alloca_used);
 
-	      if ((rc = gaih_inet_serv (service->name, tp, req, st, tmpbuf)))
+	      int rc = gaih_inet_serv (service->name, tp, req, st, tmpbuf);
+	      if (__glibc_unlikely (rc != 0))
 		return rc;
 	    }
 	  else
@@ -418,13 +413,9 @@ gaih_inet (const char *name, const struct gaih_service *service,
 		    alloca_account (sizeof (struct gaih_servtuple),
 				    alloca_used);
 
-		  if ((rc = gaih_inet_serv (service->name,
-					    tp, req, newp, tmpbuf)))
-		    {
-		      if (rc)
-			continue;
-		      return rc;
-		    }
+		  if (gaih_inet_serv (service->name,
+				      tp, req, newp, tmpbuf) != 0)
+		    continue;
 
 		  *pst = newp;
 		  pst = &(newp->next);
@@ -497,7 +488,7 @@ gaih_inet (const char *name, const struct gaih_service *service,
 	    idn_flags |= IDNA_USE_STD3_ASCII_RULES;
 
 	  char *p = NULL;
-	  rc = __idna_to_ascii_lz (name, &p, idn_flags);
+	  int rc = __idna_to_ascii_lz (name, &p, idn_flags);
 	  if (rc != IDNA_SUCCESS)
 	    {
 	      /* No need to jump to free_and_return here.  */
@@ -598,14 +589,13 @@ gaih_inet (const char *name, const struct gaih_service *service,
 	      int rc;
 	      struct hostent th;
 	      struct hostent *h;
-	      int herrno;
 
 	      while (1)
 		{
 		  rc = __gethostbyname2_r (name, AF_INET, &th,
 					   tmpbuf->data, tmpbuf->length,
-					   &h, &herrno);
-		  if (rc != ERANGE || herrno != NETDB_INTERNAL)
+					   &h, &h_errno);
+		  if (rc != ERANGE || h_errno != NETDB_INTERNAL)
 		    break;
 		  if (!scratch_buffer_grow (tmpbuf))
 		    {
@@ -627,15 +617,20 @@ gaih_inet (const char *name, const struct gaih_service *service,
 			}
 		      *pat = addrmem;
 		    }
+		  else
+		    {
+		      if (h_errno == NO_DATA)
+			result = -EAI_NODATA;
+		      else
+			result = -EAI_NONAME;
+		      goto free_and_return;
+		    }
 		}
 	      else
 		{
-		  if (herrno == NETDB_INTERNAL)
-		    {
-		      __set_h_errno (herrno);
-		      result = -EAI_SYSTEM;
-		    }
-		  else if (herrno == TRY_AGAIN)
+		  if (h_errno == NETDB_INTERNAL)
+		    result = -EAI_SYSTEM;
+		  else if (h_errno == TRY_AGAIN)
 		    result = -EAI_AGAIN;
 		  else
 		    /* We made requests but they turned out no data.
@@ -658,8 +653,7 @@ gaih_inet (const char *name, const struct gaih_service *service,
 	    {
 	      /* Try to use nscd.  */
 	      struct nscd_ai_result *air = NULL;
-	      int herrno;
-	      int err = __nscd_getai (name, &air, &herrno);
+	      int err = __nscd_getai (name, &air, &h_errno);
 	      if (air != NULL)
 		{
 		  /* Transform into gaih_addrtuple list.  */
@@ -750,9 +744,9 @@ gaih_inet (const char *name, const struct gaih_service *service,
 		goto free_and_return;
 	      else if (__nss_not_use_nscd_hosts == 0)
 		{
-		  if (herrno == NETDB_INTERNAL && errno == ENOMEM)
+		  if (h_errno == NETDB_INTERNAL && errno == ENOMEM)
 		    result = -EAI_MEMORY;
-		  else if (herrno == TRY_AGAIN)
+		  else if (h_errno == TRY_AGAIN)
 		    result = -EAI_AGAIN;
 		  else
 		    result = -EAI_SYSTEM;
@@ -791,24 +785,21 @@ gaih_inet (const char *name, const struct gaih_service *service,
 
 	      if (fct4 != NULL)
 		{
-		  int herrno;
-
 		  while (1)
 		    {
-		      rc = 0;
 		      status = DL_CALL_FCT (fct4, (name, pat,
 						   tmpbuf->data, tmpbuf->length,
-						   &rc, &herrno,
+						   &errno, &h_errno,
 						   NULL));
 		      if (status == NSS_STATUS_SUCCESS)
 			break;
 		      if (status != NSS_STATUS_TRYAGAIN
-			  || rc != ERANGE || herrno != NETDB_INTERNAL)
+			  || errno != ERANGE || h_errno != NETDB_INTERNAL)
 			{
-			  if (herrno == TRY_AGAIN)
+			  if (h_errno == TRY_AGAIN)
 			    no_data = EAI_AGAIN;
 			  else
-			    no_data = herrno == NO_DATA;
+			    no_data = h_errno == NO_DATA;
 			  break;
 			}
 
@@ -938,13 +929,17 @@ gaih_inet (const char *name, const struct gaih_service *service,
 		    }
 		  else
 		    {
+		      /* Could not locate any of the lookup functions.
+			 The NSS lookup code does not consistently set
+			 errno, so we need to supply our own error
+			 code here.  The root cause could either be a
+			 resource allocation failure, or a missing
+			 service function in the DSO (so it should not
+			 be listed in /etc/nsswitch.conf).  Assume the
+			 former, and return EBUSY.  */
 		      status = NSS_STATUS_UNAVAIL;
-		      /* Could not load any of the lookup functions.  Indicate
-		         an internal error if the failure was due to a system
-			 error other than the file not being found.  We use the
-			 errno from the last failed callback.  */
-		      if (errno != 0 && errno != ENOENT)
-			__set_h_errno (NETDB_INTERNAL);
+		     __set_h_errno (NETDB_INTERNAL);
+		     __set_errno (EBUSY);
 		    }
 		}
 
@@ -960,7 +955,10 @@ gaih_inet (const char *name, const struct gaih_service *service,
 	  __resolv_context_enable_inet6 (res_ctx, res_enable_inet6);
 	  __resolv_context_put (res_ctx);
 
-	  if (h_errno == NETDB_INTERNAL)
+	  /* If we have a failure which sets errno, report it using
+	     EAI_SYSTEM.  */
+	  if ((status == NSS_STATUS_TRYAGAIN || status == NSS_STATUS_UNAVAIL)
+	      && h_errno == NETDB_INTERNAL)
 	    {
 	      result = -EAI_SYSTEM;
 	      goto free_and_return;
diff --git a/sysdeps/posix/preadv2.c b/sysdeps/posix/preadv2.c
index 2a7cf11e27..d27f7028ed 100644
--- a/sysdeps/posix/preadv2.c
+++ b/sysdeps/posix/preadv2.c
@@ -28,7 +28,7 @@ preadv2 (int fd, const struct iovec *vector, int count, OFF_T offset,
 {
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
 
diff --git a/sysdeps/posix/preadv64v2.c b/sysdeps/posix/preadv64v2.c
index e084f3f9e1..ce7cb40bf2 100644
--- a/sysdeps/posix/preadv64v2.c
+++ b/sysdeps/posix/preadv64v2.c
@@ -25,7 +25,7 @@ preadv64v2 (int fd, const struct iovec *vector, int count, OFF_T offset,
 {
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
 
diff --git a/sysdeps/posix/pwritev2.c b/sysdeps/posix/pwritev2.c
index 5b7650c4fc..7ec8cbc407 100644
--- a/sysdeps/posix/pwritev2.c
+++ b/sysdeps/posix/pwritev2.c
@@ -28,7 +28,7 @@ pwritev2 (int fd, const struct iovec *vector, int count, OFF_T offset,
 {
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
 
diff --git a/sysdeps/posix/pwritev64v2.c b/sysdeps/posix/pwritev64v2.c
index 0f2f9ef863..be98aeed9d 100644
--- a/sysdeps/posix/pwritev64v2.c
+++ b/sysdeps/posix/pwritev64v2.c
@@ -26,7 +26,7 @@ pwritev64v2 (int fd, const struct iovec *vector, int count, OFF_T offset,
 {
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
 
diff --git a/sysdeps/powerpc/Makefile b/sysdeps/powerpc/Makefile
index 0d9206bec4..6aa683b03f 100644
--- a/sysdeps/powerpc/Makefile
+++ b/sysdeps/powerpc/Makefile
@@ -8,9 +8,11 @@ sysdep-dl-routines += dl-machine hwcapinfo
 sysdep_routines += dl-machine hwcapinfo
 # extra shared linker files to link only into dl-allobjs.so
 sysdep-rtld-routines += dl-machine hwcapinfo
-# Don't optimize GD tls sequence to LE.
-LDFLAGS-tst-tlsopt-powerpc += -Wl,--no-tls-optimize
+
+modules-names += mod-tlsopt-powerpc
+mod-tlsopt-powerpc.so-no-z-defs = yes
 tests += tst-tlsopt-powerpc
+$(objpfx)tst-tlsopt-powerpc: $(objpfx)mod-tlsopt-powerpc.so
 
 ifneq (no,$(multi-arch))
 tests-static += tst-tlsifunc-static
diff --git a/sysdeps/powerpc/fpu/math_private.h b/sysdeps/powerpc/fpu/math_private.h
index d8fd4923ac..396fd0562e 100644
--- a/sysdeps/powerpc/fpu/math_private.h
+++ b/sysdeps/powerpc/fpu/math_private.h
@@ -30,7 +30,7 @@ extern __always_inline _Float128
 __ieee754_sqrtf128 (_Float128 __x)
 {
   _Float128 __z;
-  asm ("xssqrtqp %0,%1" : "=wq" (__z) : "wq" (__x));
+  asm ("xssqrtqp %0,%1" : "=v" (__z) : "v" (__x));
   return __z;
 }
 #endif
diff --git a/sysdeps/powerpc/mod-tlsopt-powerpc.c b/sysdeps/powerpc/mod-tlsopt-powerpc.c
new file mode 100644
index 0000000000..ee0db12a73
--- /dev/null
+++ b/sysdeps/powerpc/mod-tlsopt-powerpc.c
@@ -0,0 +1,49 @@
+/* shared library to test for __tls_get_addr optimization.  */
+#include <stdio.h>
+
+#include "../../elf/tls-macros.h"
+#include "dl-tls.h"
+
+/* common 'int' variable in TLS.  */
+COMMON_INT_DEF(foo);
+
+
+int
+tls_get_addr_opt_test (void)
+{
+  int result = 0;
+
+  /* Get variable using general dynamic model.  */
+  int *ap = TLS_GD (foo);
+  if (*ap != 0)
+    {
+      printf ("foo = %d\n", *ap);
+      result = 1;
+    }
+
+  tls_index *tls_arg;
+#ifdef __powerpc64__
+  register unsigned long thread_pointer __asm__ ("r13");
+  asm ("addi %0,2,foo@got@tlsgd" : "=r" (tls_arg));
+#else
+  register unsigned long thread_pointer __asm__ ("r2");
+  asm ("bcl 20,31,1f\n1:\t"
+       "mflr %0\n\t"
+       "addis %0,%0,_GLOBAL_OFFSET_TABLE_-1b@ha\n\t"
+       "addi %0,%0,_GLOBAL_OFFSET_TABLE_-1b@l\n\t"
+       "addi %0,%0,foo@got@tlsgd" : "=b" (tls_arg));
+#endif
+
+  if (tls_arg->ti_module != 0)
+    {
+      printf ("tls_index not optimized, binutils too old?\n");
+      result = 1;
+    }
+  else if (tls_arg->ti_offset + thread_pointer != (unsigned long) ap)
+    {
+      printf ("tls_index->ti_offset wrong value\n");
+      result = 1;
+    }
+
+  return result;
+}
diff --git a/sysdeps/powerpc/powerpc64/tls-macros.h b/sysdeps/powerpc/powerpc64/tls-macros.h
index 42a95ec5c1..79a0b2579c 100644
--- a/sysdeps/powerpc/powerpc64/tls-macros.h
+++ b/sysdeps/powerpc/powerpc64/tls-macros.h
@@ -18,13 +18,11 @@
      __result;								      \
   })
 
-#define __TLS_GET_ADDR "__tls_get_addr"
-
 /* PowerPC64 Local Dynamic TLS access.  */
 #define TLS_LD(x)							      \
   ({ int * __result;							      \
      asm ("addi  3,2," #x "@got@tlsld\n\t"				      \
-	  "bl    " __TLS_GET_ADDR "\n\t"				      \
+	  "bl    __tls_get_addr\n\t"					      \
 	  "nop   \n\t"							      \
 	  "addis %0,3," #x "@dtprel@ha\n\t"				      \
 	  "addi  %0,%0," #x "@dtprel@l"					      \
@@ -36,7 +34,7 @@
 #define TLS_GD(x)							      \
   ({ register int *__result __asm__ ("r3");				      \
      asm ("addi  3,2," #x "@got@tlsgd\n\t"				      \
-	  "bl    " __TLS_GET_ADDR "\n\t"				      \
+	  "bl    __tls_get_addr\n\t"					      \
 	  "nop   "							      \
 	  : "=r" (__result) :						      \
 	  : __TLS_CALL_CLOBBERS);					      \
diff --git a/sysdeps/powerpc/powerpc64le/Makefile b/sysdeps/powerpc/powerpc64le/Makefile
index 77617b670a..cf2dbfb673 100644
--- a/sysdeps/powerpc/powerpc64le/Makefile
+++ b/sysdeps/powerpc/powerpc64le/Makefile
@@ -16,7 +16,10 @@ $(foreach suf,$(all-object-suffixes),%f128_r$(suf)): CFLAGS += -mfloat128
 $(foreach suf,$(all-object-suffixes),$(objpfx)test-float128%$(suf)): CFLAGS += -mfloat128
 $(foreach suf,$(all-object-suffixes),$(objpfx)test-ifloat128%$(suf)): CFLAGS += -mfloat128
 CFLAGS-libm-test-support-float128.c += -mfloat128
-$(objpfx)test-float128% $(objpfx)test-ifloat128%: \
+CFLAGS-test-math-iscanonical.cc += -mfloat128
+CFLAGS-test-math-issignaling.cc += -mfloat128
+CFLAGS-test-math-iszero.cc += -mfloat128
+$(objpfx)test-float128% $(objpfx)test-ifloat128% $(objpfx)test-math-iszero: \
   gnulib-tests += $(f128-loader-link)
 endif
 
diff --git a/sysdeps/powerpc/powerpc64le/power9/fpu/e_sqrtf128.c b/sysdeps/powerpc/powerpc64le/power9/fpu/e_sqrtf128.c
index 769d3f8922..59fd8269f5 100644
--- a/sysdeps/powerpc/powerpc64le/power9/fpu/e_sqrtf128.c
+++ b/sysdeps/powerpc/powerpc64le/power9/fpu/e_sqrtf128.c
@@ -30,7 +30,7 @@ __float128
 __ieee754_sqrtf128 (__float128 a)
 {
   __float128 z;
-  asm ("xssqrtqp %0,%1" : "=wq" (z) : "wq" (a));
+  asm ("xssqrtqp %0,%1" : "=v" (z) : "v" (a));
   return z;
 }
 strong_alias (__ieee754_sqrtf128, __sqrtf128_finite)
diff --git a/sysdeps/powerpc/tst-tlsopt-powerpc.c b/sysdeps/powerpc/tst-tlsopt-powerpc.c
index 8ae928a3f4..cc682b2ed0 100644
--- a/sysdeps/powerpc/tst-tlsopt-powerpc.c
+++ b/sysdeps/powerpc/tst-tlsopt-powerpc.c
@@ -1,51 +1,11 @@
 /* glibc test for __tls_get_addr optimization.  */
-#include <stdio.h>
-
-#include "../../elf/tls-macros.h"
-#include "dl-tls.h"
-
-/* common 'int' variable in TLS.  */
-COMMON_INT_DEF(foo);
-
 
 static int
 do_test (void)
 {
-  int result = 0;
-
-  /* Get variable using general dynamic model.  */
-  int *ap = TLS_GD (foo);
-  if (*ap != 0)
-    {
-      printf ("foo = %d\n", *ap);
-      result = 1;
-    }
-
-  tls_index *tls_arg;
-#ifdef __powerpc64__
-  register unsigned long thread_pointer __asm__ ("r13");
-  asm ("addi %0,2,foo@got@tlsgd" : "=r" (tls_arg));
-#else
-  register unsigned long thread_pointer __asm__ ("r2");
-  asm ("bcl 20,31,1f\n1:\t"
-       "mflr %0\n\t"
-       "addis %0,%0,_GLOBAL_OFFSET_TABLE_-1b@ha\n\t"
-       "addi %0,%0,_GLOBAL_OFFSET_TABLE_-1b@l\n\t"
-       "addi %0,%0,foo@got@tlsgd" : "=b" (tls_arg));
-#endif
-
-  if (tls_arg->ti_module != 0)
-    {
-      printf ("tls_index not optimized, binutils too old?\n");
-      result = 1;
-    }
-  else if (tls_arg->ti_offset + thread_pointer != (unsigned long) ap)
-    {
-      printf ("tls_index->ti_offset wrong value\n");
-      result = 1;
-    }
+  extern int tls_get_addr_opt_test (void);
 
-  return result;
+  return tls_get_addr_opt_test ();
 }
 
 #include <support/test-driver.c>
diff --git a/sysdeps/unix/sysv/linux/aarch64/cpu-features.c b/sysdeps/unix/sysv/linux/aarch64/cpu-features.c
index 0275d11c7f..0c7e13f4fa 100644
--- a/sysdeps/unix/sysv/linux/aarch64/cpu-features.c
+++ b/sysdeps/unix/sysv/linux/aarch64/cpu-features.c
@@ -28,6 +28,7 @@ struct cpu_list
 };
 
 static struct cpu_list cpu_list[] = {
+      {"falkor",	0x510FC000},
       {"thunderxt88",	0x430F0A10},
       {"generic", 	0x0}
 };
@@ -36,7 +37,7 @@ static uint64_t
 get_midr_from_mcpu (const char *mcpu)
 {
   for (int i = 0; i < sizeof (cpu_list) / sizeof (struct cpu_list); i++)
-    if (tunable_is_name (mcpu, cpu_list[i].name) == 0)
+    if (strcmp (mcpu, cpu_list[i].name) == 0)
       return cpu_list[i].midr;
 
   return UINT64_MAX;
diff --git a/sysdeps/unix/sysv/linux/aarch64/cpu-features.h b/sysdeps/unix/sysv/linux/aarch64/cpu-features.h
index c92b650984..73cb53da9a 100644
--- a/sysdeps/unix/sysv/linux/aarch64/cpu-features.h
+++ b/sysdeps/unix/sysv/linux/aarch64/cpu-features.h
@@ -41,6 +41,9 @@
 #define IS_THUNDERX(midr) (MIDR_IMPLEMENTOR(midr) == 'C'	\
 			   && MIDR_PARTNUM(midr) == 0x0a1)
 
+#define IS_FALKOR(midr) (MIDR_IMPLEMENTOR(midr) == 'Q'			      \
+                        && MIDR_PARTNUM(midr) == 0xc00)
+
 struct cpu_features
 {
   uint64_t midr_el1;
diff --git a/sysdeps/unix/sysv/linux/preadv2.c b/sysdeps/unix/sysv/linux/preadv2.c
index 11fe85eaa8..137e2dd791 100644
--- a/sysdeps/unix/sysv/linux/preadv2.c
+++ b/sysdeps/unix/sysv/linux/preadv2.c
@@ -32,7 +32,7 @@ preadv2 (int fd, const struct iovec *vector, int count, off_t offset,
 # ifdef __NR_preadv2
   ssize_t result = SYSCALL_CANCEL (preadv2, fd, vector, count,
 				   LO_HI_LONG (offset), flags);
-  if (result >= 0 || errno != ENOSYS)
+  if (result >= 0)
     return result;
 # endif
   /* Trying to emulate the preadv2 syscall flags is troublesome:
@@ -46,7 +46,7 @@ preadv2 (int fd, const struct iovec *vector, int count, off_t offset,
 
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
   return preadv (fd, vector, count, offset);
diff --git a/sysdeps/unix/sysv/linux/preadv64v2.c b/sysdeps/unix/sysv/linux/preadv64v2.c
index 9d7f8c9893..8f413253f4 100644
--- a/sysdeps/unix/sysv/linux/preadv64v2.c
+++ b/sysdeps/unix/sysv/linux/preadv64v2.c
@@ -30,7 +30,7 @@ preadv64v2 (int fd, const struct iovec *vector, int count, off64_t offset,
 #ifdef __NR_preadv64v2
   ssize_t result = SYSCALL_CANCEL (preadv64v2, fd, vector, count,
 				   LO_HI_LONG (offset), flags);
-  if (result >= 0 || errno != ENOSYS)
+  if (result >= 0)
     return result;
 #endif
   /* Trying to emulate the preadv2 syscall flags is troublesome:
@@ -44,7 +44,7 @@ preadv64v2 (int fd, const struct iovec *vector, int count, off64_t offset,
 
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
   return preadv64 (fd, vector, count, offset);
diff --git a/sysdeps/unix/sysv/linux/pwritev2.c b/sysdeps/unix/sysv/linux/pwritev2.c
index 72f0471f96..8e5032fe2f 100644
--- a/sysdeps/unix/sysv/linux/pwritev2.c
+++ b/sysdeps/unix/sysv/linux/pwritev2.c
@@ -28,7 +28,7 @@ pwritev2 (int fd, const struct iovec *vector, int count, off_t offset,
 # ifdef __NR_pwritev2
   ssize_t result = SYSCALL_CANCEL (pwritev2, fd, vector, count,
 				   LO_HI_LONG (offset), flags);
-  if (result >= 0 || errno != ENOSYS)
+  if (result >= 0)
     return result;
 # endif
   /* Trying to emulate the pwritev2 syscall flags is troublesome:
@@ -42,7 +42,7 @@ pwritev2 (int fd, const struct iovec *vector, int count, off_t offset,
 
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
   return pwritev (fd, vector, count, offset);
diff --git a/sysdeps/unix/sysv/linux/pwritev64v2.c b/sysdeps/unix/sysv/linux/pwritev64v2.c
index def9a0bc57..d2800c6657 100644
--- a/sysdeps/unix/sysv/linux/pwritev64v2.c
+++ b/sysdeps/unix/sysv/linux/pwritev64v2.c
@@ -30,7 +30,7 @@ pwritev64v2 (int fd, const struct iovec *vector, int count, off64_t offset,
 #ifdef __NR_pwritev64v2
   ssize_t result = SYSCALL_CANCEL (pwritev64v2, fd, vector, count,
 				   LO_HI_LONG (offset), flags);
-  if (result >= 0 || errno != ENOSYS)
+  if (result >= 0)
     return result;
 #endif
   /* Trying to emulate the pwritev2 syscall flags is troublesome:
@@ -44,7 +44,7 @@ pwritev64v2 (int fd, const struct iovec *vector, int count, off64_t offset,
 
   if (flags != 0)
     {
-      __set_errno (EOPNOTSUPP);
+      __set_errno (ENOTSUP);
       return -1;
     }
   return pwritev64 (fd, vector, count, offset);
diff --git a/sysdeps/unix/sysv/linux/sparc/bits/long-double.h b/sysdeps/unix/sysv/linux/sparc/bits/long-double.h
deleted file mode 100644
index 094e05124b..0000000000
--- a/sysdeps/unix/sysv/linux/sparc/bits/long-double.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/* Properties of long double type.  SPARC version.
-   Copyright (C) 2016-2017 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License  published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <bits/wordsize.h>
-
-#if !defined __NO_LONG_DOUBLE_MATH && __WORDSIZE == 32
-# define __LONG_DOUBLE_MATH_OPTIONAL   1
-# ifndef __LONG_DOUBLE_128__
-#  define __NO_LONG_DOUBLE_MATH        1
-# endif
-#endif
diff --git a/sysdeps/unix/sysv/linux/sparc/sparc32/bits/long-double.h b/sysdeps/unix/sysv/linux/sparc/sparc32/bits/long-double.h
new file mode 100644
index 0000000000..094e05124b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sparc/sparc32/bits/long-double.h
@@ -0,0 +1,26 @@
+/* Properties of long double type.  SPARC version.
+   Copyright (C) 2016-2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License  published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <bits/wordsize.h>
+
+#if !defined __NO_LONG_DOUBLE_MATH && __WORDSIZE == 32
+# define __LONG_DOUBLE_MATH_OPTIONAL   1
+# ifndef __LONG_DOUBLE_128__
+#  define __NO_LONG_DOUBLE_MATH        1
+# endif
+#endif
diff --git a/sysdeps/unix/sysv/linux/sparc/sparc64/bits/long-double.h b/sysdeps/unix/sysv/linux/sparc/sparc64/bits/long-double.h
new file mode 100644
index 0000000000..094e05124b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/sparc/sparc64/bits/long-double.h
@@ -0,0 +1,26 @@
+/* Properties of long double type.  SPARC version.
+   Copyright (C) 2016-2017 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License  published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <bits/wordsize.h>
+
+#if !defined __NO_LONG_DOUBLE_MATH && __WORDSIZE == 32
+# define __LONG_DOUBLE_MATH_OPTIONAL   1
+# ifndef __LONG_DOUBLE_128__
+#  define __NO_LONG_DOUBLE_MATH        1
+# endif
+#endif
diff --git a/sysdeps/x86/cpu-features.c b/sysdeps/x86/cpu-features.c
index 1d087ea732..6f900840d4 100644
--- a/sysdeps/x86/cpu-features.c
+++ b/sysdeps/x86/cpu-features.c
@@ -244,10 +244,13 @@ init_cpu_features (struct cpu_features *cpu_features)
 	  |= bit_arch_Prefer_No_AVX512;
 
       /* To avoid SSE transition penalty, use _dl_runtime_resolve_slow.
-         If XGETBV suports ECX == 1, use _dl_runtime_resolve_opt.  */
+         If XGETBV suports ECX == 1, use _dl_runtime_resolve_opt.
+	 Use _dl_runtime_resolve_opt only with AVX512F since it is
+	 slower than _dl_runtime_resolve_slow with AVX.  */
       cpu_features->feature[index_arch_Use_dl_runtime_resolve_slow]
 	|= bit_arch_Use_dl_runtime_resolve_slow;
-      if (cpu_features->max_cpuid >= 0xd)
+      if (CPU_FEATURES_ARCH_P (cpu_features, AVX512F_Usable)
+	  && cpu_features->max_cpuid >= 0xd)
 	{
 	  unsigned int eax;
 
diff --git a/sysdeps/x86_64/fpu/libm-test-ulps b/sysdeps/x86_64/fpu/libm-test-ulps
index c347642044..1e28aaa9f1 100644
--- a/sysdeps/x86_64/fpu/libm-test-ulps
+++ b/sysdeps/x86_64/fpu/libm-test-ulps
@@ -1733,10 +1733,10 @@ ldouble: 3
 
 Function: Imaginary part of "ctan_upward":
 double: 2
-float: 1
+float: 2
 float128: 5
 idouble: 2
-ifloat: 1
+ifloat: 2
 ifloat128: 5
 ildouble: 3
 ldouble: 3
