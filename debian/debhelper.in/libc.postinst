#!/bin/bash
set -e
export LC_ALL=C

type=$1
preversion=$2

package_name()
{
    echo LIBC
}

zone_banner() {
    TZBase=$(LC_ALL=C TZ=UTC0 date)
    UTdate=$(TZ=UTC0 date -d "$TZBase")
    TZdate=$(TZ="$timezone" date -d "$TZBase")
    extra_info="
Local time is now:      $TZdate.
Universal Time is now:  $UTdate."
    echo "Current default timezone: '$timezone'.$extra_info"
    echo "Run 'tzconfig' if you wish to change it."
}

set_timezone() {
    frontend=`echo "$DEBIAN_FRONTEND" | tr '[:upper:]' '[:lower:]'`
    if [ "$frontend" = noninteractive ]; then
        echo "Non-interactive mode, setting timezone to UTC.  Run tzconfig to change."
        echo "UTC" >/etc/timezone
        ln -sf /usr/share/zoneinfo/UTC /etc/localtime
    else
        echo "Running 'tzconfig' to set this system's timezone."
        /usr/sbin/tzconfig
    fi
}

# Borrowed from sysvinit's postinst.
#	Function like update-rc.d but simpler & faster.
#	Usage: updatercd basename start|stop NN runlevel .
#
#	Now we use the real update-rc.d, so now this function should
#	be equivalent to /usr/sbin/update-rc.d.
#
updatercd() {

	if [ ! -f /etc/init.d/$1 ]
	then
		return
	fi

	if [ -x /usr/sbin/update-rc.d ]
	then
		update-rc.d "$@" > /dev/null
		return $?
	fi

	base=$1
	shift
	while [ "$1" != "" ]
	do
		if [ "$1" = stop ]
		then
			tlet=K
		else
			tlet=S
		fi
		lev=$2
		shift 2
		while [ "$1" != "." ]
		do
			cd /etc/rc$1.d
			tmp="`echo $tlet??$base`"
			case "$tmp" in
				"$tlet??$base")
					# Not present yet.
					ln -s ../init.d/$base $tlet$lev$base
					;;
				*)
					# Already present.
					;;
			esac
			shift
		done
		shift
	done
}

realpath()
{
    fname=${1%/} # strips trailing '/'
    while [ -L "$fname" ]; do
	oldfname="$fname"
	fname="$(command ls -l $fname)"
	fname="${fname#*\> }"
	if [ "$fname" = . ] ; then
	    fname="$(dirname $oldfname)"
	elif echo $fname | grep -vq '^/' - ; then
	    fname="$(dirname $oldfname)/$fname"
	fi
    done
    pushd $(dirname $fname) > /dev/null
    fname=$(pwd -P)/$(basename $fname)
    popd > /dev/null
    echo $fname
}

# element() is a helper function for file-rc:
element() {
    local element list IFS

    element="$1"

    [ "$2" = "in" ] && shift
    list="$2"
    [ "$list" = "-" ] && return 1
    [ "$list" = "*" ] && return 0

    IFS=","
    set -- $list
    case $element in
	"$1"|"$2"|"$3"|"$4"|"$5"|"$6"|"$7"|"$8"|"$9")
	    return 0
    esac
    return 1
}

# filerc (runlevel, service) returns /etc/init.d/service, if service is
# running in $runlevel:
filerc() {
    local runlevel basename
    runlevel=$1
    basename=$2
    while read LINE
    do
	case $LINE in
	    \#*|"") continue
	esac

	set -- $LINE
	SORT_NO="$1"; STOP="$2"; START="$3"; CMD="$4"
	[ "$CMD" = "/etc/init.d/$basename" ] || continue

	if element "$runlevel" in "$START" || element "S" in "$START"
	then
	    echo "/etc/init.d/$basename"
	    return 0
	fi
    done < /etc/runlevel.conf
    echo ""
}

checkpkgver () {
    local status pkg
    pkg=$1
    status=$(dpkg -s $pkg 2>/dev/null | grep ^Status: | sed -e 's/^Status: \(.*\) \(.*\) \(.*\)/\3/g')
    if [ -n "$status" ] && [ "$status" != "not-installed" ] && [ "$status" != "config-files" ]; then
	echo $(dpkg -s $pkg 2>/dev/null | grep ^Version: | sed -e 's/^Version: *//');
    fi
}

# We remove a relic of the past /usr/doc/<package> symlinks.
# This script should keep at least until sarge release.
package=LIBC
if [ -L "/usr/doc/$package" ]; then
    rm -f "/usr/doc/$package"
fi
# I'm so lazy that libc6-{dbg,dev,pic,prof} are removed in this file - gotom.
for suffix in -dbg -dev -pic -prof; do
    package_name="$package""$suffix"
    if [ -L "/usr/doc/$package_name" ]; then
	rm -f "/usr/doc/$package_name"
    fi
done

if [ "$type" = "configure" ]
then
    # Handle upgrades for libdb.so.3. We do this before calling ldconfig,
    # since it will create a symlink for us. Just move everything over. We
    # use `cat' because I feel it is simpler and safer. Make sure that
    # libdb.so.3 is either a symlink, or non-existent, just in case
    # something weird happened and the new libdb2 is unpacked before we
    # get here.
    if [ -e /lib/libdb.so.3.old ]; then
	if [ -L /lib/libdb.so.3 -o ! -e /lib/libdb.so.3 ]; then
	    rm -f /lib/libdb.so.3
	    cat /lib/libdb.so.3.old > /lib/libdb.so.3
	fi
	rm -f /lib/libdb.so.3.old
    fi

    # Handle upgrades when libc-opt package has been installed.
    # We check the version between the current installed libc and libc-opt.
    # If they're unmatched, we keep /etc/ld.so.nohwcap file until libc-opt
    # package is installed or removed.
    if [ -f /etc/ld.so.nohwcap ]; then
	# We check the availability of ld.so.hwcappkgs.  If it's not existed,
	# it's first time to install ld.so.hwcappkgs aware packages.  We record
	# all current hwcap package status.
	if [ ! -f /etc/ld.so.hwcappkgs ]; then
	    case $(dpkg --print-architecture) in
		i386)
		    hwcappkgs="libc6 libc6-i686"
		    ;;
		sparc)
		    hwcappkgs="libc6 libc6-sparcv9 libc6-sparcv9b"
		    ;;
	    esac
	    if [ -n "$hwcappkgs" ]; then
		for pkg in $hwcappkgs; do
		    ver=$(checkpkgver $pkg)
		    if [ -n "$ver" ]; then
			echo "$pkg $ver" >> /etc/ld.so.hwcappkgs
			new_hwcappkgs=yes
		    fi
		done
	    fi
	fi

	# If ld.so.hwcappkgs is existed, it may have one or more opt packages.
	# Update the current package's version, and compare the consistency of
	# those optimized packages.  If inconsistency is found, keep
	# /etc/ld.so.nohwcap.
	if [ -f /etc/ld.so.hwcappkgs ]; then
	    curver=CURRENT_VER
	    rm -f /etc/ld.so.hwcappkgs.tmp
	    while read LINE; do
		case $LINE in
		    \#*|"") continue
		esac
		set -- $LINE
		pkg=$1; ver=$2
		if [ "$pkg" = "$package" ]; then
		    # libc6
		    ver=$curver
		    isrecorded=yes
		else
		    if [ "$new_hwcappkgs" != yes ]; then
			ver=$(checkpkgver $pkg)
		    fi
		    if [ -z "$ver" ]; then
			continue
		    fi
		    dpkg --compare-versions $curver ne $ver && optunmatch=yes
		fi
		echo "$pkg $ver" >> /etc/ld.so.hwcappkgs.tmp
	    done < /etc/ld.so.hwcappkgs
	    if [ "$isrecorded" != yes ]; then
		echo "$package $curver" >> /etc/ld.so.hwcappkgs.tmp
	    fi
	    mv /etc/ld.so.hwcappkgs.tmp /etc/ld.so.hwcappkgs
	fi

	# nohwcap during upgrade.
	egrep -v '^glibc$|^downgrade-to-old-glibc$' /etc/ld.so.nohwcap > /etc/ld.so.nohwcap.tmp || true
	mv /etc/ld.so.nohwcap.tmp /etc/ld.so.nohwcap
	if [ "$optunmatch" != "yes" ]; then
	    test -s /etc/ld.so.nohwcap || rm -f /etc/ld.so.nohwcap
	fi
    fi

    if [ ! -z $preversion ]; then
	if [ ! -d /var/mail ] && [ ! -L /var/mail ]; then
	    ln -sf spool/mail /var/mail
	fi
	if dpkg --compare-versions $preversion lt 2.3.5-1; then
	    echo -n "Checking for services that may need to be restarted..."

	    check="nis smail sendmail exim ssh netbase"
	    check="$check ssh-nonfree postfix-tls wu-ftpd boa cron postfix"
	    check="$check wu-ftpd-academ vsftpd slapd openldapd wwwoffle"
	    check="$check cupsys lprng lpr lpr-ppd autofs snmpd ssh-krb5"
	    check="$check courier-authdaemon mysql-server spamassassin"
	    check="$check apache apache-ssl apache-perl apache2-common"
	    check="$check proftpd proftpd-ldap proftpd-mysql proftpd-pgsql"
	    check="$check dovecot-common cucipop rsync samba saslauthd"
	    # Only get the ones that are installed, and configured
	    check=$(dpkg -s $check 2> /dev/null | egrep '^Package:|^Status:' | awk '{if ($1 ~ /^Package:/) { package=$2 } else if ($0 ~ /^Status: .* installed$/) { print package }}')
	    # apache2 ships its init script in apache2-common, but the
	    # script is apache2
	    check=$(echo $check | sed 's/apache2-common/apache2/g')
	    # The name of proftpd-{ldap,mysql,pgsql} init script is
	    # same as "proftpd".
	    check=$(echo $check | sed 's/proftpd-.*/proftpd/g')
	    # dovecot-common ships its init script, but the
	    # script name is dovecot for dovecot-{imapd,pop3d}.
	    check=$(echo $check | sed 's/dovecot-common/dovecot/g')
	    # lpr and lpr-ppd ship its init script, but the 
	    # script name is lpd and lpd-ppd.  The inserted space is
	    # intentional to not replace lprng.
	    check=$(echo $check | sed 's/lpr /lpd /g')
	    check=$(echo $check | sed 's/lpr-ppd /lpd-ppd /g')
	    # We have to list inetd and atd explicitly, because the packages
	    # have different names to their init scripts
	    check="$check inetd atd"
	    rl=$(runlevel | awk '{print $2}')
	    for service in $check; do
		if [ -f /usr/share/file-rc/rc -o -f /usr/lib/file-rc/rc ] && [ -f /etc/runlevel.conf ]; then
		    idl=$(filerc $rl $service)
		else
		    idl=$(ls /etc/rc${rl}.d/S??${service} 2> /dev/null | head -1)
		fi
		if [ -n "$idl" ] && [ -x $idl ]; then
		    services="$service $services"
		fi
	    done
	    echo "done."
	    if [ -n "$services" ]; then
		echo
		echo "Name Service Switch update in the C Library: post-installation question."
		echo
		echo "Running services and programs that are using NSS need to be restarted,"
		echo "otherwise they might not be able to do lookup or authentication any more"
		echo "(for services such as ssh, this can affect your ability to login)."
		echo "Note: restarting sshd/telnetd should not affect any existing connections."
		echo
		echo "The services detected are: "
		echo "        $services"
		echo
		echo "If other services have begun to fail mysteriously after this upgrade, it is"
		echo "probably necessary to restart them too.  We recommend you to reboot your"
		echo "machine after the upgrade to avoid the NSS related trouble."
		echo
		frontend=`echo "$DEBIAN_FRONTEND" | tr '[:upper:]' '[:lower:]'`
		if [ "$frontend" = noninteractive ]; then
		    echo "Non-interactive mode, restarting services"
		    answer=yes
		else
		    echo -n "Do you wish to restart services? [Y/n] "
		    read answer
		    case $answer in
			Y*|y*) answer=yes ;;
			N*|n*) answer=no ;;
			*) answer=yes ;;
		    esac
		fi
		echo
		if [ "$answer" = yes ] && [ "$services" != "" ]; then
		    echo "Restarting services possibly affected by the upgrade:"
		    failed=""
		    for service in $services; do
			if [ -f /usr/share/file-rc/rc -o -f /usr/lib/file-rc/rc ] && [ -f /etc/runlevel.conf ]; then
			    idl=$(filerc $rl $service)
			else
			    idl=$(ls /etc/rc${rl}.d/S??${service} 2> /dev/null | head -1)
			fi
			echo -n "  $service: stopping..."
			$idl stop > /dev/null 2>&1 || true
			sleep 2
			echo -n "starting..."
			if $idl start > /dev/null 2>&1; then
			    echo "done."
			else
			    echo "FAILED! ($?)"
			    failed="$service $failed"
			fi
		    done
		    echo
		    if [ -n "$failed" ]; then
			# Ruh roh, George
			echo "The following services failed to start: $failed"
			echo
			echo "You will need to start these manually by running \`/etc/init.d/<service> start'"
			echo "If the service still fails to start, you may need to file a bug on"
			echo "$(package_name) or the service involved."
			if [ "$DEBIAN_FRONTEND" != noninteractive ]; then
			    echo
			    echo -n "Press ENTER to continue: "
			    read foo
			fi
		    else
			echo "Services restarted successfully."
		    fi
		    echo
		fi
	    fi
	fi # end upgrading and $preversion lt 2.3.5-1
    fi # Upgrading
    if [ -f /etc/timezone.save ]; then
	mv -fb /etc/timezone.save /etc/timezone
    fi
    if [ -f /etc/timezone ]; then
	timezone=$(cat /etc/timezone)
    else
	timezone=Factory
    fi
    if [ "$timezone" = Factory ]; then
	if [ -L /etc/localtime ]; then
	    localtime_link=$(realpath /etc/localtime)
	    if [ -f "$localtime_link" ]; then
		link_not_dangling=true
	    fi
	    if [ "$link_not_dangling" = true ]; then
		timezone=$(echo $localtime_link | sed 's%^/usr/share/zoneinfo/%%')
	    fi
	fi
    fi
    if [ -f /usr/share/zoneinfo/$timezone ] && [ "$timezone" != Factory ]
    then
#	zic -l $timezone
	rm -f /etc/localtime && \
	ln -sf /usr/share/zoneinfo/$timezone /etc/localtime
	zone_banner
    # Handle problem caused by lame old tzconfig.
    elif [ "$timezone" = "US/Pacific-New" ]
    then
	echo "US/Pacific" > /etc/timezone
#	zic -l US/Pacific
	rm -f /etc/localtime && \
	ln -sf /usr/share/zoneinfo/US/Pacific /etc/localtime
	zone_banner
    else
	set_timezone
    fi
    if [ "$(date +%Z)" = "/etc/localtime" ]; then
	set_timezone
    fi
#    # DO NOT FOLLOW THIS EXAMPLE IN OTHER PACKAGES
     updatercd glibc.sh start 01 S .
     if [ -x /usr/sbin/invoke-rc.d ]; then
	invoke-rc.d glibc.sh start
     else
	/etc/init.d/glibc.sh 2>/dev/null || true
     fi
fi

if [ "`uname -s`" = Linux ]; then
#
#       Upgrade init if possible. There was a bug in all versions
#       up to and including 2.75-4, which didn't affect i386 but
#       did affect most other architectures.
#
sysvinitver="`dpkg -s sysvinit 2>/dev/null | grep ^Version: | sed -e 's/^Version: *//'`"
case "`uname -m`" in
        i?86)
                badsysvinitver="2.[0-6]*|2.7[0-3]*"
                ;;
        *)
                badsysvinitver="2.[0-6]*|2.7[0-4]*|2.75-*"
                ;;
esac
# Black magic. If we are in a chroot, then /proc/1/exe will not resolve to
# a file (will return EPERM). This keeps us from breaking things in
# debootstrap, and the like.
case "$sysvinitver" in
        $badsysvinitver)
                ;;
        *)
		if [ -x /sbin/init -a -x /bin/readlink ]; then
			if [ "$(readlink /proc/1/exe 2>/dev/null)" = "/sbin/init" ]; then
				(init u ; sleep 1)
			fi
		fi
		;;
esac
fi

#DEBHELPER#

exit 0
